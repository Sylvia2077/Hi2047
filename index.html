<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手机应用界面</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/remixicon@4.2.0/fonts/remixicon.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS变量定义 */
        :root {
            --moments-cover-image: url('https://placehold.co/375x192/333/fff?text=Cover');
            --moments-avatar-image: url('https://placehold.co/128x128/777/FFF?text=Me');
        }

        /* 基础字体样式 */
        body {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Inter', sans-serif;
        }

        /* 字体大小调整 */
        #phone-screen {
            font-size: 15px; /* 中 (默认) */
            transition: font-size 0.2s ease-in-out;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Inter', sans-serif;
        }
        #phone-screen.text-size-small {
            font-size: 13.5px; /* 小 */
        }
        #phone-screen.text-size-large {
            font-size: 16.5px; /* 大 */
        }
        
        /* 應用程式圖示互動效果 */
        .app-icon {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background-size: cover;
            background-position: center;
        }
        .app-icon:hover {
            transform: scale(1.05);
        }
        .app-icon:active {
            transform: scale(0.95);
            box-shadow: none;
        }

        .app-icon-glass {
            background: rgba(55, 65, 81, 0.5); /* bg-gray-600 with 50% opacity */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* 訊息提示框樣式 */
        .message-box {
            position: absolute; /* 相對於父容器phone-screen定位 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem 2rem;
            border-radius: 1rem;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 11000; /* Ensure it's above everything */
        }
        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* 淡入動畫 */
        .animate-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .hidden {
            display: none;
        }
        
        /* 黑膠唱片旋轉動畫 */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .record-spin {
            animation: spin 12s linear infinite;
        }
        /* 接收按钮动画 - 极简优雅版 */
        /* 邮件发送图标闪烁动画 - 保持图标不变，只改变显示效果 */
        @keyframes mail-send-flash {
            0% { opacity: 1; filter: brightness(1); }
            25% { opacity: 0.6; filter: brightness(0.8); }
            50% { opacity: 1; filter: brightness(1.2); }
            75% { opacity: 0.6; filter: brightness(0.8); }
            100% { opacity: 1; filter: brightness(1); }
        }
        
        .spinning {
            animation: mail-send-flash 1.2s ease-in-out infinite;
        }
        
        /* 接收按钮悬停效果 */
        #receive-chat-button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #receive-chat-button:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        #receive-chat-button:active {
            transform: scale(0.98);
        }
        
        /* 隱藏文件輸入框 */
        #music-upload-input, #background-input, #vinyl-input, #widget-image-input, #photo-widget-input, #wallpaper-input, #character-avatar-input, #user-avatar-input, #chat-bg-input, #import-data-input, #image-upload-input, #sticker-upload-input, #user-video-image-input, #my-video-image-input, #moment-image-input {
            display: none;
        }
        
        .music-block-background {
            background-image: url('https://placehold.co/400x150/1a1a1a/ffffff?text=UPLOAD+BACKGROUND');
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        
        .vinyl-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            border-radius: 50%;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .vinyl-image-container {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 67%;
            height: 67%;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background-image: url('https://placehold.co/100x100/000000/ffffff?text=UPLOAD');
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        
        .vinyl-center {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 1rem;
            height: 1rem;
            background-color: #f3f4f6;
            border-radius: 50%;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 9000;
            display: none;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            display: flex;
        }
        .modal-content {
            width: 80%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        .song-list-item {
            padding: 0.75rem 0.5rem;
            border-radius: 0.75rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: default;
        }
        .song-list-item:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .song-list-item.active {
            font-weight: 600;
            color: #ffffff;
        }
        .song-list-item-left {
            display: flex;
            align-items: center;
            flex-grow: 1;
            min-width: 0;
        }
        .song-list-item-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        .drag-handle {
            cursor: grab;
            padding-right: 0.75rem;
            color: #9ca3af;
        }
        .delete-button {
            cursor: pointer;
            transition: color 0.2s;
            padding-left: 0.75rem;
        }
        .delete-button.pending-delete {
            color: #ef4444;
        }

        .player-button {
            transition: color 0.2s;
        }

        .loop-button.active, .single-loop-button.active {
            color: #ffffff;
        }
        
        .text-widget-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            padding: 0.25rem 0;
        }
        
        .image-placeholder {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: cover;
            background-position: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 日夜间模式样式 */
        .dark-mode {
            background-color: #333333;
            color: #ffffff;
        }
        .dark-mode .phone-frame { background-color: #1a1a1a; }
        .dark-mode .phone-screen { background-color: transparent; }
        .dark-mode #home-wallpaper { background-color: #000000; }
        .dark-mode .status-bar, .dark-mode .text-dark, .dark-mode .player-button i, .dark-mode #music-upload-button i, .dark-mode #mood-text::placeholder, .dark-mode #playlist-button i, .dark-mode .text-widget-input::placeholder, .dark-mode .app-header-btn, .dark-mode .quick-action-btn { color: #ffffff; }
        .dark-mode .status-bar { transition: background-color 0.3s; background-color: #1a1a1a; }
        .dark-mode .status-bar.on-home { background-color: transparent !important; }
        .dark-mode .dock, .dark-mode .music-block {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .dark-mode .app-screen-view:not(#home-screen):not(#wechat-chat-screen) { background-color: #1a1a1a; }
        .dark-mode #wechat-chat-screen { background-color: #1a1a1a; }
        .dark-mode .app-header { 
            background-color: rgba(26, 26, 26, 0.9); 
            border-color: rgba(255, 255, 255, 0.15); 
        }
        .dark-mode .wechat-tab-bar { background-color: #2c2c2c; border-color: #4a4a4a; }
        .dark-mode .image-placeholder { background-color: rgba(255, 255, 255, 0.2); }
        .dark-mode .bg-card { background-color: rgba(255, 255, 255, 0.08); }
        .dark-mode .settings-item, .dark-mode .list-item { background-color: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); }
        .dark-mode .wechat-list-item { border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .dark-mode .wechat-list-item:hover { background-color: rgba(255, 255, 255, 0.1); }
        .dark-mode .api-status-on { color: #ffffff; }
        .dark-mode .chat-input-btn { color: #d1d5db; }
        .dark-mode .chat-system-message { background-color: rgba(255, 255, 255, 0.1); }
        
        .light-mode { background-color: white; color: #1f2937; }
        .light-mode .phone-frame { background-color: #1a1a1a; }
        .light-mode .phone-screen { background-color: transparent; }
        .light-mode #home-wallpaper { background: white; }
        .light-mode .status-bar, .light-mode .text-dark, .light-mode .app-header-btn, .light-mode .quick-action-btn { color: #1f2937; }
        .light-mode .status-bar { transition: background-color 0.3s; background-color: #ffffff; }
        .light-mode .status-bar.on-home { background-color: transparent !important; }
        .light-mode .player-button i, .light-mode #music-upload-button i, .light-mode #playlist-button i, .light-mode .text-widget-input::placeholder { color: #1f2937; }
        .light-mode #mood-text { color: #1f2937; }
        .light-mode #mood-text::placeholder { color: #9ca3af; }
        .light-mode .dock, .light-mode .music-block {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .light-mode .app-screen-view:not(#home-screen):not(#wechat-chat-screen) { background-color: white; }
        .light-mode #wechat-chat-screen { background-color: white; }
        .light-mode .app-header { 
            background-color: rgba(255, 255, 255, 0.9); 
            border-color: rgba(0, 0, 0, 0.1); 
        }
        .light-mode .wechat-tab-bar { background-color: #ffffff; border-color: #e5e7eb; }
        .light-mode .image-placeholder { background-color: rgba(0, 0, 0, 0.1); }
        .light-mode .bg-card { background-color: #ffffff; }
        .light-mode .settings-item, .light-mode .list-item { background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .light-mode .wechat-list-item { border-bottom: 1px solid rgba(0, 0, 0, 0.08); }
        .light-mode .wechat-list-item:hover { background-color: rgba(0, 0, 0, 0.05); }
        .light-mode .api-status-on { color: #1f2937; }
        .light-mode .chat-input-btn { color: #4b5563; }
        .light-mode .chat-system-message { background-color: rgba(0, 0, 0, 0.1); }

        /* 聊天界面样式 */
        #wechat-content-chat {
            padding-top: 0.5rem;
        }
        #wechat-content-chat .chat-message-wrapper.new-sender:first-child {
            margin-top: 0.5rem;
        }
        .chat-message-wrapper {
            display: flex;
            align-items: flex-start;
            width: 100%;
            position: relative;
        }
        .chat-message-wrapper.sent {
            justify-content: flex-end;
        }
        .chat-message-wrapper.received {
            justify-content: flex-start;
        }
        .chat-message-wrapper + .chat-message-wrapper {
            margin-top: 0.25rem; 
        }
        .chat-message-wrapper.new-sender {
            margin-top: 1rem;
        }
        .chat-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: #9ca3af;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chat-avatar i {
            font-size: 22px;
            color: rgba(255, 255, 255, 0.8);
        }
        .light-mode .chat-avatar i {
             color: rgba(0, 0, 0, 0.6);
        }
        .chat-message-content {
            display: flex;
            flex-direction: column;
            min-width: 0;
            margin: 0 0.5rem;
            max-width: 75%;
        }
        .chat-message-wrapper.sent .chat-message-content { align-items: flex-end; }
        .chat-message-wrapper.received .chat-message-content { align-items: flex-start; }
        .chat-message {
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border-radius: 1.5rem;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 4px 16px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            padding: 0.35rem 1rem;
            width: -moz-fit-content;
            width: fit-content;
            max-width: 100%; 
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: 
                linear-gradient(135deg, 
                    rgba(255, 255, 255, 0.1) 0%, 
                    rgba(255, 255, 255, 0.05) 50%, 
                    rgba(255, 255, 255, 0.02) 100%
                );
            overflow: hidden;
        }
        
        .chat-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transition: left 0.6s ease;
        }
        
        .chat-message:hover::before {
            left: 100%;
        }
        
        .chat-message:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.18),
                0 6px 20px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }
        .chat-message.image-message, .chat-message.sticker-message {
            padding: 0.25rem;
            background-color: transparent !important;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .chat-message.image-message img, .chat-message.sticker-message img {
            max-width: 150px;
            max-height: 200px;
            border-radius: 1rem;
            display: block;
        }
        .chat-message.sticker-message img {
            max-width: 100px;
            max-height: 100px;
        }
        .chat-message.voice-message {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .voice-main {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .voice-play-icon {
            font-size: 1.25rem;
        }
        .voice-duration {
            font-size: 0.8em;
            white-space: nowrap;
        }
        .voice-text {
            padding-top: 0.5rem;
            margin-top: 0.5rem;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 0.9em;
            display: none;
        }
        .chat-message p, .chat-message i {
            font-size: inherit;
            line-height: 1.5;
        }

        .chat-message.image-message::before, .chat-message.voice-message::before, .chat-message.sticker-message::before, .chat-message.red-packet-message::before, .chat-message.transfer-message::before {
            display: none;
        }
        .chat-message::after {
            content: '';
            position: absolute;
            bottom: 6px;
            width: 14px;
            height: 14px;
            background: inherit;
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 12C5.33333 12 12 5.33333 12 0C12 5.33333 5.33333 12 0 12Z' fill='%23C4C4C4'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 12C5.33333 12 12 5.33333 12 0C12 5.33333 5.33333 12 0 12Z' fill='%23C4C4C4'/%3E%3C/svg%3E");
        }
        .chat-message.image-message::after, .chat-message.sticker-message::after, .chat-message.red-packet-message::after, .chat-message.transfer-message::after {
            display: none;
        }
        .chat-message.sent::after {
            right: -7px;
            transform: scaleX(-1);
            border-radius: 0 0 14px 0;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .chat-message.received::after {
            left: -7px;
            border-radius: 0 0 0 14px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .message-meta {
            font-size: 0.65rem;
            color: #9ca3af;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            margin-bottom: 5px;
            white-space: nowrap;
            align-self: flex-end;
        }
        .chat-message-wrapper.sent .message-meta {
            align-items: flex-end;
        }
        .chat-message-wrapper.received .message-meta {
            align-items: flex-start;
        }
        .message-read-status {
            margin-left: 0;
            display: none;
        }
        .message-read-status.visible {
            display: inline;
        }
        .dark-mode .chat-message { 
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 3px 15px rgba(0,0,0,0.12), 0 1px 6px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        .light-mode .chat-message { 
            border: 1px solid rgba(0, 0, 0, 0.06);
            box-shadow: 0 3px 15px rgba(0,0,0,0.08), 0 1px 6px rgba(0,0,0,0.04), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        /* 用户气泡颜色修改 - 水滴毛玻璃效果 */
        .dark-mode .chat-message.sent { 
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3));
            color: #f3f4f6;
        }
        .light-mode .chat-message.sent { 
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4));
            color: #f3f4f6;
        }
        .dark-mode .chat-message.received { 
            background: linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1));
        }
        .light-mode .chat-message.received { 
            background: linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3));
        }
        .dark-mode .chat-message.sent.image-message, .light-mode .chat-message.sent.image-message { border: 2px solid #4b5563; }
        .dark-mode .chat-message.received.image-message, .light-mode .chat-message.received.image-message { border: 2px solid rgba(229, 231, 250, 0.8); }

        /* ====== 画板样式 ====== */
        .drawing-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .drawing-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .drawing-modal-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .drawing-modal-content {
            background: white;
            border-radius: 20px;
            padding: 0;
            max-width: 350px;
            max-height: 500px;
            width: 90%;
            height: 90%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .drawing-modal-overlay.visible .drawing-modal-content {
            transform: scale(1);
        }

        .drawing-modal-header {
            background: linear-gradient(135deg, #2c2c2c 0%, #666666 50%, #a0a0a0 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 20px 20px 0 0;
        }

        .drawing-modal-title {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .drawing-modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .drawing-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .drawing-board-container {
            padding: 20px;
        }

        #drawing-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            cursor: crosshair;
            background: white;
            display: block;
            margin: 0 auto 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            max-height: 250px;
            width: 100%;
            height: auto;
        }

        .drawing-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            justify-content: center;
            max-width: 280px;
            margin: 0 auto;
        }

        .color-swatch {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .color-swatch.selected {
            border-color: #667eea;
            transform: scale(1.1);
        }

        .brush-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }

        .brush-size-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .brush-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .brush-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        #brush-size-value {
            font-size: 14px;
            color: #6b7280;
            min-width: 40px;
            text-align: center;
        }

        .drawing-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .drawing-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drawing-btn.secondary {
            background: #f3f4f6;
            color: #6b7280;
        }

        .drawing-btn.secondary:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .drawing-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .drawing-btn.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .drawing-modal-content {
                margin: 15px;
                max-width: calc(100% - 30px);
                max-height: calc(100% - 30px);
                width: calc(100% - 30px);
                height: calc(100% - 30px);
            }
            
            #drawing-canvas {
                max-width: 100%;
                max-height: 180px;
            }
            
            .drawing-tools {
                gap: 10px;
            }
            
            .color-palette {
                grid-template-columns: repeat(6, 1fr);
                gap: 5px;
                max-width: 180px;
            }
            
            .color-swatch {
                width: 20px;
                height: 20px;
            }
        }

        /* ====== 塔罗牌样式 ====== */
        /* 确保塔罗牌界面不受其他样式影响 */
        html, body {
            overflow: visible !important;
            position: relative !important;
        }
        
        .tarot-modal-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 20, 0.98) 100%);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 99999 !important;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .tarot-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .tarot-modal-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .tarot-modal-content {
            background: linear-gradient(145deg, #0a0a0a 0%, #1a1a1a 25%, #2a2a2a 50%, #3a3a3a 75%, #1a1a1a 100%);
            border-radius: 25px;
            padding: 0;
            max-width: 420px;
            max-height: 680px;
            width: 90%;
            height: auto;
            min-height: 520px;
            overflow: hidden;
            box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(128, 128, 128, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: scale(0.7) rotateY(-15deg);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
            box-sizing: border-box;
            margin: 0;
        }

        .tarot-modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(128, 128, 128, 0.1) 25%, 
                rgba(64, 64, 64, 0.2) 50%, 
                rgba(128, 128, 128, 0.1) 75%, 
                transparent 100%);
            border-radius: 25px;
            animation: shimmer 3s ease-in-out infinite;
            pointer-events: none;
        }

        .tarot-modal-content::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                #ffffff, #cccccc, #999999, #666666, #ffffff);
            background-size: 400% 400%;
            border-radius: 27px;
            z-index: -1;
            animation: borderGlow 4s ease-in-out infinite;
            opacity: 0.5;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; transform: translateX(-100%); }
            50% { opacity: 0.8; transform: translateX(100%); }
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tarot-modal-overlay.visible .tarot-modal-content {
            transform: scale(1) rotateY(0deg);
        }

        .tarot-modal-header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 50%, #3a3a3a 100%);
            color: #e0e0e0;
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 25px 25px 0 0;
            position: relative;
            overflow: hidden;
        }

        .tarot-modal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            animation: headerShine 4s ease-in-out infinite;
        }

        @keyframes headerShine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        .tarot-modal-title {
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(45deg, #ffffff, #cccccc, #ffffff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        @keyframes titleGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tarot-modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .tarot-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .tarot-container {
            padding: 25px;
            text-align: center;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
        }

        .tarot-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(128, 128, 128, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(64, 64, 64, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        .tarot-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 0%, transparent 8px),
                radial-gradient(circle at 75% 75%, rgba(128, 128, 128, 0.1) 0%, transparent 8px),
                radial-gradient(circle at 50% 10%, rgba(64, 64, 64, 0.1) 0%, transparent 6px),
                radial-gradient(circle at 10% 60%, rgba(255, 255, 255, 0.1) 0%, transparent 6px),
                radial-gradient(circle at 90% 40%, rgba(128, 128, 128, 0.1) 0%, transparent 6px);
            animation: particleFloat 8s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes particleFloat {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg);
                opacity: 0.3;
            }
            25% { 
                transform: translateY(-10px) rotate(90deg);
                opacity: 0.7;
            }
            50% { 
                transform: translateY(-5px) rotate(180deg);
                opacity: 0.5;
            }
            75% { 
                transform: translateY(-15px) rotate(270deg);
                opacity: 0.8;
            }
        }

        @keyframes darkGradientShift {
            0%, 100% { 
                background-position: 0% 50%;
            }
            25% { 
                background-position: 100% 50%;
            }
            50% { 
                background-position: 100% 100%;
            }
            75% { 
                background-position: 0% 100%;
            }
        }

        .tarot-card-display {
            margin-bottom: 12px;
            flex-shrink: 0;
            position: relative;
        }

        .tarot-card-back {
            width: 180px;
            height: 260px;
            margin: 0 auto;
            background: linear-gradient(145deg, #1a1a1a 0%, #2a2a2a 25%, #3a3a3a 50%, #4a4a4a 75%, #2a2a2a 100%);
            border-radius: 16px;
            border: 2px solid #666666;
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.6),
                0 0 25px rgba(128, 128, 128, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .tarot-card-back::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            animation: cardGlow 3s ease-in-out infinite;
        }

        .tarot-card-back::after {
            content: '✧';
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite;
        }

        .tarot-card-back .symbol-top-right {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 0.5s;
        }

        .tarot-card-back .symbol-bottom-left {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 16px;
            color: rgba(128, 128, 128, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 1s;
        }

        .tarot-card-back .symbol-bottom-right {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 16px;
            color: rgba(192, 192, 192, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 1.5s;
        }

        @keyframes symbolTwinkle {
            0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(180deg); }
        }

        @keyframes cardGlow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .tarot-card-back:hover {
            transform: translateY(-8px) rotateY(5deg);
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.7),
                0 0 40px rgba(128, 128, 128, 0.6);
        }

        .card-back-pattern {
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            bottom: 25px;
            background: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 15px,
                    rgba(255, 255, 255, 0.08) 15px,
                    rgba(255, 255, 255, 0.08) 30px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 15px,
                    rgba(255, 255, 255, 0.05) 15px,
                    rgba(255, 255, 255, 0.05) 30px
                );
            border-radius: 15px;
            opacity: 0.8;
        }

        .card-back-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            background: linear-gradient(45deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: textPulse 2s ease-in-out infinite;
        }

        @keyframes textPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .tarot-card-front {
            width: 180px;
            height: 260px;
            margin: 0 auto;
            background: linear-gradient(145deg, #f5f5f5 0%, #e8e8e8 25%, #d8d8d8 50%, #c8c8c8 75%, #f5f5f5 100%);
            border-radius: 16px;
            border: 2px solid #999999;
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.5),
                0 0 25px rgba(128, 128, 128, 0.3);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform: rotateY(180deg);
            transform-style: preserve-3d;
        }

        .tarot-card-front.flipped {
            transform: rotateY(0deg);
        }

        .card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 17px;
        }

        .tarot-info {
            margin: 15px 0 8px 0;
            padding: 15px;
            background: linear-gradient(135deg, rgba(26, 26, 26, 0.8) 0%, rgba(42, 42, 42, 0.8) 100%);
            border-radius: 12px;
            border: 1px solid rgba(128, 128, 128, 0.3);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .tarot-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(128, 128, 128, 0.05) 50%, 
                transparent 100%);
            animation: infoShimmer 4s ease-in-out infinite;
        }

        @keyframes infoShimmer {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .card-name {
            margin: 0 0 12px 0;
            font-size: 19px;
            font-weight: bold;
            background: linear-gradient(45deg, #ffffff, #cccccc, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .card-meaning {
            margin: 0 0 15px 0;
            font-size: 15px;
            line-height: 1.6;
            color: #e0e0e0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .card-orientation {
            margin-top: 10px;
        }

        .orientation-text {
            padding: 8px 18px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(192, 192, 192, 0.1) 100%);
            border-radius: 25px;
            font-size: 13px;
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(5px);
            animation: orientationPulse 3s ease-in-out infinite;
        }

        @keyframes orientationPulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .tarot-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 8px;
            padding-top: 12px;
            flex-shrink: 0;
        }

        .tarot-btn {
            padding: 12px 22px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 110px;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .tarot-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
            transition: left 0.5s ease;
        }

        .tarot-btn:hover::before {
            left: 100%;
        }

        .tarot-btn.primary {
            background: linear-gradient(135deg, #333333 0%, #666666 50%, #333333 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(128, 128, 128, 0.4);
            border: 1px solid rgba(128, 128, 128, 0.3);
        }

        .tarot-btn.primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(128, 128, 128, 0.6);
        }

        .tarot-btn.secondary {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .tarot-btn.secondary:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.2);
        }

        /* 塔罗牌响应式设计 */
        @media (max-width: 768px) {
            .tarot-modal-content {
                margin: 15px;
                max-width: calc(100% - 30px);
                max-height: calc(100% - 30px);
                width: calc(100% - 30px);
                height: auto;
                min-height: 450px;
                transform: scale(0.8) rotateY(-10deg);
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(0.9) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 140px;
                height: 210px;
            }
            
            .tarot-container {
                padding: 15px;
            }
            
            .tarot-actions {
                gap: 10px;
                margin-top: 15px;
            }
            
            .tarot-btn {
                padding: 10px 20px;
                min-width: 100px;
                font-size: 13px;
            }
        }

        @media (max-width: 480px) {
            .tarot-modal-overlay {
                padding: 10px;
            }
            
            .tarot-modal-content {
                transform: scale(0.9) rotateY(0deg);
                max-width: 95%;
                max-height: 90vh;
                min-height: auto;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 100px;
                height: 150px;
            }
            
            .tarot-actions {
                flex-direction: column;
                gap: 15px;
            }
            
            .tarot-btn {
                min-width: 100%;
                padding: 12px 20px;
                font-size: 14px;
            }
            
            .tarot-info {
                margin: 15px 0;
                padding: 15px;
            }
            
            .card-name {
                font-size: 18px;
            }
            
            .card-meaning {
                font-size: 13px;
            }
        }
        
        @media (max-width: 360px) {
            .tarot-modal-overlay {
                padding: 5px;
            }
            
            .tarot-modal-content {
                transform: scale(0.95) rotateY(0deg);
                max-width: 98%;
                max-height: 95vh;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 80px;
                height: 120px;
            }
            
            .tarot-info {
                margin: 10px 0;
                padding: 10px;
            }
            
            .card-name {
                font-size: 16px;
            }
            
            .card-meaning {
                font-size: 12px;
            }
            
            .tarot-btn {
                padding: 10px 16px;
                font-size: 13px;
            }
        }
        
        /* 移动端特殊处理 */
        @media (max-width: 768px) {
            .tarot-modal-overlay {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
                overflow: hidden !important;
            }
            
            .tarot-modal-content {
                position: relative !important;
                transform: scale(0.9) rotateY(0deg) !important;
                max-width: 95vw !important;
                max-height: 90vh !important;
                margin: 0 auto !important;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg) !important;
            }
        }
        
        /* 强制覆盖所有可能的定位问题 */
        .tarot-modal-overlay.visible {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 99999 !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* 修复垂直居中偏下的问题 */
        .tarot-modal-content {
            position: relative !important;
            transform: none !important;
            margin: 0 auto !important;
            max-height: 90vh !important;
            overflow-y: auto !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: center !important;
        }
        
        /* 移动端垂直居中优化 */
        @media (max-width: 768px) {
            .tarot-modal-content {
                max-height: 85vh !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-modal-content {
                max-height: 80vh !important;
            }
        }
        
        /* 更精确的垂直居中 */
        .tarot-modal-overlay.visible {
            align-items: flex-start !important;
            padding-top: 5vh !important;
            padding-bottom: 5vh !important;
            overflow-y: auto !important;
        }
        
        /* 移动端更精确的垂直居中 */
        @media (max-width: 768px) {
            .tarot-modal-overlay.visible {
                padding-top: 3vh !important;
                padding-bottom: 3vh !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-modal-overlay.visible {
                padding-top: 2vh !important;
                padding-bottom: 2vh !important;
            }
        }
        
        /* 确保在移动端也能正确显示 */
        @media (orientation: portrait) {
            .tarot-modal-overlay {
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
            }
        }
        
        @media (orientation: landscape) {
            .tarot-modal-overlay {
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
            }
        }
        
        /* 确保按钮区域完全可见 */
        .tarot-buttons {
            margin-top: 15px !important;
            padding: 10px 0 !important;
            position: relative !important;
            z-index: 10 !important;
        }
        
        .tarot-btn {
            margin: 5px !important;
            position: relative !important;
            z-index: 10 !important;
        }
        

        
        /* 移动端按钮优化 */
        @media (max-width: 768px) {
            .tarot-buttons {
                margin-top: 20px !important;
                padding: 15px 0 !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-buttons {
                margin-top: 25px !important;
                padding: 20px 0 !important;
            }
        }
        .chat-system-message {
            background-color: rgba(128, 128, 128, 0.2);
            color: #d1d5db;
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            margin: 0.5rem auto;
            width: fit-content;
        }
        .light-mode .chat-system-message {
            color: #4b5563;
        }
        .chat-input-bar {
            background-color: transparent;
            border-top-width: 1px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .dark-mode .chat-input-bar { border-color: rgba(255, 255, 255, 0.1); }
        .light-mode .chat-input-bar { border-color: rgba(0, 0, 0, 0.1); }
        #chat-input {
            border: 1px solid transparent;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s, box-shadow 0.3s, height 0.2s ease-in-out;
            resize: none;
            overflow-y: auto;
            line-height: 1.5;
        }
        .dark-mode #chat-input { background-color: rgba(31, 41, 55, 0.8); color: #ffffff; }
        .light-mode #chat-input { background-color: rgba(243, 244, 246, 0.8); color: #1f2937; }
        .status-bar.transparent-override {
            background-color: transparent !important;
        }
        #wechat-chat-screen.has-custom-bg {
            background-color: transparent !important;
        }
        #wechat-chat-screen.has-custom-bg .app-header,
        #wechat-chat-screen.has-custom-bg .chat-input-bar,
        #wechat-chat-screen.has-custom-bg #chat-quick-actions-bar {
            background: transparent !important;
            border-color: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        #wechat-chat-screen.has-custom-bg #chat-input {
            background-color: rgba(0,0,0,0.2);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }
        .light-mode #wechat-chat-screen.has-custom-bg #chat-input {
             background-color: rgba(255,255,255,0.2);
             box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .chat-time-divider {
            display: none;
        }
        
        .bubble-context-menu {
            position: absolute;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 2rem;
            padding: 2px 4px;
            display: none;
            flex-direction: row;
            align-items: center;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateY(5px) scale(0.95);
            opacity: 0;
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
            visibility: hidden;
        }
        .bubble-context-menu.visible {
            display: flex;
            opacity: 1;
            transform: translateY(0) scale(1);
            visibility: visible;
        }
        .bubble-menu-button {
            background: none;
            border: none;
            color: #f0f0f0;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 11px;
            border-radius: 2rem;
            transition: background-color 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }
        .bubble-menu-button:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .bubble-menu-button:disabled {
            color: #6b7280;
            cursor: not-allowed;
        }
        .bubble-menu-button i {
            font-size: 12px;
            margin-right: 3px;
        }
        
        .chat-message-wrapper.selected .chat-message {
            background-color: rgba(59, 130, 246, 0.4) !important;
            border-color: rgba(96, 165, 250, 0.8) !important;
        }
        .light-mode .chat-message-wrapper.selected .chat-message {
             background-color: rgba(96, 165, 250, 0.5) !important;
        }


        .color-picker-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 1.75rem;
            height: 1.75rem;
            padding: 0;
            border: 2px solid rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            cursor: pointer;
            background-color: transparent;
        }
        .color-picker-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-picker-input::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
        .color-picker-input::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .app-header { 
            display: flex; 
            align-items: center; /* 垂直居中所有子元素 */
            justify-content: space-between; 
            padding: 0.5rem 1rem;
            height: 4.5rem; /* 增加标题栏高度以容纳多行文字 */
            flex-shrink: 0;
            position: relative; /* 确保z-index生效 */
            z-index: 20;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2); /* 中性边框颜色 */
            background: transparent;
        }

        .app-header .text-center {
            /* 这个容器包裹着中英文标题 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-header-title { 
            font-weight: 700; 
            font-size: 1.125em; /* 18px */
            color: inherit; /* 继承父元素颜色 */
            margin: 0; /* 移除任何可能的外边距 */
        }

        .app-header .text-xs {
            font-size: 0.75rem; /* 12px */
            color: inherit; /* 继承父元素颜色 */
            letter-spacing: 0.1em; /* 增加字母间距 */
            margin-top: 0.25rem; /* 与主标题的间距 */
        }
        .app-header-title.clickable { cursor: pointer; }
        .app-header-btn.text-pink-500 {
            color: #d1d5db;
        }
        .app-header-btn { font-size: 1.25em; }

        .list-item {
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 1rem;
            position: relative;
        }
        .list-item:hover {
            background-color: rgba(128, 128, 128, 0.1);
        }
        .list-item-delete-btn {
            position: absolute;
            top: -0.5rem;
            left: -0.5rem;
            width: 1.5rem;
            height: 1.5rem;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 10;
            animation: popIn 0.2s ease-out;
        }
        .deletable:hover .list-item-delete-btn {
            display: flex;
        }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }


        .form-input, .form-textarea, .form-select { width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid transparent; }
        .dark-mode .form-input, .dark-mode .form-textarea, .dark-mode .form-select { background-color: #2c2c2c; color: #ffffff; }
        .light-mode .form-input, .light-mode .form-textarea, .light-mode .form-select { background-color: #ffffff; color: #1f2937; border: 1px solid #e5e7eb; }
        .wb-checkbox-label { display: flex; align-items: center; padding: 0.5rem; border-radius: 0.5rem; cursor: pointer; }
        .wb-checkbox-label:hover { background-color: rgba(255, 255, 255, 0.1); }
        .wb-checkbox-label input { margin-right: 0.75rem; }

        .wechat-tab-bar { display: flex; border-top-width: 1px; }
        .wechat-tab-item { flex: 1; text-align: center; padding: 0.5rem 0; cursor: pointer; color: #9ca3af; }
        .wechat-tab-item.active {
            font-weight: 600;
        }
        .dark-mode .wechat-tab-item.active {
            color: #ffffff;
        }
        .light-mode .wechat-tab-item.active {
            color: #1f2937;
        }
        .wechat-tab-item i { font-size: 1.25em; }
        .wechat-tab-item span { display: block; font-size: 0.75em; }

        .wechat-list-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }
        .wechat-list-item .last-message {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .user-avatar-in-chat {
            cursor: pointer;
        }

        .app-screen-view { 
            position: relative; /* 新增：为子元素的绝对定位提供基准 */
            height: 100%;
            padding-top: 3rem;
        }


        .font-size-btn.active {
            font-weight: 600;
        }
        .dark-mode .font-size-btn.active { background-color: #52525b; }
        .light-mode .font-size-btn.active { background-color: #d4d4d8; }
        .dark-mode #font-size-selector { background-color: #3f3f46; }
        .light-mode #font-size-selector { background-color: #e4e4e7; }

        #confirm-delete-modal .modal-content {
            padding: 1.5rem;
        }
        
        .chat-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: -1;
        }
        
        #chat-quick-actions-bar {
            background: transparent;
            padding: 0.25rem 1rem;
            display: flex;
            justify-content: flex-start;
            gap: 1rem;
        }
        .quick-action-btn {
            font-size: 1.25rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .quick-action-btn:hover {
            opacity: 1;
        }
        
        #chat-footer {
            position: relative;
        }

        #chat-input-bar {
            padding: 0.5rem 0.25rem;
        }
        #chat-input-bar .chat-input-btn {
            font-size: 1.25rem;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        #emoji-btn {
            margin-left: -0.25rem;
        }

        #more-features-panel {
            background: #2c2c2e;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
        }
        .light-mode #more-features-panel {
            background: #f8f8f8;
            border-top-color: rgba(0, 0, 0, 0.1);
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        .feature-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .feature-icon-wrapper {
            width: 56px;
            height: 56px;
            border-radius: 1rem;
            background-color: #3a3a3c;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.5rem;
            transition: background-color 0.2s;
        }
        .light-mode .feature-icon-wrapper {
            background-color: #ffffff;
        }
        .feature-item:hover .feature-icon-wrapper {
            background-color: #555;
        }
        .light-mode .feature-item:hover .feature-icon-wrapper {
            background-color: #e5e5e5;
        }
        .feature-icon-wrapper i {
            font-size: 1.5rem;
        }
        .feature-item span {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .call-screen {
            position: absolute;
            inset: 0;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            background-color: #111;
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .call-screen.visible {
            opacity: 1;
            visibility: visible;
        }
        .call-background {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.6);
            transform: scale(1.1);
        }
        .call-content {
            position: relative;
            z-index: 1;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 3.5rem 1rem 1rem;
        }
        #voice-call-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.5);
            object-fit: cover;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
            margin-top: 2rem;
        }
        #user-video-preview {
            position: absolute;
            top: 3.5rem;
            right: 1rem;
            width: 90px;
            height: 120px;
            background-color: #333;
            border-radius: 1rem;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #user-video-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .call-status-box {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.25); 
            backdrop-filter: blur(12px);     
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); 
            border-radius: 1rem;
            padding: 1rem;
            max-height: 25vh;
            overflow-y: auto;
            font-style: italic;
            color: #e5e7eb;
            flex-shrink: 0;
        }
        .call-input-area {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }
        .call-input-area textarea {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            padding: 0.5rem 1rem;
            color: white;
            resize: none;
        }
        .call-input-area button {
            background-color: #374151;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        .call-input-area button:hover {
            background-color: #4b5563;
        }
        .call-controls {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem 0;
        }
        .call-control-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
        }
        .hangup-btn { background-color: #ef4444; }

        #incoming-call-alert {
            position: absolute;
            top: 3.5rem;
            left: 0.5rem;
            right: 0.5rem;
            z-index: 9500;
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            transform: translateY(-200%);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }
        #incoming-call-alert.visible {
            transform: translateY(0);
        }
        #incoming-call-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 1rem;
        }
        #incoming-call-info {
            flex-grow: 1;
        }
        .call-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 1.25rem;
            margin-left: 0.75rem;
        }
        #answer-call-btn { background-color: #22c55e; }
        #decline-call-btn { background-color: #ef4444; }

        /* 红包/转账高级UI样式 */
        .payment-modal-overlay {
            position: absolute;
            inset: 0;
            z-index: 12000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .payment-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .payment-modal-content {
            background-color: #1a1a1a;
            color: #C0C0C0;
            width: 90%;
            max-width: 280px; /* 缩小了宽度 */
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
        }
        .payment-modal-overlay.visible .payment-modal-content {
             transform: scale(1);
             opacity: 1;
        }
        .payment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
        }
        .payment-header .close-btn { font-size: 1.5rem; cursor: pointer; }
        .payment-header .title { font-size: 1.125rem; font-weight: 600; }
        .payment-content {
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .amount-input-wrapper {
            display: flex;
            align-items: center;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            width: 100%;
        }
        .currency-symbol {
            font-size: 2.5rem;
            font-weight: 300;
            margin-right: 1rem;
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .amount-input {
            background: transparent;
            border: none;
            outline: none;
            font-size: 3rem;
            font-weight: 700;
            width: 100%;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        /* 隐藏数字输入框的箭头 */
        .amount-input::-webkit-outer-spin-button,
        .amount-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .amount-input[type=number] {
            -webkit-appearance: textfield;
            -moz-appearance: textfield;
            appearance: textfield;
        }
        .message-input {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(220, 20, 60, 0.3);
            border-radius: 1rem;
            width: 100%;
            padding: 1rem;
            margin-top: 1.5rem;
            color: #ffffff;
            outline: none;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .message-input:focus {
            border-color: #DC143C;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.2);
            transform: translateY(-2px);
        }
        .message-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        .send-payment-btn {
            margin-top: 1.5rem;
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #DC143C, #B22222);
            color: #ffffff;
            font-size: 1.125rem;
            font-weight: 700;
            border-radius: 1rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(220, 20, 60, 0.3);
            position: relative;
            overflow: hidden;
        }
        .send-payment-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        .send-payment-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(220, 20, 60, 0.4);
        }
        .send-payment-btn:hover::before {
            left: 100%;
        }
        .send-payment-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        /* 红包/转账气泡样式 - 已修改 */
        .chat-message.red-packet-message, .chat-message.transfer-message {
            padding: 0;
            width: 200px;
            border-radius: 0.75rem;
            overflow: hidden;
            border: none;
            position: relative;
        }
        .chat-message.red-packet-message {
            background-image: radial-gradient(circle at 20% 20%, rgba(220, 20, 60, 0.25), transparent), linear-gradient(#1a1a1a, #1a1a1a);
        }
        .chat-message.transfer-message {
            background-image: radial-gradient(circle at 20% 20%, rgba(229, 231, 235, 0.15), transparent), linear-gradient(#374151, #374151);
        }
        .payment-bubble-header {
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
        }
        .payment-bubble-header i {
            font-size: 1.5rem;
            margin-right: 0.5rem;
        }
        .red-packet-message .payment-bubble-header i { color: #DC143C; }
        .transfer-message .payment-bubble-header i { color: #E5E7EB; }

        .payment-bubble-body {
            padding: 0.125rem 0.75rem; /* 减小白色区域高度 */
            background-color: white;
            color: #6b7280;
            font-size: 0.65rem;
        }
        .payment-bubble-amount {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 0.125rem;
        }
        .payment-bubble-message {
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .red-packet-message .payment-bubble-message {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        .transfer-message .payment-bubble-amount,
        .transfer-message .payment-bubble-message {
            background: linear-gradient(90deg, #E5E7EB, #B0B0B0, #E5E7EB);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* 表情面板 (美化版) */
        #sticker-panel {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            width: 375px;
            max-width: calc(100vw - 2rem);
            background: linear-gradient(135deg, rgba(44, 44, 46, 0.95), rgba(60, 60, 65, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px 20px 0 0;
            z-index: 50;
            transition: transform 0.3s ease-out;
            max-height: 50%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }
        
        /* 确保表情面板的父容器有相对定位 */
        #wechat-chat-screen {
            position: relative;
        }
        
        .light-mode #sticker-panel {
            background: linear-gradient(135deg, rgba(248, 248, 248, 0.95), rgba(255, 255, 255, 0.95));
            border-top-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.1);
        }
        
        #sticker-panel.visible {
            transform: translateX(-50%) translateY(0);
        }
        
        /* 表情面板标题栏 */
        #sticker-panel::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .light-mode #sticker-panel::before {
            background: rgba(0, 0, 0, 0.2);
        }
        
        #sticker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            padding: 20px 16px 16px 16px;
            overflow-y: auto;
            flex-grow: 1;
            margin-top: 8px;
        }
        
        /* 自定义滚动条 */
        #sticker-grid::-webkit-scrollbar {
            width: 6px;
        }
        
        #sticker-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        #sticker-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .light-mode #sticker-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode #sticker-grid::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .sticker-item, .add-sticker-btn {
            width: 60px;
            height: 60px;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 8px;
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
            overflow: hidden;
        }
        
        .sticker-item:hover, .add-sticker-btn:hover {
            transform: translateY(-4px) scale(1.05);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.15));
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .light-mode .sticker-item, .light-mode .add-sticker-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(240, 240, 240, 0.6));
            border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .sticker-item:hover, .light-mode .add-sticker-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(250, 250, 250, 0.8));
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        /* 淺色模式下的刪除按鈕樣式 */
        .light-mode .sticker-delete-btn {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .sticker-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        .light-mode .sticker-delete-btn.active {
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
        }
        
        /* 淺色模式下的刪除確認彈窗樣式 */
        .light-mode .delete-confirm-modal {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
        }
        
        .light-mode .delete-confirm-modal h3 {
            color: #1f2937;
        }
        
        .light-mode .delete-confirm-modal p {
            color: #4b5563;
        }
        
        .light-mode .delete-confirm-btn.cancel {
            background: rgba(0, 0, 0, 0.05);
            color: #374151;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .delete-confirm-btn.cancel:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        /* 浅色模式红包样式 */
        .light-mode .chat-message.red-packet-message {
            background-image: radial-gradient(circle at 20% 20%, rgba(220, 20, 60, 0.15), transparent), linear-gradient(#ffffff, #f8f9fa);
        }
        
        .light-mode .red-packet-message .payment-bubble-header i {
            color: #DC143C;
        }
        
        .light-mode .red-packet-message .payment-bubble-message {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* 浅色模式红包/转账界面样式 */
        .light-mode .payment-modal-content {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            color: #374151;
            border: 1px solid rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .currency-symbol {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .light-mode .amount-input {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .light-mode .message-input {
            background: rgba(220, 20, 60, 0.05);
            border: 2px solid rgba(220, 20, 60, 0.2);
            color: #374151;
        }
        
        .light-mode .message-input:focus {
            border-color: #DC143C;
            background: rgba(220, 20, 60, 0.08);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.15);
        }
        
        .light-mode .message-input::placeholder {
            color: rgba(55, 65, 81, 0.6);
        }
        
        .light-mode .send-payment-btn {
            background: linear-gradient(135deg, #DC143C, #B22222);
            box-shadow: 0 4px 15px rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .send-payment-btn:hover {
            box-shadow: 0 8px 25px rgba(220, 20, 60, 0.3);
        }
        
        .sticker-item img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            transition: transform 0.3s ease;
        }
        
        .sticker-item:hover img {
            transform: scale(1.1);
        }
        
        .add-sticker-btn {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(147, 197, 253, 0.1));
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .add-sticker-btn:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(147, 197, 253, 0.2));
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .add-sticker-btn i {
            font-size: 2rem;
            color: #3b82f6;
            transition: all 0.3s ease;
        }
        
        .add-sticker-btn:hover i {
            transform: rotate(90deg) scale(1.1);
            color: #1d4ed8;
        }
        
        /* 表情包面板动画效果 */
        @keyframes stickerFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .sticker-item {
            animation: stickerFadeIn 0.4s ease-out;
        }
        
        .sticker-item:nth-child(1) { animation-delay: 0.1s; }
        .sticker-item:nth-child(2) { animation-delay: 0.15s; }
        .sticker-item:nth-child(3) { animation-delay: 0.2s; }
        .sticker-item:nth-child(4) { animation-delay: 0.25s; }
        .sticker-item:nth-child(5) { animation-delay: 0.3s; }
        .sticker-item:nth-child(6) { animation-delay: 0.35s; }
        
        /* 表情包面板显示/隐藏动画 */
        #sticker-panel.visible {
            transform: translateX(-50%) translateY(0);
        }
        
        /* 刪除按鈕樣式 */
        .sticker-delete-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            background: rgba(239, 68, 68, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .sticker-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }
        
        .sticker-delete-btn i {
            color: white;
            font-size: 16px;
        }
        
        .sticker-delete-btn.active {
            background: rgba(239, 68, 68, 1);
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
        }
        
        /* 刪除模式下的表情包樣式 */
        .sticker-item.delete-mode {
            position: relative;
        }
        
        .sticker-item.delete-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(239, 68, 68, 0.2);
            border-radius: 16px;
            z-index: 1;
        }
        
        .sticker-item.delete-mode.selected::before {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(239, 68, 68, 0.8);
        }
        
        .sticker-item.delete-mode .sticker-checkbox {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid rgba(239, 68, 68, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .sticker-item.delete-mode .sticker-checkbox.checked {
            background: rgba(239, 68, 68, 0.9);
            border-color: rgba(239, 68, 68, 1);
        }
        
        .sticker-item.delete-mode .sticker-checkbox.checked::after {
            content: '✓';
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* 刪除確認彈窗樣式 */
        .delete-confirm-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 24px;
            z-index: 10000;
            display: none;
            flex-direction: column;
            align-items: center;
            min-width: 280px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .delete-confirm-modal.visible {
            display: flex;
        }
        
        .delete-confirm-modal h3 {
            color: white;
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .delete-confirm-modal p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0 0 24px 0;
            text-align: center;
            line-height: 1.5;
        }
        
        .delete-confirm-buttons {
            display: flex;
            gap: 12px;
            width: 100%;
        }
        
        .delete-confirm-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .delete-confirm-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .delete-confirm-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .delete-confirm-btn.confirm {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .delete-confirm-btn.confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }
        
        /* 响应式设计 */
        @media (max-width: 480px) {
            #sticker-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 10px;
                padding: 16px 12px 12px 12px;
            }
            
            .sticker-item, .add-sticker-btn {
                width: 70px;
                height: 70px;
            }
        }

        /* V7.0 新增样式 */
        .wechat-content-view {
            padding: 0.5rem;
            height: 100%;
            overflow-y: auto;
        }
        /* 动态 (Moments) */
        .moment-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            animation: fadeIn 0.5s ease-out;
        }
        .light-mode .moment-card {
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .moment-image {
            width: 100%;
            height: 180px;
            border-radius: 0.75rem;
            background-color: rgba(255,255,255,0.1);
            background-size: cover;
            background-position: center;
            margin-top: 0.75rem;
        }
        .moment-actions {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 0.75rem;
            padding-top: 0.5rem;
        }
        .light-mode .moment-actions { border-color: rgba(0,0,0,0.08); }
        .moment-action-btn {
            transition: color 0.2s, transform 0.2s;
        }
        .moment-action-btn:active {
            transform: scale(1.2);
        }
        .moment-action-btn.liked {
            color: #ef4444;
        }

        /* 日记 (Diary) */
        #wechat-diary-container {
            background-image: url('https://www.transparenttextures.com/patterns/45-degree-fabric-dark.png');
            background-color: #fffcfc;
            color: #4a4a4a;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }
        .dark-mode #wechat-diary-container {
             background-image: url('https://www.transparenttextures.com/patterns/45-degree-fabric-dark.png');
             background-color: #292929;
             color: #d1d5db;
        }
        .diary-entry {
            padding: 1.5rem;
            border-bottom: 1px dashed #c7c1b6;
            animation: fadeIn 0.5s ease-out;
        }
        .dark-mode .diary-entry {
            border-bottom-color: #4a4a4a;
        }
        .diary-date {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        .diary-content {
            line-height: 1.8;
        }

        /* 计划 (Plan) */
        .plan-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.75rem;
            margin-bottom: 0.5rem;
            animation: fadeIn 0.3s ease-out;
            cursor: pointer;
        }
        .light-mode .plan-item {
            background-color: #ffffff;
        }
        .plan-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.25rem;
        }
        .plan-status-agreed { background-color: #3b82f6; color: white; }
        .plan-status-inprogress { background-color: #f59e0b; color: white; }
        .plan-status-completed { background-color: #10b981; color: white; }
        .plan-details {
            display: none;
            margin-top: 0.5rem;
            padding: 0.75rem;
            background-color: rgba(0,0,0,0.1);
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }
        .light-mode .plan-details {
            background-color: rgba(0,0,0,0.05);
        }
        
        /* ============================================= */
        /* V7.1 UI 升级样式 (动态 & 日记) */
        /* ============================================= */

        /* --- 新增：动态 (Moments) 整体 UI --- */
        #moments-header {
            transition: transform 0.3s ease;
        }
        #moments-header:hover {
            transform: scale(1.02);
        }

        /* 朋友圈背景图片样式 */
        #moments-cover {
            z-index: 25; /* 提高z-index，确保在渐变遮罩之上 */
            position: relative;
            min-height: 192px; /* 确保有足够的高度 */
            width: 100%; /* 确保宽度填满 */
        }

        /* 渐变遮罩样式 */
        #moments-header .bg-gradient-to-t {
            z-index: 20;
            pointer-events: none; /* 让渐变遮罩不阻挡点击事件 */
        }

        #moments-user-name {
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            color: white;
            font-weight: bold;
        }

        #moments-user-avatar {
            background-color: #4a4a4a;
            transition: transform 0.3s ease;
            z-index: 30; /* 确保头像在背景之上 */
        }
        #moments-user-avatar:hover {
            transform: scale(1.05);
        }
        
        /* 头像信息容器样式 */
        #moments-user-info {
            position: absolute;
            z-index: 30; /* 确保头像信息在背景之上 */
        }

        /* 朋友圈背景图片样式 - 确保不被日夜间模式覆盖 */
        #moments-cover {
            background-image: var(--moments-cover-image, url('https://placehold.co/375x192/333/fff?text=Cover'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 确保日夜间模式切换后背景图片仍然显示 */
        .dark-mode #moments-cover,
        .light-mode #moments-cover {
            background-image: var(--moments-cover-image, url('https://placehold.co/375x192/333/fff?text=Cover'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 强制设置默认背景图片，确保始终有图片显示 */
        #moments-cover:not([style*="background-image"]) {
            background-image: url('https://placehold.co/375x192/333/fff?text=Cover');
        }

        /* 朋友圈头像样式 - 确保不被日夜间模式覆盖 */
        #moments-user-avatar {
            background-image: var(--moments-avatar-image, url('https://placehold.co/128x128/777/FFF?text=Me'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 确保日夜间模式切换后头像仍然显示 */
        .dark-mode #moments-user-avatar,
        .light-mode #moments-user-avatar {
            background-image: var(--moments-avatar-image, url('https://placehold.co/128x128/777/FFF?text=Me'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 动态卡片(新) */
        .moment-card {
            border: none;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            padding: 0.75rem; /* 内边距统一 */
        }


        
        /* 朋友圈头像点击样式 */
        .moment-card .w-10.h-10 {
            transition: transform 0.2s;
        }
        .moment-card .w-10.h-10:hover {
            transform: scale(1.1);
        }
        .light-mode .moment-card {
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
        }
        .moment-card .flex.items-start .font-bold {
            font-size: 1.05em; /* 名字稍大一些 */
        }
        .moment-card .whitespace-pre-wrap {
            font-size: 1em;
            line-height: 1.6;
        }

        /* 点赞和评论样式 */
        .moment-action-btn {
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .moment-action-btn:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .moment-action-btn.text-blue-500 {
            color: #3b82f6;
        }
        
        .moment-action-btn.text-blue-500:hover {
            background-color: rgba(59, 130, 246, 0.15);
        }
        
        /* 评论样式 */
        .moment-card .bg-gray-50 {
            background-color: rgba(249, 250, 251, 0.8);
            border: 1px solid rgba(229, 231, 235, 0.5);
        }
        
        .light-mode .moment-card .bg-gray-50 {
            background-color: rgba(249, 250, 251, 0.9);
            border: 1px solid rgba(229, 231, 235, 0.7);
        }

        /* --- 新增：日记 (Diary) "书架" UI - 优化质感 --- */
        #diary-bookshelf .diary-book-item {
            aspect-ratio: 3 / 4;
            border-radius: 0.75rem 1rem 1rem 0.75rem;
            padding: 1.2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: white;
            cursor: pointer;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #diary-bookshelf .diary-book-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(135deg, 
                    rgba(0, 0, 0, 0.1) 0%, 
                    rgba(0, 0, 0, 0.3) 50%, 
                    rgba(0, 0, 0, 0.5) 100%);
            pointer-events: none;
            z-index: 1;
        }

        #diary-bookshelf .diary-book-item:hover {
            transform: translateY(-12px) rotate(3deg) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 8px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .diary-book-item-title {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 1.3rem;
            font-weight: 600;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 2;
            letter-spacing: 0.5px;
        }

        .diary-book-item-author {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 0.85rem;
            align-self: flex-end;
            font-style: italic;
            text-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 2;
            opacity: 0.9;
        }

        /* --- 新增：日记本"翻页书" UI --- */
        .book-container {
            position: relative;
            width: 90vw;
            height: 70vh;
            perspective: 2500px;
        }
        .book {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(10deg) rotateY(0deg);
            transition: transform 1s ease;
        }
        .book:hover {
            transform: rotateX(0deg) rotateY(0deg);
        }

        /* 旧的展开书本样式已删除 */

        /* 旧的展开书本样式已删除 */

        /* 旧的展开书本样式已删除 */
        
        /* 日记本封面编辑按钮样式 - 优化质感 */
        .diary-cover-edit-btn {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            width: 2.2rem;
            height: 2.2rem;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.7) 0%, 
                rgba(0, 0, 0, 0.8) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
            backdrop-filter: blur(8px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .diary-book-item:hover .diary-cover-edit-btn {
            opacity: 1;
            transform: scale(1.05);
        }

        .diary-cover-edit-btn:hover {
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.8) 0%, 
                rgba(0, 0, 0, 0.9) 100%);
            transform: scale(1.1);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .diary-cover-edit-btn i {
            font-size: 1.1rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 单页日记本样式 - 优化为纸张质感 */
        .diary-single-page-container {
            width: 90vw;
            max-width: 400px;
            height: 80vh;
            max-height: 600px;
        }

        .diary-single-page {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            border-radius: 16px;
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.25),
                0 4px 12px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* 封面样式 - 黑白灰质感设计 */
        .diary-cover {
            background: linear-gradient(145deg, 
                #2c2c2c 0%, 
                #404040 25%, 
                #505050 50%, 
                #404040 75%, 
                #2c2c2c 100%);
            color: #f0f0f0;
            padding: 2.5rem 2rem;
            text-align: center;
            border-radius: 16px 16px 0 0;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .diary-cover::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        .diary-cover h2 {
            font-size: 1.6rem;
            margin-bottom: 0.8rem;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.5px;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }

        .diary-cover p {
            font-size: 1rem;
            opacity: 0.9;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }

        /* 内页样式 - 真实纸张质感 */
        .diary-pages {
            flex: 1;
            background: 
                linear-gradient(135deg, #fefefe 0%, #f8f8f8 100%);
            padding: 2.5rem;
            overflow-y: auto;
            position: relative;
            z-index: 1;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
        }

        /* 纸张纹理效果 */
        .diary-pages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(0, 0, 0, 0.02) 1px, transparent 0);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }

        /* 日记页面内容样式 - 优化字体和排版 */
        .diary-page-content {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Kaiti', 'STKaiti', 'Georgia', 'Times New Roman', serif;
            line-height: 1.9;
            position: relative;
            z-index: 2;
        }
        
        /* 确保所有日记相关文字都使用思源宋体 */
        .diary-book-item,
        .diary-book-item h3,
        .diary-book-item p,
        .diary-entry,
        .diary-entry h3,
        .diary-entry p {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }

        .diary-page-date {
            font-weight: 600;
            margin-bottom: 2rem;
            color: #2c2c2c;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.8rem;
            font-size: 1.1rem;
            letter-spacing: 0.5px;
            position: relative;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }

        .diary-page-date::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, #505050, transparent);
        }

        /* 日记页面头部样式 */
        .diary-page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        /* 删除按钮样式 */
        .diary-delete-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .diary-delete-btn:hover {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        /* 页码样式 */
        .diary-page-number {
            position: relative;
            text-align: right;
            margin-top: 2rem;
            font-size: 0.8rem;
            color: #999;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            /* 移除 display: inline-block，因為 float: right 會強制轉換為 block */
            float: right;
        }

        .diary-page-text {
            font-size: 1rem;
            text-align: justify;
            white-space: pre-wrap;
            color: #2a2a2a;
            line-height: 2;
            text-shadow: 0 0.5px 1px rgba(255, 255, 255, 0.8);
            padding: 1rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            cursor: text;
        }

        .diary-page-text[contenteditable="true"]:hover {
            background: rgba(0, 0, 0, 0.02);
        }

        .diary-page-text[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 0, 0, 0.03);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.08),
                0 0 0 2px rgba(80, 80, 80, 0.1);
        }

        /* 滚动条样式优化 */
        .diary-pages::-webkit-scrollbar {
            width: 6px;
        }

        .diary-pages::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
        }

        .diary-pages::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .diary-pages::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* 日记编辑区域样式 - 纸张质感 */
        .diary-page-editable {
            width: 100%;
            min-height: 200px;
            padding: 1.5rem;
            border: none;
            background: 
                linear-gradient(135deg, #fefefe 0%, #fafafa 100%);
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 1rem;
            line-height: 1.9;
            color: #2a2a2a;
            resize: vertical;
            border-radius: 8px;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.08),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
            transition: all 0.3s ease;
        }

        .diary-page-editable:focus {
            outline: none;
            background: 
                linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.12),
                inset 0 -1px 2px rgba(0, 0, 0, 0.05),
                0 0 0 3px rgba(80, 80, 80, 0.1);
        }

        .diary-page-editable::placeholder {
            color: #999;
            font-style: italic;
            opacity: 0.7;
        }

        /* 新日记页面样式 */
        .diary-page-new {
            background: 
                linear-gradient(135deg, #f8f8f8 0%, #f0f0f0 100%);
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            color: #666;
            transition: all 0.3s ease;
        }

        .diary-page-new:hover {
            border-color: #999;
            background: 
                linear-gradient(135deg, #f0f0f0 0%, #e8e8e8 100%);
        }

        .diary-page-new h3 {
            margin-bottom: 1rem;
            color: #505050;
            font-size: 1.2rem;
        }

        .diary-page-new p {
            color: #888;
            line-height: 1.6;
        }

        /* 日记本控制按钮样式 - 黑白灰质感 */
        #close-diary-book-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #close-diary-book-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #prev-page-btn,
        #next-page-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            box-shadow: 
                0 3px 10px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #prev-page-btn:hover,
        #next-page-btn:hover {
            background: rgba(0, 0, 0, 0.75);
            transform: scale(1.1);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #add-page-btn {
            background: linear-gradient(145deg, #404040, #505050);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #add-page-btn:hover {
            background: linear-gradient(145deg, #505050, #606060);
            transform: scale(1.05);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        /* 按钮图标样式 */
        #close-diary-book-btn i,
        #prev-page-btn i,
        #next-page-btn i,
        #add-page-btn i {
            color: #f0f0f0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 日记页面占位符样式 */
        .diary-page-placeholder {
            display: none;
        }

        /* 笔记本项目样式 */
        .notebook-item {
            position: relative;
        }

        .notebook-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notebook-item:hover .notebook-actions {
            opacity: 1;
        }

        .notebook-edit-btn,
        .notebook-delete-btn {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .notebook-edit-btn:hover {
            background: rgba(59, 130, 246, 0.8);
            transform: scale(1.1);
        }

        .notebook-delete-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            transform: scale(1.1);
        }

        /* 新笔记本模态框样式 */
        #new-notebook-modal .modal-content {
            max-width: 400px;
        }

        .form-input,
        .form-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.75rem;
            color: white;
            width: 100%;
            transition: all 0.3s ease;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.6);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
    /* ====== 动态监控 App (Refined UI) ====== */
    #monitoring-screen {
        color: #662034;
        position: relative;
        overflow: hidden;
    }

    /* 科技感背景 - 日间模式 */
    #monitoring-screen::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, white, #FFE6F3);
        z-index: 0;
        animation: particleFloat 8s ease-in-out infinite;
    }

    /* 科技感背景 - 夜间模式 */
    .dark-mode #monitoring-screen::before {
        background: linear-gradient(135deg, #0a0a0a, #1a1a1a, #2d2d2d, #1a1a1a);
        background-size: 400% 400%;
        animation: darkGradientShift 12s ease-in-out infinite;
    }

    /* 夜间模式文本颜色 */
    .dark-mode #monitoring-screen {
        color: #782143;
    }

    /* 日间模式身份信息文本颜色 */
    #monitoring-name {
        color: #662034 !important;
    }

    #monitoring-mood {
        color: #662034 !important;
    }

    #monitoring-status-text {
        color: #662034;
    }

    /* 科技感装饰元素 - 名片区域 */
    #monitoring-identity-block::after {
        content: '';
        position: absolute;
        top: 8px;
        right: 12px;
        width: 6px;
        height: 6px;
        background: linear-gradient(45deg, #00d4ff, #0099cc);
        border-radius: 50%;
        box-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
        animation: techPulse 3s ease-in-out infinite;
        z-index: 2;
    }

    #monitoring-identity-block::before {
        content: '';
        position: absolute;
        top: 20px;
        right: 8px;
        width: 4px;
        height: 4px;
        background: linear-gradient(45deg, #ff6b9d, #ff8fab);
        border-radius: 50%;
        box-shadow: 0 0 6px rgba(255, 107, 157, 0.6);
        animation: techPulse 3s ease-in-out infinite 0.5s;
        z-index: 2;
    }

    /* 科技感装饰元素 - 文本框右上角 */
    .monitoring-card:has(#monitoring-text-container)::after {
        content: '';
        position: absolute;
        top: 8px;
        right: 12px;
        width: 8px;
        height: 8px;
        background: linear-gradient(45deg, #00d4ff, #0099cc);
        clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.6);
        animation: techRotate 4s linear infinite;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-text-container)::before {
        content: '';
        position: absolute;
        top: 20px;
        right: 8px;
        width: 6px;
        height: 6px;
        background: linear-gradient(45deg, #ff6b9d, #ff8fab);
        clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 0% 100%);
        box-shadow: 0 0 8px rgba(255, 107, 157, 0.6);
        animation: techFloat 2.5s ease-in-out infinite 1s;
        z-index: 2;
    }

    /* 额外科技感装饰元素 - 名片区域 */
    #monitoring-identity-block .tech-dot-1 {
        position: absolute;
        top: 35px;
        right: 15px;
        width: 3px;
        height: 3px;
        background: linear-gradient(45deg, #00d4ff, #0099cc);
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(0, 212, 255, 0.5);
        animation: techFade 2s ease-in-out infinite 1.5s;
        z-index: 2;
    }

    #monitoring-identity-block .tech-dot-2 {
        position: absolute;
        top: 45px;
        right: 10px;
        width: 5px;
        height: 5px;
        background: linear-gradient(45deg, #ff6b9d, #ff8fab);
        clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 0% 100%);
        box-shadow: 0 0 6px rgba(255, 107, 157, 0.5);
        animation: techScale 2.5s ease-in-out infinite 0.8s;
        z-index: 2;
    }

    #monitoring-identity-block .tech-dot-3 {
        position: absolute;
        top: 12px;
        right: 25px;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #00d4ff, #0099cc);
        border-radius: 50%;
        box-shadow: 0 0 3px rgba(0, 212, 255, 0.4);
        animation: techFade 1.8s ease-in-out infinite 2.2s;
        z-index: 2;
    }

    /* 额外科技感装饰元素 - 文本框区域 */
    .monitoring-card:has(#monitoring-text-container) .tech-dot-1 {
        position: absolute;
        top: 35px;
        right: 15px;
        width: 4px;
        height: 4px;
        background: linear-gradient(45deg, #ff6b9d, #ff8fab);
        clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        box-shadow: 0 0 5px rgba(255, 107, 157, 0.5);
        animation: techRotate 3s linear infinite 1.2s;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-text-container) .tech-dot-2 {
        position: absolute;
        top: 45px;
        right: 8px;
        width: 3px;
        height: 3px;
        background: linear-gradient(45deg, #00d4ff, #0099cc);
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(0, 212, 255, 0.4);
        animation: techFloat 2.8s ease-in-out infinite 0.6s;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-text-container) .tech-dot-3 {
        position: absolute;
        top: 15px;
        right: 30px;
        width: 5px;
        height: 5px;
        background: linear-gradient(45deg, #ff6b9d, #ff8fab);
        clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 0% 100%);
        box-shadow: 0 0 7px rgba(255, 107, 157, 0.5);
        animation: techScale 3.2s ease-in-out infinite 1.8s;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-text-container) .tech-dot-4 {
        position: absolute;
        top: 50px;
        right: 22px;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #00d4ff, #0099cc);
        border-radius: 50%;
        box-shadow: 0 0 3px rgba(0, 212, 255, 0.4);
        animation: techFade 2.2s ease-in-out infinite 0.3s;
        z-index: 2;
    }

    /* 名片区域的科技感曲线装饰 */
    .monitoring-card:has(#monitoring-avatar) .tech-curve-1 {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 40px;
        height: 40px;
        border: 2px solid transparent;
        border-top: 2px solid rgba(0, 212, 255, 0.6);
        border-right: 2px solid rgba(0, 212, 255, 0.4);
        border-radius: 50%;
        transform: rotate(-45deg);
        animation: techCurveRotate 4s linear infinite;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-avatar) .tech-curve-2 {
        position: absolute;
        top: 25px;
        right: 25px;
        width: 25px;
        height: 25px;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(255, 107, 157, 0.5);
        border-left: 1px solid rgba(255, 107, 157, 0.3);
        border-radius: 50%;
        transform: rotate(45deg);
        animation: techCurveRotate 3s linear infinite reverse;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-avatar) .tech-curve-3 {
        position: absolute;
        top: 35px;
        right: 35px;
        width: 15px;
        height: 15px;
        border: 1px solid transparent;
        border-top: 1px solid rgba(0, 212, 255, 0.4);
        border-radius: 50%;
        transform: rotate(0deg);
        animation: techCurvePulse 2.5s ease-in-out infinite;
        z-index: 2;
    }

    /* 文本框下方的科技感线性装饰 */
    .tech-lines-container {
        height: 20px;
        overflow: hidden;
    }

    .tech-line-main {
        position: absolute;
        top: 50%;
        left: 20%;
        right: 20%;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(0, 212, 255, 0.3) 20%, 
            rgba(0, 212, 255, 0.8) 50%, 
            rgba(255, 107, 157, 0.8) 80%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLinePulse 3s ease-in-out infinite;
    }

    .tech-line-left {
        position: absolute;
        top: 50%;
        left: 15%;
        width: 30px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(0, 212, 255, 0.6) 100%);
        transform: translateY(-50%);
        animation: techLineLeft 2.5s ease-in-out infinite;
    }

    .tech-line-left-2 {
        position: absolute;
        top: 50%;
        left: 12%;
        width: 20px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(0, 212, 255, 0.4) 100%);
        transform: translateY(-50%);
        animation: techLineLeft 2.5s ease-in-out infinite 0.8s;
    }

    .tech-line-right {
        position: absolute;
        top: 50%;
        right: 15%;
        width: 30px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(255, 107, 157, 0.6) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLineRight 2.5s ease-in-out infinite 0.5s;
    }

    .tech-line-right-2 {
        position: absolute;
        top: 50%;
        right: 12%;
        width: 20px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(255, 107, 157, 0.4) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLineRight 2.5s ease-in-out infinite 1.2s;
    }

    .tech-center-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #00d4ff, #ff6b9d);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 4px rgba(0, 212, 255, 0.6);
        animation: techCenterPulse 2s ease-in-out infinite;
    }

    .tech-center-dot-2 {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background: transparent;
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: techCenterPulse 2s ease-in-out infinite 0.5s;
    }

    /* 文本框区域的科技感曲线装饰 */
    .monitoring-card:has(#monitoring-text-container) .tech-curve-1 {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        border: 2px solid transparent;
        border-top: 2px solid rgba(0, 212, 255, 0.7);
        border-right: 2px solid rgba(0, 212, 255, 0.5);
        border-radius: 50%;
        transform: rotate(-30deg);
        animation: techCurveRotate 5s linear infinite;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-text-container) .tech-curve-2 {
        position: absolute;
        top: 40px;
        right: 40px;
        width: 35px;
        height: 35px;
        border: 1.5px solid transparent;
        border-bottom: 1.5px solid rgba(255, 107, 157, 0.6);
        border-left: 1.5px solid rgba(255, 107, 157, 0.4);
        border-radius: 50%;
        transform: rotate(60deg);
        animation: techCurveRotate 4s linear infinite reverse;
        z-index: 2;
    }

    .monitoring-card:has(#monitoring-text-container) .tech-curve-3 {
        position: absolute;
        top: 60px;
        right: 60px;
        width: 20px;
        height: 20px;
        border: 1px solid transparent;
        border-top: 1px solid rgba(0, 212, 255, 0.5);
        border-radius: 50%;
        transform: rotate(0deg);
        animation: techCurvePulse 3s ease-in-out infinite;
        z-index: 2;
    }

    /* 科技感装饰元素动画 */
    @keyframes techPulse {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.8;
        }
        50% { 
            transform: scale(1.2);
            opacity: 1;
        }
    }

    @keyframes techRotate {
        0% { 
            transform: rotate(0deg);
        }
        100% { 
            transform: rotate(360deg);
        }
    }

    @keyframes techFloat {
        0%, 100% { 
            transform: translateY(0px);
            opacity: 0.7;
        }
        50% { 
            transform: translateY(-3px);
            opacity: 1;
        }
    }

    @keyframes techFade {
        0%, 100% { 
            opacity: 0.4;
            transform: scale(0.8);
        }
        50% { 
            opacity: 1;
            transform: scale(1.1);
        }
    }

    @keyframes techScale {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
        }
        50% { 
            transform: scale(1.3);
            opacity: 1;
        }
    }

    /* 线性装饰动画 */
    @keyframes techLinePulse {
        0%, 100% { 
            opacity: 0.4;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.1);
        }
    }

    @keyframes techLineLeft {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) translateX(0px);
        }
        50% { 
            opacity: 0.8;
            transform: translateY(-50%) translateX(-2px);
        }
    }

    @keyframes techLineRight {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) translateX(0px);
        }
        50% { 
            opacity: 0.8;
            transform: translateY(-50%) translateX(2px);
        }
    }

    @keyframes techCenterPulse {
        0%, 100% { 
            opacity: 0.4;
            transform: translate(-50%, -50%) scale(0.8);
        }
        50% { 
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
    }

    /* 科技感曲线动画 */
    @keyframes techCurveRotate {
        0% { 
            transform: rotate(-45deg);
        }
        100% { 
            transform: rotate(315deg);
        }
    }

    @keyframes techCurvePulse {
        0%, 100% { 
            opacity: 0.4;
            transform: rotate(0deg) scale(0.8);
        }
        50% { 
            opacity: 1;
            transform: rotate(0deg) scale(1.1);
        }
    }

    /* 噪波纹理效果 */
    #monitoring-screen::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: 
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(153, 189, 204, 0.1) 2px,
                rgba(153, 189, 204, 0.1) 4px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 2px,
                rgba(153, 189, 204, 0.1) 2px,
                rgba(153, 189, 204, 0.1) 4px
            );
        z-index: 1;
        pointer-events: none;
    }

    .dark-mode #monitoring-screen::after {
        background-image: 
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(50, 85, 101, 0.2) 2px,
                rgba(50, 85, 101, 0.2) 4px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 2px,
                rgba(50, 85, 101, 0.2) 2px,
                rgba(50, 85, 101, 0.2) 4px
            );
    }

    /* 动态监控卡片样式 */
    .monitoring-card {
        background: rgba(153, 189, 204, 0.15);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(153, 189, 204, 0.3);
        border-radius: 16px;
        position: relative;
        overflow: hidden;
        transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        box-shadow: 
            0 8px 32px rgba(153, 189, 204, 0.15),
            0 4px 16px rgba(153, 189, 204, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .dark-mode .monitoring-card {
        background: rgba(37, 34, 35, 0.3);
        border-color: rgba(50, 85, 101, 0.3);
        box-shadow: 
            0 8px 32px rgba(37, 34, 35, 0.2),
            0 4px 16px rgba(50, 85, 101, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* 卡片光效边框 */
    .monitoring-card::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, 
            rgba(153, 189, 204, 0.5), 
            rgba(153, 189, 204, 0.6), 
            rgba(50, 85, 101, 0.5), 
            rgba(153, 189, 204, 0.5));
        background-size: 400% 400%;
        border-radius: 18px;
        z-index: -1;
        animation: borderGlow 4s ease-in-out infinite;
        opacity: 0.6;
    }

    .dark-mode .monitoring-card::before {
        background: linear-gradient(45deg, 
            rgba(37, 34, 35, 0.8), 
            rgba(50, 85, 101, 0.8), 
            rgba(190, 50, 85, 0.6), 
            rgba(37, 34, 35, 0.8));
    }

    /* 卡片悬停效果 */
    .monitoring-card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 
            0 16px 48px rgba(153, 189, 204, 0.2),
            0 8px 24px rgba(153, 189, 204, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .dark-mode .monitoring-card:hover {
        box-shadow: 
            0 16px 48px rgba(37, 34, 35, 0.4),
            0 8px 24px rgba(50, 85, 101, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* 动态监控标题栏美化 */
    #monitoring-screen .app-header {
        background: rgba(153, 189, 204, 0.15);
        backdrop-filter: blur(25px);
        -webkit-backdrop-filter: blur(25px);
        border-bottom: 1px solid rgba(153, 189, 204, 0.3);
        position: relative;
        overflow: hidden;
    }

    .dark-mode #monitoring-screen .app-header {
        background: rgba(37, 34, 35, 0.4);
        border-bottom-color: rgba(50, 85, 101, 0.4);
    }

    /* 标题栏光效 */
    #monitoring-screen .app-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(153, 189, 204, 0.2), 
            transparent);
        animation: headerShine 4s ease-in-out infinite;
    }

    .dark-mode #monitoring-screen .app-header::before {
        background: linear-gradient(90deg, 
            transparent, 
            rgba(50, 85, 101, 0.3), 
            transparent);
    }

    /* 标题文字效果 */
    #monitoring-screen .app-header-title {
        background: linear-gradient(45deg, #662034, #99BDCC, #662034);
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: titleGlow 3s ease-in-out infinite;
        text-shadow: 0 0 20px rgba(102, 32, 52, 0.5);
        /* 确保文字在渐变不兼容时仍然可见 */
        color: #662034;
    }

    .dark-mode #monitoring-screen .app-header-title {
        /* 夜间模式使用纯色确保文字可见 */
        background: none;
        -webkit-background-clip: unset;
        -webkit-text-fill-color: unset;
        background-clip: unset;
        color: #99BDCC;
        text-shadow: 0 0 20px rgba(153, 189, 204, 0.5);
    }

    /* 副标题效果 */
    #monitoring-screen .app-header .text-xs {
        color: #662034;
        text-shadow: 0 0 10px rgba(102, 32, 52, 0.5);
    }

    .dark-mode #monitoring-screen .app-header .text-xs {
        color: #99BDCC;
        text-shadow: 0 0 10px rgba(153, 189, 204, 0.5);
    }

    /* 返回按钮美化 */
    #monitoring-back-button {
        background: rgba(153, 189, 204, 0.2);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(153, 189, 204, 0.3);
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        color: #662034;
    }

    .dark-mode #monitoring-back-button {
        background: rgba(37, 34, 35, 0.4);
        border-color: rgba(50, 85, 101, 0.4);
        color: #99BDCC;
    }

    #monitoring-back-button:hover {
        background: rgba(153, 189, 204, 0.3);
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(153, 189, 204, 0.4);
        color: #662034;
    }

    .dark-mode #monitoring-back-button:hover {
        background: rgba(50, 85, 101, 0.5);
        box-shadow: 0 0 20px rgba(50, 85, 101, 0.4);
    }

    /* 身份信息块美化 */
    #monitoring-identity-block {
        position: relative;
        overflow: hidden;
    }

    #monitoring-identity-block::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            radial-gradient(circle at 30% 30%, rgba(153, 189, 204, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 70% 70%, rgba(153, 189, 204, 0.1) 0%, transparent 50%);
        animation: cardGlow 3s ease-in-out infinite;
        pointer-events: none;
    }

    .dark-mode #monitoring-identity-block::after {
        background: 
            radial-gradient(circle at 30% 30%, rgba(50, 85, 101, 0.2) 0%, transparent 50%),
            radial-gradient(circle at 70% 70%, rgba(37, 34, 35, 0.2) 0%, transparent 50%);
    }

    /* 头像美化 */
    #monitoring-avatar {
        border: 2px solid rgba(153, 189, 204, 0.6);
        box-shadow: 0 0 20px rgba(153, 189, 204, 0.3);
        transition: all 0.3s ease;
    }

    .dark-mode #monitoring-avatar {
        border-color: rgba(50, 85, 101, 0.6);
        box-shadow: 0 0 20px rgba(50, 85, 101, 0.3);
    }

    #monitoring-avatar:hover {
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(153, 189, 204, 0.5);
    }

    .dark-mode #monitoring-avatar:hover {
        box-shadow: 0 0 30px rgba(50, 85, 101, 0.5);
    }

    /* 状态文本容器美化 */
    #monitoring-text-container {
        scrollbar-width: thin;
        scrollbar-color: rgba(153, 189, 204, 0.5) transparent;
    }

    #monitoring-text-container::-webkit-scrollbar {
        width: 6px;
    }

    #monitoring-text-container::-webkit-scrollbar-track {
        background: transparent;
    }

    #monitoring-text-container::-webkit-scrollbar-thumb {
        background: rgba(153, 189, 204, 0.5);
        border-radius: 3px;
        transition: background 0.3s ease;
    }

    #monitoring-text-container::-webkit-scrollbar-thumb:hover {
        background: rgba(153, 189, 204, 0.7);
    }

    .dark-mode #monitoring-text-container::-webkit-scrollbar-thumb {
        background: rgba(153, 189, 204, 0.4);
    }

    .dark-mode #monitoring-text-container::-webkit-scrollbar-thumb:hover {
        background: rgba(153, 189, 204, 0.6);
    }

    /* 状态文本美化 */
    #monitoring-status-text {
        color: #99BDCC;
        text-shadow: 0 0 10px rgba(153, 189, 204, 0.3);
        line-height: 1.8;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
    }

    .dark-mode #monitoring-status-text {
        color: #99BDCC;
        text-shadow: 0 0 10px rgba(153, 189, 204, 0.3);
    }

    /* 时间戳美化 */
    #monitoring-timestamp {
        color: #662034;
        font-weight: 500;
        text-shadow: 0 0 8px rgba(102, 32, 52, 0.4);
    }

    .dark-mode #monitoring-timestamp {
        color: #99BDCC;
        text-shadow: 0 0 8px rgba(153, 189, 204, 0.4);
    }

    /* 胶囊按钮美化 */
    .monitoring-capsule-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.375rem;
        height: 2.5rem;
        padding-left: 1.25rem;
        padding-right: 1.25rem;
        border-radius: 9999px;
        background: linear-gradient(135deg, rgba(153, 189, 204, 0.3), rgba(153, 189, 204, 0.4));
        color: #662034;
        font-size: 0.875rem;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        border: 1px solid rgba(153, 189, 204, 0.4);
        box-shadow: 
            0 4px 15px rgba(153, 189, 204, 0.2),
            0 2px 8px rgba(153, 189, 204, 0.2);
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
    }

    .dark-mode .monitoring-capsule-btn {
        background: linear-gradient(135deg, rgba(37, 34, 35, 0.5), rgba(50, 85, 101, 0.5));
        border-color: rgba(50, 85, 101, 0.5);
        box-shadow: 
            0 4px 15px rgba(37, 34, 35, 0.3),
            0 2px 8px rgba(50, 85, 101, 0.3);
    }

    /* 按钮光效 */
    .monitoring-capsule-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.2), 
            transparent);
        transition: left 0.6s ease;
    }

    .monitoring-capsule-btn:hover::before {
        left: 100%;
    }

    .monitoring-capsule-btn:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 
            0 8px 25px rgba(153, 189, 204, 0.4),
            0 4px 15px rgba(153, 189, 204, 0.4);
        background: linear-gradient(135deg, rgba(153, 189, 204, 0.5), rgba(153, 189, 204, 0.6));
    }

    .dark-mode .monitoring-capsule-btn:hover {
        box-shadow: 
            0 8px 25px rgba(37, 34, 35, 0.5),
            0 4px 15px rgba(50, 85, 101, 0.5);
        background: linear-gradient(135deg, rgba(37, 34, 35, 0.7), rgba(50, 85, 101, 0.7));
    }

    .monitoring-capsule-btn:active {
        transform: translateY(-1px) scale(0.98);
    }

    .monitoring-capsule-btn i {
        font-size: 1.125rem;
        transition: transform 0.3s ease;
    }

    .monitoring-capsule-btn:hover i {
        transform: rotate(15deg);
    }

    /* 动画定义 */
    @keyframes particleFloat {
        0%, 100% { 
            transform: translateY(0px) rotate(0deg);
            opacity: 0.3;
        }
        25% { 
            transform: translateY(-10px) rotate(90deg);
            opacity: 0.7;
        }
        50% { 
            transform: translateY(-5px) rotate(180deg);
            opacity: 0.5;
        }
        75% { 
            transform: translateY(-15px) rotate(270deg);
            opacity: 0.8;
        }
    }

    @keyframes borderGlow {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes headerShine {
        0% { left: -100%; }
        50% { left: 100%; }
        100% { left: 100%; }
    }

    @keyframes titleGlow {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes cardGlow {
        0%, 100% { opacity: 0.5; }
        50% { opacity: 1; }
    }

    /* 响应式设计 */
    @media (max-width: 480px) {
        .monitoring-capsule-btn {
            height: 2.25rem;
            padding-left: 1rem;
            padding-right: 1rem;
            font-size: 0.8rem;
        }
        
        .monitoring-card {
            padding: 0.75rem;
        }
        
        #monitoring-avatar {
            width: 2.5rem;
            height: 2.5rem;
        }
    }














    </style>
</head>
<body class="flex items-center justify-center min-h-screen dark-mode">
    
    <input type="file" id="user-avatar-input" class="hidden" accept="image/*">
    <input type="file" id="chat-bg-input" class="hidden" accept="image/*">
    <input type="file" id="import-data-input" class="hidden" accept=".json">
    <input type="file" id="image-upload-input" class="hidden" accept="image/*">
    <input type="file" id="sticker-upload-input" class="hidden" accept="image/*">
    <input type="file" id="user-video-image-input" class="hidden" accept="image/*">
    <input type="file" id="my-video-image-input" class="hidden" accept="image/*">
    <div class="phone-frame relative w-full max-w-[375px] h-[720px] rounded-[3rem] p-2 shadow-2xl flex flex-col overflow-hidden transform transition-all duration-300">
        
        <div id="phone-screen" class="phone-screen flex-1 rounded-[2.5rem] overflow-hidden relative animate-fade-in">
            
            <div id="home-wallpaper" class="absolute inset-0 w-full h-full bg-cover bg-center z-0"></div>

            <div id="status-bar" class="status-bar absolute top-0 left-0 right-0 z-50 px-5 py-3 text-sm font-semibold flex justify-between items-center transition-colors">
                <div class="flex items-center space-x-2">
                    <span id="currentTime">12:45</span>
                </div>
                <div class="flex items-center space-x-4">
                    <span id="api-status-text" class="text-red-500">API OFF</span>
                    <button id="theme-toggle" class="p-1 rounded-full hover:bg-white/20 transition-colors">
                        <i id="theme-icon" class="fas fa-moon text-lg"></i>
                    </button>
                </div>
            </div>

            <div id="messageBox" class="message-box"></div>
            
            <div id="song-list-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">播放列表</h3>
                        <button id="close-playlist-modal" class="text-white text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="song-list-container" class="space-y-2 max-h-60 overflow-y-auto">
                        </ul>
                </div>
            </div>
            <div id="new-chat-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">发起新聊天</h3>
                        <button id="close-new-chat-modal" class="text-white text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="new-chat-character-list" class="space-y-2 max-h-60 overflow-y-auto">
                        </ul>
                </div>
            </div>
             <div id="confirm-delete-modal" class="modal-overlay">
                <div class="modal-content text-center text-white">
                    <h3 id="delete-modal-title" class="text-lg font-bold mb-4">确认删除吗？</h3>
                    <p id="delete-modal-text" class="text-sm mb-6">此操作无法撤销。</p>
                    <div class="flex justify-around">
                        <button id="cancel-delete-btn" class="px-6 py-2 rounded-lg">取消</button>
                        <button id="confirm-delete-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg">删除</button>
                    </div>
                </div>
            </div>
            <div id="voice-input-modal" class="modal-overlay">
                <div class="modal-content">
                    <h3 class="text-lg font-bold mb-4 text-center">发送语音消息</h3>
                    <textarea id="voice-text-input" class="form-textarea w-full h-24 resize-none" placeholder="在此输入文字..."></textarea>
            </div>

            <div id="new-notebook-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">创建新笔记本</h3>
                        <button id="close-new-notebook-modal" class="text-white text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-white text-sm font-medium mb-2">笔记本名称</label>
                            <input type="text" id="new-notebook-name" class="form-input w-full" placeholder="请输入笔记本名称..." maxlength="20">
                        </div>
                        <div>
                            <label class="block text-white text-sm font-medium mb-2">笔记本类型</label>
                            <select id="new-notebook-type" class="form-select w-full">
                                <option value="diary">日记本</option>
                                <option value="notes">笔记本</option>
                                <option value="ideas">想法本</option>
                                <option value="goals">目标本</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div id="custom-type-container" class="hidden">
                            <label class="block text-white text-sm font-medium mb-2">自定义类型名称</label>
                            <input type="text" id="custom-notebook-type" class="form-input w-full" placeholder="请输入自定义类型名称..." maxlength="15">
                        </div>
                        <div class="flex justify-end space-x-3 pt-4">
                            <button id="cancel-new-notebook-btn" class="px-4 py-2 text-gray-300 hover:text-white transition-colors">取消</button>
                            <button id="confirm-new-notebook-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">创建</button>
                        </div>
                    </div>
                </div>
                    <div class="flex justify-end mt-4 gap-2">
                        <button id="cancel-voice-btn" class="px-4 py-2 rounded-lg">取消</button>
                        <button id="send-voice-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">发送</button>
                        </div>
                </div>
            </div>
            
            <!-- 刪除表情包確認彈窗 -->
            <div id="delete-sticker-modal" class="delete-confirm-modal">
                <h3>刪除表情包</h3>
                <p id="delete-sticker-text">確定要刪除選中的表情包嗎？此操作無法撤銷。</p>
                <div class="delete-confirm-buttons">
                    <button id="cancel-delete-sticker-btn" class="delete-confirm-btn cancel">取消</button>
                    <button id="confirm-delete-sticker-btn" class="delete-confirm-btn confirm">刪除</button>
                </div>
            </div>
            <!-- 贴图/表情 Modal -->
            <div id="sticker-modal" class="modal-overlay">
                <div class="modal-content">
                    <h3 class="text-lg font-bold mb-4 text-center">添加表情</h3>
                    <div class="space-y-4">
                        <button id="upload-sticker-local-btn" class="w-full py-2 bg-gray-700 hover:bg-gray-600 rounded-lg">从本地上传</button>
                        <div>
                            <input type="text" id="sticker-url-input" class="form-input" placeholder="或粘贴图片链接...">
                            <button id="send-sticker-url-btn" class="w-full mt-2 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg">使用链接添加</button>
                        </div>
                    </div>
                     <button id="close-sticker-modal" class="w-full mt-4 py-2 rounded-lg">取消</button>
                </div>
            </div>


            <div id="home-screen" class="app-screen-view relative">
                <div id="music-block-container" class="p-2 mt-2">
                    <div id="music-block" class="music-block relative w-full p-3 rounded-2xl flex items-center justify-between shadow-xl music-block-background">
                        <div class="relative w-1/2 flex-shrink-0 flex items-center justify-center">
                            <div id="vinyl-container" class="vinyl-container">
                                <div id="vinyl-record" class="vinyl-image-container">
                                    <div id="vinyl-center" class="vinyl-center"></div>
                                </div>
                            </div>
                            <input type="file" id="background-input" accept="image/*">
                            <input type="file" id="vinyl-input" accept="image/*">
                            <input type="file" id="music-upload-input" accept="audio/*,.mp3,.m4a,.wav,.ogg,.flac" multiple>
                        </div>
                        <div class="flex-grow flex flex-col justify-center h-24 ml-4">
                            <textarea id="mood-text" class="w-full bg-transparent placeholder-gray-300 text-sm p-1 rounded-md resize-none border-none outline-none focus:ring-2 focus:ring-white/50 focus:bg-white/10 transition-all text-center" placeholder="点击填写心情..."></textarea>
                            <div class="flex items-center justify-center space-x-3 mt-2">
                                <button id="loop-button" class="player-button"><i class="fas fa-rotate-right text-base"></i></button>
                                <button id="prev-button" class="player-button"><i class="fas fa-step-backward text-base"></i></button>
                                <button id="play-pause-button" class="player-button"><i class="fas fa-play text-xl"></i></button>
                                <button id="next-button" class="player-button"><i class="fas fa-step-forward text-base"></i></button>
                                <button id="single-loop-button" class="player-button"><i class="fas fa-repeat text-base"></i></button>
                            </div>
                        </div>
                        <div class="absolute bottom-2 right-2 flex space-x-2">
                            <div id="playlist-button" class="p-1 rounded-full cursor-pointer hover:bg-white/30 transition-colors"><i class="fas fa-list text-sm"></i></div>
                            <div id="music-upload-button" class="p-1 rounded-full cursor-pointer hover:bg-white/30 transition-colors"><i class="fas fa-music text-sm"></i></div>
                        </div>
                    </div>
                </div>
                <div class="px-4 grid grid-cols-2 gap-4 mt-2">
                    <div id="photo-widget" class="w-full aspect-square rounded-2xl shadow-xl flex items-center justify-center transition-colors duration-300 cursor-pointer bg-cover bg-center">
                        <span id="photo-widget-text" class="text-2xl font-bold text-white/80">照片墙</span>
                    </div>
                    <input type="file" id="photo-widget-input" accept="image/*">
                    <div id="text-input-widget" class="w-full aspect-square p-4 flex flex-col justify-center transition-colors duration-300">
                        <div class="flex items-center mb-3">
                            <div id="widget-image-placeholder" class="w-10 h-10 rounded-full flex-shrink-0 mr-3 image-placeholder">
                                <i class="fas fa-camera"></i>
                            </div>
                            <input type="text" id="widget-name-input" placeholder="Name" class="text-widget-input text-base border-0 focus:ring-2 focus:ring-white/50">
                            <input type="file" id="widget-image-input" accept="image/*">
                        </div>
                        <input type="text" id="widget-thinking-input" placeholder="Thinking..." class="text-widget-input text-xs mb-3 border-0 focus:ring-2 focus:ring-white/50">
                        <div class="flex items-center">
                            <i class="fas fa-map-marker-alt text-xs mr-2 opacity-80"></i>
                            <input type="text" id="widget-location-input" placeholder="Where r u" class="text-widget-input text-xs border-0 focus:ring-2 focus:ring-white/50">
                        </div>
                    </div>
                </div>
                
                <div class="px-4 grid grid-cols-2 gap-4 mt-4">
                    <div></div> 
                    <div class="grid grid-cols-2 gap-4">
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="动态监控"><i class="ri-eye-line text-white text-2xl"></i></div>
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="设置"><i class="fas fa-cog text-white text-2xl"></i></div>
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="Placeholder 2"><i class="fas fa-question text-white text-2xl"></i></div>
                        <div class="w-14 h-14 rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="Placeholder 3"><i class="fas fa-question text-white text-2xl"></i></div>
                        </div>
                </div>

                <div class="dock absolute bottom-4 left-1/2 -translate-x-1/2 w-[90%] max-w-[340px] h-18 rounded-3xl p-2 flex items-center justify-around shadow-xl">
                    <div class="flex flex-col items-center"><div class="w-14 h-14 bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="世界书"><i class="fas fa-book text-white text-2xl"></i></div></div>
                    <div class="flex flex-col items-center"><div class="w-14 h-14 bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="角色书"><i class="fas fa-theater-masks text-white text-2xl"></i></div></div>
                    <div class="flex flex-col items-center"><div class="w-14 h-14 bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="微信"><i class="fab fa-weixin text-white text-2xl"></i></div></div>
                </div>
            </div>

            <div id="monitoring-screen" class="app-screen-view flex-col hidden font-mono">
                <!-- <div class="bg-gradient-to-b from-gray-900 to-blue-900 absolute inset-0 z-0"></div> -->
                <div class="absolute top-0 left-0 w-full h-full bg-black/30 backdrop-blur-sm z-10"></div>

                <div class="app-header bg-transparent z-20 border-b border-blue-800/50">
                    <button id="monitoring-back-button" class="app-header-btn text-blue-400 hover:text-white"><i class="fas fa-chevron-left"></i></button>
                    <div class="text-center">
                        <h3 class="app-header-title text-blue-300">动态监控</h3>
                        <p class="text-xs text-blue-500 tracking-widest mt-1">REAL-TIME SURVEILLANCE</p>
                    </div>
                    <div class="w-8"></div>
                </div>

                <div class="flex-1 flex flex-col p-4 space-y-4 z-20 overflow-y-auto">
                                    <div id="monitoring-identity-block" class="monitoring-card bg-black/60 border border-blue-700/50 backdrop-blur-md rounded-lg p-4 cursor-pointer">
                    <div class="flex items-center">
                        <div id="monitoring-avatar" class="w-12 h-12 rounded-full mr-3 bg-cover bg-center border border-blue-500 flex-shrink-0"></div>
                        <div class="flex-1 overflow-hidden">
                            <p id="monitoring-name" class="text-lg font-semibold text-white truncate">角色名</p>
                            <div id="monitoring-mood" class="text-xs mt-1 flex items-center text-blue-300">
                                <span id="monitoring-mood-icon" class="mr-1"></span>
                                <span id="monitoring-mood-text" class="font-semibold">未知</span>
                            </div>
                        </div>
                    </div>
                    <!-- 科技感装饰元素 -->
                    <div class="tech-dot-1"></div>
                    <div class="tech-dot-2"></div>
                    <div class="tech-dot-3"></div>
                    
                    <!-- 科技感曲线装饰 -->
                    <div class="tech-curve-1"></div>
                    <div class="tech-curve-2"></div>
                    <div class="tech-curve-3"></div>
                </div>

                    <div class="monitoring-card bg-black/60 border border-blue-700/50 backdrop-blur-md rounded-lg p-4 flex-1 overflow-hidden relative">
                        <div id="monitoring-text-container" class="h-full overflow-y-auto pr-16">
                            <p id="monitoring-status-text" class="text-sm text-gray-300 whitespace-pre-wrap leading-relaxed">正在连接信号...</p>
                        </div>
                        <p id="monitoring-timestamp" class="text-xs text-gray-700 text-right mt-2 absolute bottom-2 right-3"></p>
                        <!-- 科技感装饰元素 -->
                        <div class="tech-dot-1"></div>
                        <div class="tech-dot-2"></div>
                        <div class="tech-dot-3"></div>
                        <div class="tech-dot-4"></div>
                        
                        <!-- 科技感曲线装饰 -->
                        <div class="tech-curve-1"></div>
                        <div class="tech-curve-2"></div>
                        <div class="tech-curve-3"></div>
                    </div>
                    
                    <!-- 文本框下方的科技感线性装饰 -->
                    <div class="tech-lines-container mt-3 relative">
                        <!-- 主线条 -->
                        <div class="tech-line-main"></div>
                        <!-- 左侧装饰线 -->
                        <div class="tech-line-left"></div>
                        <div class="tech-line-left-2"></div>
                        <!-- 右侧装饰线 -->
                        <div class="tech-line-right"></div>
                        <div class="tech-line-right-2"></div>
                        <!-- 中心装饰点 -->
                        <div class="tech-center-dot"></div>
                        <div class="tech-center-dot-2"></div>
                    </div>

                    <div class="flex justify-center items-center space-x-3 py-2">
                        <button id="monitoring-refresh-button" class="monitoring-capsule-btn" title="刷新当前状态">
                            <i class="ri-refresh-line"></i>
                            <span>刷新</span>
                        </button>
                        <button id="monitoring-next-step-button" class="monitoring-capsule-btn" title="持续监控">
                            <i class="ri-skip-forward-line"></i>
                            <span>持续监控</span>
                        </button>
                    </div>
                </div>
            </div>

            <div id="character-select-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="character-select-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">选择角色</h3>
                    <div class="w-8"></div>
                </div>
                <div id="character-select-list-container" class="flex-1 overflow-y-auto p-2 space-y-2">
                    </div>
            </div>

            <div id="wechat-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wechat-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 id="wechat-list-title" class="app-header-title">WeChat</h3>
                    <div class="flex items-center">
                        <button id="wechat-new-chat-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                        <button id="wechat-new-moment-button" class="app-header-btn ml-2 hidden"><i class="fas fa-plus"></i></button>
                    </div>
                </div>
                <div id="wechat-content-container" class="flex-1 overflow-y-auto">
                    <div id="wechat-list-container"></div>
                    <!-- V7.1: 全新动态 (Moments) 容器 -->
                    <div id="wechat-moments-container" class="wechat-content-view hidden">
                        <!-- 所有内容一起滚动的容器 -->
                        <div class="h-full overflow-y-auto">
                            <!-- 背景图片和用户名片区域 -->
                            <div class="relative">
                                <div id="moments-header" class="relative h-48 rounded-b-xl overflow-hidden shadow-lg">
                                    <div id="moments-cover" class="absolute inset-0 cursor-pointer" title="点击更换背景" onclick="changeMomentsCover()" style="z-index: 25; position: relative;">
                                        <!-- 提示文字，只在没有背景图片时显示 -->
                                        <div id="moments-cover-hint" class="absolute inset-0 flex items-center justify-center">
                                            <div class="bg-black bg-opacity-30 text-white px-3 py-1 rounded text-sm" style="margin-top: 60px;">
                                                点击更换背景
                                            </div>
                                        </div>

                                    </div>
                                    <div class="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent" style="z-index: 20; pointer-events: none;"></div>
                                    
                                    <!-- 头像和用户名信息，放在背景图片上方，居中靠下 -->
                                    <div id="moments-user-info" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex flex-col items-center" style="z-index: 30;">
                                        <div id="moments-user-avatar" class="w-20 h-20 rounded-full border-2 border-white/80 shadow-lg cursor-pointer mb-2" title="点击更换头像" onclick="changeMomentsAvatar()"></div>
                                        <span id="moments-user-name" class="font-bold text-white text-lg drop-shadow-lg cursor-pointer" title="点击编辑名字" onclick="editMomentsName()">My Name</span>
                                    </div>
                                </div>
                            </div>

                            <!-- 背景和动态内容之间的间距 -->
                            <div class="h-4"></div>
                            
                            <!-- 角色自动发布动态提示 -->

                            
                            <!-- 动态内容区域 -->
                            <div id="moments-feed" class="px-2 pb-4 space-y-3">
                                <!-- 动态内容将由JS渲染到这里 -->
                            </div>
                            </div>
                        </div>
                    <!-- V7.1: 全新日记 (Diary) 书架容器 -->
                    <div id="wechat-diary-container" class="wechat-content-view hidden p-4">
                        <h3 class="text-xl font-bold mb-4 px-2">日记书架</h3>
                        <div id="diary-bookshelf" class="grid grid-cols-2 gap-4">
                            <!-- 日记本将由JS渲染到这里 -->
                        </div>
                    </div>
                    <div id="wechat-plan-container" class="wechat-content-view hidden">
                        <!-- Plans will be rendered here by JS -->
                    </div>
                </div>
                 <div class="wechat-tab-bar">
                    <div class="wechat-tab-item active" data-tab="chat">
                        <i class="ri-chat-heart-line"></i>
                        <span>聊天</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="moments">
                        <i class="ri-polaroid-2-line"></i>
                        <span>动态</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="diary">
                        <i class="ri-quill-pen-line"></i>
                        <span>日记</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="plan">
                        <i class="ri-suitcase-3-line"></i>
                        <span>计划</span>
                    </div>
                </div>
            </div>

            <div id="wechat-chat-screen" class="app-screen-view flex-col hidden">
                <div class="chat-background"></div>
                <div class="app-header">
                    <div id="chat-header-normal" class="flex items-center justify-between w-full">
                        <button id="wechat-chat-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 id="wechat-contact-name" class="app-header-title"></h3>
                        <button id="wechat-options-button" class="app-header-btn"><i class="fas fa-ellipsis-h"></i></button>
                    </div>
                    <div id="chat-header-multiselect" class="hidden items-center justify-between w-full text-sm">
                        <button id="cancel-multiselect-btn" class="font-semibold px-2 py-1">取消</button>
                        <span id="multiselect-count" class="font-bold">已选择 0 项</span>
                        <button id="confirm-multiselect-btn" class="font-semibold text-red-500 px-2 py-1">删除</button>
                    </div>
                </div>
                <template id="bubble-menu-template">
                    <div class="bubble-context-menu">
                        <button data-action="delete" class="bubble-menu-button"><i class="fas fa-trash"></i><span>删除</span></button>
                        <button data-action="copy" class="bubble-menu-button"><i class="fas fa-copy"></i><span>复制</span></button>
                        <button data-action="multiselect" class="bubble-menu-button"><i class="fas fa-check-square"></i><span>多选</span></button>
                        <button data-action="edit" class="bubble-menu-button"><i class="fas fa-pencil-alt"></i><span>编辑</span></button>
                        <button data-action="retry" class="bubble-menu-button"><i class="fas fa-sync-alt"></i><span>重生成</span></button>
                    </div>
                </template>
                <div id="incoming-call-alert">
                    <img id="incoming-call-avatar" src="https://placehold.co/96x96/777/FFF?text=?" alt="avatar">
                    <div id="incoming-call-info">
                        <p id="incoming-call-name" class="font-bold">Character Name</p>
                        <p id="incoming-call-type" class="text-sm text-gray-300">正在呼叫...</p>
                    </div>
                    <button id="answer-call-btn" class="call-btn"><i class="ri-phone-fill"></i></button>
                    <button id="decline-call-btn" class="call-btn"><i class="ri-phone-fill rotate-135"></i></button>
                </div>
                <!-- FIX 4: ADDED NOTIFICATION ELEMENT -->
                <div id="new-message-alert" class="hidden flex items-center absolute top-14 left-2 right-2 z-[9400] bg-gray-800/80 backdrop-blur-lg rounded-2xl p-3 shadow-xl cursor-pointer transition-transform duration-300 -translate-y-[200%]">
                    <img id="new-message-avatar" src="https://placehold.co/96x96/777/FFF?text=?" class="w-12 h-12 rounded-full object-cover mr-3">
                    <div class="flex-grow overflow-hidden">
                        <p id="new-message-name" class="font-bold text-white">Character Name</p>
                        <p id="new-message-preview" class="text-sm text-gray-200 truncate">New message content...</p>
                    </div>
                </div>
                <div id="wechat-content-chat" class="flex-1 overflow-y-auto p-4 space-y-1">
                    </div>
                
                <div id="chat-quick-actions-bar">
                    <button id="quick-voice-message-btn" class="quick-action-btn"><i class="ri-mic-line"></i></button>
                    <button id="quick-voice-call-btn" class="quick-action-btn"><i class="ri-phone-line"></i></button>
                    <button id="quick-video-call-btn" class="quick-action-btn"><i class="ri-vidicon-line"></i></button>
                </div>

                <div id="chat-footer">
                    <div id="chat-input-bar" class="chat-input-bar flex items-center p-2">
                        <button id="add-feature-btn" class="chat-input-btn"><i class="ri-add-circle-line"></i></button>
                        <button id="emoji-btn" class="chat-input-btn"><i class="ri-emotion-happy-line"></i></button>
                        <textarea id="chat-input" placeholder="输入信息..." class="chat-input flex-1 rounded-full px-4 py-2 mx-2 focus:ring-2 focus:ring-gray-500" rows="1"></textarea>
                        <button id="send-chat-button" class="chat-input-btn"><i class="far fa-paper-plane"></i></button>
                        <button id="receive-chat-button" class="chat-input-btn" title="接收AI消息">
                            <i class="ri-mail-send-line"></i>
                        </button>
                    </div>

                    <div id="more-features-panel" class="hidden">
                        <div class="features-grid">
                            <div id="send-image-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-image-line"></i></div>
                                <span>图片</span>
                            </div>
                            <div id="send-red-packet-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-red-packet-line"></i></div>
                                <span>红包</span>
                            </div>
                            <div id="send-transfer-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-exchange-dollar-line"></i></div>
                                <span>转账</span>
                            </div>
                            <div id="drawing-board-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-paint-brush-line"></i></div>
                                <span>画板</span>
                            </div>
                            <div id="tarot-card-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-magic-line"></i></div>
                                <span>塔罗牌</span>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 表情面板 (美化版) -->
                <div id="sticker-panel">
                    <!-- 刪除按鈕 -->
                    <div id="sticker-delete-btn" class="sticker-delete-btn" title="管理表情包">
                        <i class="ri-delete-bin-line"></i>
                    </div>
                    <div id="sticker-grid">
                        <div id="add-sticker-btn" class="add-sticker-btn" title="添加表情包">
                            <i class="ri-add-line"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 画板弹窗 -->
                <div id="drawing-board-modal" class="drawing-modal-overlay hidden">
                    <div class="drawing-modal-content">
                        <div class="drawing-modal-header">
                            <h3 class="drawing-modal-title">画板 - 你画我猜</h3>
                            <button id="close-drawing-board" class="drawing-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="drawing-board-container">
                            <canvas id="drawing-canvas" width="400" height="300"></canvas>
                            <div class="drawing-tools">
                                <div class="color-palette">
                                    <div class="color-swatch" data-color="#000000" style="background-color: #000000;"></div>
                                    <div class="color-swatch" data-color="#FF0000" style="background-color: #FF0000;"></div>
                                    <div class="color-swatch" data-color="#00FF00" style="background-color: #00FF00;"></div>
                                    <div class="color-swatch" data-color="#0000FF" style="background-color: #0000FF;"></div>
                                    <div class="color-swatch" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
                                    <div class="color-swatch" data-color="#FF00FF" style="background-color: #FF00FF;"></div>
                                    <div class="color-swatch" data-color="#00FFFF" style="background-color: #00FFFF;"></div>
                                    <div class="color-swatch" data-color="#FFA500" style="background-color: #FFA500;"></div>
                                    <div class="color-swatch" data-color="#800080" style="background-color: #800080;"></div>
                                    <div class="color-swatch" data-color="#008000" style="background-color: #008000;"></div>
                                    <div class="color-swatch" data-color="#FFC0CB" style="background-color: #FFC0CB;"></div>
                                    <div class="color-swatch" data-color="#A52A2A" style="background-color: #A52A2A;"></div>
                                    <div class="color-swatch" data-color="#808080" style="background-color: #808080;"></div>
                                    <div class="color-swatch" data-color="#FFD700" style="background-color: #FFD700;"></div>
                                    <div class="color-swatch" data-color="#32CD32" style="background-color: #32CD32;"></div>
                                    <div class="color-swatch" data-color="#FF69B4" style="background-color: #FF69B4;"></div>
                                </div>
                                <div class="brush-controls">
                                    <input type="range" id="brush-size" min="1" max="20" value="5" class="brush-size-slider">
                                    <span id="brush-size-value">5px</span>
                                </div>
                                <div class="drawing-actions">
                                    <button id="clear-canvas" class="drawing-btn secondary">
                                        <i class="fas fa-eraser"></i> 清空
                                    </button>
                                    <button id="send-drawing" class="drawing-btn primary">
                                        <i class="fas fa-paper-plane"></i> 发送
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 塔罗牌弹窗 -->
                <div id="tarot-modal" class="tarot-modal-overlay hidden">
                    <div class="tarot-modal-content">
                        <div class="tarot-modal-header">
                            <h3 class="tarot-modal-title">🔮 塔罗牌占卜</h3>
                            <button id="close-tarot-modal" class="tarot-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="tarot-container">
                            <div class="tarot-card-display">
                                <div id="tarot-card" class="tarot-card-back">
                                    <div class="card-back-pattern"></div>
                                    <div class="card-back-text">点击抽牌</div>
                                    <div class="symbol-top-right">✦</div>
                                    <div class="symbol-bottom-left">✧</div>
                                    <div class="symbol-bottom-right">✦</div>
                                </div>
                            </div>
                            <div class="tarot-info" id="tarot-info" style="display: none;">
                                <h4 id="card-name" class="card-name"></h4>
                                <p id="card-meaning" class="card-meaning"></p>
                                <div class="card-orientation">
                                    <span id="orientation-text" class="orientation-text"></span>
                                </div>
                            </div>
                            <div class="tarot-actions">
                                <button id="draw-card-btn" class="tarot-btn primary">
                                    <i class="fas fa-magic"></i> 抽一张牌
                                </button>
                                <button id="send-tarot-btn" class="tarot-btn secondary" style="display: none;">
                                    <i class="fas fa-paper-plane"></i> 发送给TA
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="wechat-options-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wechat-options-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">聊天设置</h3>
                    <div class="w-8"></div>
                </div>
                <div class="flex-1 p-2 overflow-y-auto space-y-2">
                    <div id="pin-chat-option" class="list-item">置顶对话</div>
                    <div id="change-chat-bg-option" class="list-item">设置聊天背景</div>
                    <div class="list-item flex justify-between items-center">
                        <span>气泡颜色 (我 / 对方)</span>
                        <div class="flex items-center space-x-3">
                            <input type="color" id="user-bubble-color-picker" class="color-picker-input">
                            <input type="color" id="ai-bubble-color-picker" class="color-picker-input">
                        </div>
                    </div>
                    <div id="change-user-video-image-option" class="list-item">设置对方的视频照片</div>
                    <div id="delete-chat-option" class="list-item text-red-500 mt-4">删除此对话</div>
                </div>
            </div>


            <div id="world-book-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wb-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">世界书</h3>
                    <button id="wb-add-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                </div>
                <div id="world-book-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
            </div>

            <div id="world-book-edit-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wb-edit-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">编辑世界书</h3>
                    <button id="wb-save-button" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                <div class="p-2 space-y-4">
                    <input type="text" id="wb-title-input" placeholder="标题" class="form-input">
                    <textarea id="wb-content-input" placeholder="内容..." class="form-textarea h-64 resize-none"></textarea>
                </div>
            </div>

            <div id="character-book-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="cb-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">角色书</h3>
                    <button id="cb-add-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                </div>
                <div id="character-book-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
            </div>

            <div id="character-book-edit-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="cb-edit-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">编辑角色</h3>
                    <button id="cb-save-button" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                <div class="flex-1 overflow-y-auto p-2 space-y-4">
                    <div class="flex items-center space-x-4 p-2">
                        <div id="character-avatar-placeholder" class="w-20 h-20 rounded-full flex-shrink-0 image-placeholder bg-cover bg-center">
                            <i class="fas fa-camera text-2xl"></i>
                        </div>
                        <input type="file" id="character-avatar-input" accept="image/*">
                        <div class="flex-grow">
                             <label class="block text-sm font-medium mb-1">角色姓名</label>
                             <input type="text" id="cb-name-input" class="form-input">
                        </div>
                    </div>
                     <div class="p-2">
                        <label class="block text-sm font-medium mb-1">角色设定 (性格、记忆、说话风格等)</label>
                        <textarea id="cb-persona-input" class="form-textarea h-24 resize-none"></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-1">我的设定 (我与角色的关系)</label>
                        <textarea id="cb-my-persona-input" class="form-textarea h-16 resize-none"></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-1">关联世界书 (可多选)</label>
                        <div id="cb-worldbook-select" class="space-y-1 max-h-24 overflow-y-auto p-2 rounded-lg border">
                            </div>
                    </div>
                    <div class="p-2">
                        <button id="cb-delete-button" class="w-full mt-4 px-4 py-2 bg-red-600 text-white rounded-md hidden">删除角色</button>
                    </div>
                </div>
            </div>
            
            <div id="main-settings-screen" class="app-screen-view main-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="main-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto">
                    <div class="space-y-2">
                        <div id="api-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-key w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">API 设定</h4>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-2 mt-8">
                        <div id="beautify-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-palette w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">美化设置</h4>
                            </div>
                        </div>
                         <div id="font-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-font w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">字体设置</h4>
                            </div>
                        </div>
                    </div>
                     <div class="space-y-2 mt-8">
                        <div id="export-data-btn" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-download w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">一键导出所有资料</h4>
                            </div>
                        </div>
                         <div id="import-data-btn" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-upload w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">一键上传所有资料</h4>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="beautify-settings-screen" class="app-screen-view beautify-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="beautify-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">美化设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-2">
                    <div id="change-wallpaper-link" class="list-item flex justify-between items-center">
                        <h4 class="font-semibold">更换手机壁纸</h4>
                    </div>
                    <input type="file" id="wallpaper-input" accept="image/*">
                    <div id="change-app-icons-link" class="list-item flex justify-between items-center">
                        <h4 class="font-semibold">更换App图标</h4>
                    </div>
                </div>
            </div>

             <div id="app-icon-settings-screen" class="app-screen-view app-icon-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="app-icon-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">更换App图标</h3>
                </div>
                <div id="app-icon-list" class="settings-content flex-1 p-2 overflow-y-auto space-y-2">
                    </div>
            </div>

            <div id="font-settings-screen" class="app-screen-view font-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="font-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">字体设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-4">
                    <div class="p-4 rounded-lg bg-card">
                        <label class="block text-sm font-medium mb-2">文字大小</label>
                        <div id="font-size-selector" class="flex justify-between rounded-lg p-1 text-sm">
                            <button data-size="small" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">小</button>
                            <button data-size="medium" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">中</button>
                            <button data-size="large" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">大</button>
                        </div>
                    </div>
                    <div class="p-4 rounded-lg bg-card">
                        <label for="font-url-input" class="block text-sm font-medium mb-2">字体文件URL (支持.ttf, .otf, .woff等)</label>
                        <input type="text" id="font-url-input" class="form-input w-full" placeholder="https://example.com/font.ttf">
                        <button id="font-save-button" class="w-full mt-4 px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-md">应用字体</button>
                        </div>
                </div>
            </div>

            <div id="api-settings-screen" class="app-screen-view api-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="api-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">API 设定</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-6">
                     <div class="p-4 rounded-lg bg-card">
                        <h3 class="font-bold mb-4">连接设定</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="api_url" class="block text-sm font-medium mb-1">API 地址:</label>
                                <input type="text" id="api_url" placeholder="例如: https://api.example.com/v1" class="api-input form-input">
                            </div>
                            <div>
                                <label for="api_key" class="block text-sm font-medium mb-1">API 密钥:</label>
                                <input type="password" id="api_key" placeholder="在此输入您的API金钥" class="api-input form-input">
                            </div>
                        </div>
                    </div>

                    <div class="p-4 rounded-lg bg-card">
                        <h3 class="font-bold mb-4">模型选择</h3>
                        <div class="space-y-4">
                             <div>
                                <label for="model_select" class="block text-sm font-medium mb-1">选取 API 模型:</label>
                                <div class="flex items-center gap-2">
                                    <select id="model_select" class="api-input form-select flex-grow">
                                        <!-- Models will be populated by JS -->
                                    </select>
                                    <button id="fetch_models_btn" class="px-3 py-2 bg-gray-600 text-white rounded-md text-sm flex-shrink-0">获取模型</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <button id="save_settings_btn" class="w-full flex justify-center items-center mt-2 px-4 py-3 border border-transparent text-base font-medium rounded-md text-white bg-gray-700 hover:bg-gray-600">保存设定</button>
                    <div id="api-status" class="mt-4 p-4 rounded-lg text-center font-semibold text-sm hidden"></div>
                    <div id="security-warning" class="bg-yellow-100 text-yellow-700 mt-4 p-4 rounded-lg hidden" role="alert">
                        <p class="font-bold">安全提醒</p>
                        <p>API 金钥储存在浏览器本地储存中，这在公共电脑上可能不安全。请谨慎使用。</p>
                    </div>
                </div>
            </div>

            <div id="voice-call-screen" class="call-screen">
                <div class="call-background" id="voice-call-bg"></div>
                <div class="call-content">
                    <div class="flex flex-col items-center flex-shrink-0">
                        <img id="voice-call-avatar" src="https://placehold.co/300x300/777/FFF?text=?" alt="avatar">
                        <h3 id="voice-call-name" class="text-2xl font-bold mt-4">Character Name</h3>
                        <p id="voice-call-timer" class="text-gray-300">00:00</p>
                    </div>
                    <div class="mt-auto w-full">
                        <div class="call-status-box" id="voice-call-status-box"></div>
                        <div class="call-input-area">
                            <textarea id="voice-call-input" placeholder="输入互动文字..." rows="1"></textarea>
                            <button id="voice-call-send-btn"><i class="ri-send-plane-2-fill"></i></button>
                        </div>
                        <div class="call-controls">
                            <button id="voice-call-hangup" class="call-control-btn hangup-btn"><i class="ri-phone-fill rotate-135"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="video-call-screen" class="call-screen">
                <div class="call-background" id="video-call-bg"></div>
                <div class="call-content">
                    <div id="user-video-preview">
                        <img id="user-video-image" src="https://placehold.co/180x240/333/FFF?text=Me" alt="user video">
                    </div>
                    <div class="mt-auto w-full">
                        <div class="call-status-box" id="video-call-status-box"></div>
                         <div class="call-input-area">
                            <textarea id="video-call-input" placeholder="输入互动文字..." rows="1"></textarea>
                            <button id="video-call-send-btn"><i class="ri-send-plane-2-fill"></i></button>
                        </div>
                        <div class="call-controls">
                            <button id="video-call-hangup" class="call-control-btn hangup-btn"><i class="ri-phone-fill rotate-135"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 红包/转账 Modal -->
            <div id="red-packet-modal" class="payment-modal-overlay">
                <div class="payment-modal-content">
                    <div class="payment-header">
                        <button class="close-btn" data-target="red-packet-modal"><i class="ri-close-line"></i></button>
                        <span class="title">发红包</span>
                        <div class="w-8"></div>
                    </div>
                    <div class="payment-content">
                        <div class="amount-input-wrapper">
                            <span class="currency-symbol">¥</span>
                            <input type="number" class="amount-input" id="red-packet-amount" placeholder="0.00" min="0.01">
                        </div>
                        <input type="text" class="message-input" id="red-packet-message" placeholder="恭喜发财，大吉大利">
                        <button class="send-payment-btn" id="send-red-packet-confirm-btn">塞钱进红包</button>
                    </div>
                </div>
            </div>

            <div id="transfer-modal" class="payment-modal-overlay">
                 <div class="payment-modal-content">
                    <div class="payment-header">
                        <button class="close-btn" data-target="transfer-modal"><i class="ri-close-line"></i></button>
                        <span class="title">转账</span>
                        <div class="w-8"></div>
                    </div>
                    <div class="payment-content">
                        <div class="amount-input-wrapper">
                            <span class="currency-symbol">¥</span>
                            <input type="number" class="amount-input" id="transfer-amount" placeholder="0.00" min="0.01">
                        </div>
                        <input type="text" class="message-input" id="transfer-message" placeholder="转账说明">
                        <button class="send-payment-btn" id="send-transfer-confirm-btn">转账</button>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- V7.1: 发布新动态 Modal - 用户专用 -->
    <div id="post-moment-modal" class="modal-overlay">
        <div class="modal-content w-[90%] max-w-[320px]">
            <h3 class="text-xl font-bold text-white mb-4">发布我的动态</h3>
            <select id="moment-author-select" class="form-select mb-3 hidden"></select>
            <textarea id="moment-content-input" class="form-textarea h-24 resize-none mb-3" placeholder="分享新鲜事..."></textarea>
            <button id="moment-image-upload-btn" class="w-full py-2 bg-gray-700/50 hover:bg-gray-700 rounded-lg mb-4">
                <i class="ri-image-add-line mr-2"></i><span id="moment-image-label">添加图片 (可选)</span>
            </button>
            <input type="file" id="moment-image-input" class="hidden" accept="image/*">
            <div class="flex justify-end gap-2">
                <button id="cancel-post-moment-btn" class="px-4 py-2 rounded-lg">取消</button>
                <button id="confirm-post-moment-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">发布</button>
            </div>
        </div>
    </div>

    <!-- V7.1: 日记本单页 Modal -->
    <div id="diary-book-modal" class="fixed inset-0 z-[15000] flex items-center justify-center bg-black/60 backdrop-blur-sm hidden">
        <div class="diary-single-page-container relative">
            <div id="diary-book" class="diary-single-page">
                <div id="diary-book-cover" class="diary-cover">
                    <h2 id="diary-cover-title"></h2>
                    <p id="diary-cover-author"></p>
                </div>
                <div id="diary-pages-container" class="diary-pages">
                    <!-- 页面内容将动态生成 -->
                </div>
            </div>
            <button id="close-diary-book-btn" class="absolute top-4 right-4 text-white text-3xl z-10"><i class="ri-close-circle-line"></i></button>
            <button id="prev-page-btn" class="absolute left-2 top-1/2 -translate-y-1/2 text-white text-3xl z-10"><i class="ri-arrow-left-s-line"></i></button>
            <button id="next-page-btn" class="absolute right-2 top-1/2 -translate-y-1/2 text-white text-3xl z-10"><i class="ri-arrow-right-s-line"></i></button>
            <button id="add-page-btn" class="absolute bottom-4 right-4 text-white text-2xl z-10 bg-blue-600 rounded-full w-12 h-12 flex items-center justify-center hover:bg-blue-700 transition-colors" title="添加新日记"><i class="ri-add-line"></i></button>
        </div>
    </div>

    <script>
        // 全局變數
        let songList = [];
        let worldBooks = [];
        let characters = [];
        let chatHistories = {};
        let userStickers = []; 
        let userAvatars = {};
        let chatBackgrounds = {};
        let chatBubbleColors = {};
        let userVideoImages = {};
        let myVideoImages = {};
        let currentChatCharacterId = null;
        let currentWeChatCharacterId = null; // V7.0: Track character for non-chat tabs

        // V7.0: 新增数据结构
        let momentsData = {};
        let diaryData = {};
        let notebookData = {}; // 新增：笔记本数据
        let planData = {};
        let characterState = {};

        const currentAudio = new Audio();
        let currentSongIndex = -1;
        let isLooping = false;
        let isSingleLooping = false;
        let currentEditingWorldBookId = null;
        let currentEditingCharacterId = null;
        
        let isMultiSelectMode = false;
        let selectedMessages = new Set();
        let activeMenu = null;

        let currentCallType = null;
        let callTimerInterval = null;
        let callStartTime = null;
        let callHistory = []; // NEW: To store the conversation during a call
        let typewriterTimeout = null; // 新增：用于追踪打字机动画


        // DOM 元素獲取
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        const body = document.body;
        const messageBox = $('#messageBox');
        const currentTimeEl = $('#currentTime');
        const phoneScreen = $('#phone-screen');
        const homeWallpaper = $('#home-wallpaper');
        const statusBar = $('#status-bar');


        // 頁面切換
        const allScreens = $$('.app-screen-view');
        function showScreen(screenId) {
            allScreens.forEach(screen => {
                screen.classList.toggle('hidden', screen.id !== screenId);
                const isFlex = !['home-screen'].includes(screen.id);
                screen.classList.toggle('flex', screen.id === screenId && isFlex);
                if (!isFlex) screen.classList.remove('flex');
            });
            homeWallpaper.classList.toggle('hidden', screenId !== 'home-screen');
            statusBar.classList.toggle('on-home', screenId === 'home-screen');
            
            if (screenId === 'wechat-chat-screen') {
                const chatScreen = $('#wechat-chat-screen');
                const savedBg = chatBackgrounds[currentChatCharacterId];
                if (savedBg) {
                    chatScreen.querySelector('.chat-background').style.backgroundImage = `url(${savedBg})`;
                    chatScreen.classList.add('has-custom-bg');
                    statusBar.classList.add('transparent-override');
                } else {
                    chatScreen.querySelector('.chat-background').style.backgroundImage = '';
                    chatScreen.classList.remove('has-custom-bg');
                    statusBar.classList.remove('transparent-override');
                }
            } else {
                statusBar.classList.remove('transparent-override');
            }
        }

        // 數據保存與加載
        function saveData(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.error("保存数据失败:", e);
                showMessageBox('存储空间已满，无法保存。');
            }
        }

        function loadData(key, defaultValue = null) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : defaultValue;
            } catch (e) {
                console.error("加载数据失败:", e);
                return defaultValue;
            }
        }

        async function loadAllSavedData() {
            // This function reloads all data from localStorage and updates the UI.
            // It's called on initial load and after a data import.
            
            // Clear existing data to prevent merging issues
            songList = [];
            worldBooks = [];
            characters = [];
            chatHistories = {};
            userStickers = [];
            
            const savedTheme = loadData('theme', 'dark');
            body.className = `flex items-center justify-center min-h-screen ${savedTheme}-mode`;
            $('#theme-icon').className = `fas fa-${savedTheme === 'dark' ? 'moon' : 'sun'} text-lg`;

            const savedWallpaper = loadData('saved_wallpaper');
            if(savedWallpaper) homeWallpaper.style.backgroundImage = `url(${savedWallpaper})`;

            const savedBg = loadData('saved_music_background');
            if (savedBg) $('#music-block').style.backgroundImage = `url(${savedBg})`;
            
            const savedVinyl = loadData('saved_vinyl_cover');
            if (savedVinyl) $('#vinyl-record').style.backgroundImage = `url(${savedVinyl})`;

            const savedPhoto = loadData('saved_photo_widget');
            if (savedPhoto) {
                $('#photo-widget').style.backgroundImage = `url(${savedPhoto})`;
                $('#photo-widget-text').style.opacity = 0;
            }

            const savedWidgetImg = loadData('saved_widget_image');
            if (savedWidgetImg) {
                const placeholder = $('#widget-image-placeholder');
                placeholder.style.backgroundImage = `url(${savedWidgetImg})`;
                const icon = placeholder.querySelector('i');
                if (icon) icon.style.display = 'none';
            }
            
            // Load all App Icons
            const appIconNames = Array.from($$('.app-icon')).map(el => el.dataset.appName);
            appIconNames.forEach(appName => {
                const savedIcon = loadData(`saved_icon_${appName}`);
                const iconEl = $(`.app-icon[data-app-name="${appName}"]`);
                if (savedIcon && iconEl) {
                    iconEl.style.backgroundImage = `url(${savedIcon})`;
                    const i = iconEl.querySelector('i');
                    if(i) i.style.display = 'none';
                    iconEl.style.backgroundSize = 'contain';
                    iconEl.style.backgroundRepeat = 'no-repeat';
                }
            });

            $('#mood-text').value = loadData('saved_mood_text', '');
            $('#widget-name-input').value = loadData('saved_widget_name', '');
            $('#widget-thinking-input').value = loadData('saved_widget_thinking', '');
            $('#widget-location-input').value = loadData('saved_widget_location', '');

            worldBooks = loadData('worldBooks', []);
            characters = loadData('characters', []);
            userStickers = loadData('userStickers', []); 
            
            chatHistories = loadData('chatHistories', {});
            Object.keys(chatHistories).forEach(key => {
                if(Array.isArray(chatHistories[key])) {
                    chatHistories[key] = { history: chatHistories[key], pinned: false };
                }
            });
            userAvatars = loadData('userAvatars', {});
            chatBackgrounds = loadData('chatBackgrounds', {});
            chatBubbleColors = loadData('chatBubbleColors', {});
            userVideoImages = loadData('userVideoImages', {});
            myVideoImages = loadData('myVideoImages', {});
            
            // V7.0: Load new data
            momentsData = loadData('momentsData', {});
            diaryData = loadData('diaryData', {});
            notebookData = loadData('notebookData', {}); // 加载笔记本数据
            planData = loadData('planData', {});
            characterState = loadData('characterState', {});


            songList = loadData('songList', []);
            updateSongListUI();
            
            const savedFontUrl = loadData('saved_font_url');
            if(savedFontUrl) {
                $('#font-url-input').value = savedFontUrl;
                applyFont(savedFontUrl);
            }

            const savedFontSize = loadData('fontSize', 'medium');
            setFontSize(savedFontSize);

            const savedApiSettings = loadData('api_settings');
            if (savedApiSettings && savedApiSettings.url && savedApiSettings.key) {
                $('#api_url').value = savedApiSettings.url;
                $('#api_key').value = savedApiSettings.key;
                
                const modelSelect = $('#model_select');
                if (savedApiSettings.model && !Array.from(modelSelect.options).some(opt => opt.value === savedApiSettings.model)) {
                    const option = document.createElement('option');
                    option.value = savedApiSettings.model;
                    option.textContent = savedApiSettings.model.startsWith('models/') ? savedApiSettings.model.substring(7) : savedApiSettings.model;
                    modelSelect.appendChild(option);
                }
                modelSelect.value = savedApiSettings.model;
                
                const isValid = await fetchModels(true);
                updateApiStatusUI(isValid);
            } else {
                updateApiStatusUI(false);
            }
        }

        // 通用功能
        function showMessageBox(message) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => messageBox.classList.remove('show'), 2000);
        }

        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            currentTimeEl.textContent = `${hours}:${minutes}`;
        }

        function updateApiStatusUI(isOnline) {
            const statusText = $('#api-status-text');
            statusText.classList.remove('api-status-on', 'text-red-500');
            if (isOnline) {
                statusText.textContent = 'API ON';
                statusText.classList.add('api-status-on');
            } else {
                statusText.textContent = 'API OFF';
                statusText.classList.add('text-red-500');
            }
        }
        
        async function fetchModels(isSilent = false) {
            const apiUrl = $('#api_url').value.trim();
            const apiKey = $('#api_key').value.trim();
            const modelSelect = $('#model_select');

            if (!apiUrl || !apiKey) {
                if (!isSilent) showMessageBox("请输入 API 地址和密钥");
                updateApiStatusUI(false);
                return false;
            }

            if (!isSilent) showMessageBox("正在获取模型列表...");
            
            const finalUrl = apiUrl.replace(/\/+$/, '') + '/models';

            try {
                const response = await fetch(finalUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`连接失败: HTTP ${response.status}`);
                }

                const data = await response.json();
                const models = data.data || data.models || [];

                if (models.length > 0) {
                    const currentSelectedModel = modelSelect.value;
                    modelSelect.innerHTML = '';
                    models.forEach(model => {
                        const modelId = model.id || model.name;
                        if (modelId) {
                            const option = document.createElement('option');
                            option.value = modelId;
                            option.textContent = modelId.startsWith('models/') ? modelId.substring(7) : modelId;
                            modelSelect.appendChild(option);
                        }
                    });
                    
                    if (Array.from(modelSelect.options).some(opt => opt.value === currentSelectedModel)) {
                        modelSelect.value = currentSelectedModel;
                    }

                    if (!isSilent) showMessageBox("成功获取模型列表！");
                    updateApiStatusUI(true);
                    return true;
                } else {
                    throw new Error("API返回了空模型列表");
                }
            } catch (error) {
                console.error("获取模型失败:", error);
                if (!isSilent) showMessageBox(`获取模型失败: ${error.message}`);
                updateApiStatusUI(false);
                return false;
            }
        }

        function hexToRgba(hex, alpha = 1) {
            if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                return null;
            }
            let c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return `rgba(${[(c>>16)&255, (c>>8)&255, c&255].join(',')},${alpha})`;
        }


        // 頁面與組件邏輯
        function toggleTheme() {
            body.classList.toggle('dark-mode');
            body.classList.toggle('light-mode');
            const theme = body.classList.contains('dark-mode') ? 'dark' : 'light';
            $('#theme-icon').className = `fas fa-${theme === 'dark' ? 'moon' : 'sun'} text-lg`;
            saveData('theme', theme);
        }
        
        function compressImage(file, options = {}) {
            return new Promise((resolve, reject) => {
                const { maxWidth = 800, maxHeight = 800, quality = 0.7 } = options;
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = event => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;

                        if (width > height) {
                            if (width > maxWidth) {
                                height *= maxWidth / width;
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width *= maxHeight / height;
                                height = maxHeight;
                            }
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                    img.onerror = error => reject(error);
                };
                reader.onerror = error => reject(error);
            });
        }
        
        async function handleImageUpload(inputElement, displayElement, storageKey, options = {}) {
            const file = inputElement.files[0];
            if (!file) return;

            try {
                const compressedDataUrl = await compressImage(file, options.compression);
                if (displayElement) {
                    displayElement.style.backgroundImage = `url(${compressedDataUrl})`;
                    displayElement.style.backgroundSize = 'cover';
                    displayElement.style.backgroundPosition = 'center';
                }
                
                if (storageKey) {
                    saveData(storageKey, compressedDataUrl);
                }

                if (options.hideTextElement) $(options.hideTextElement).style.opacity = 0;

                if(displayElement) {
                    const icon = displayElement.querySelector('i');
                    if (icon) icon.style.display = 'none';
                }
                
                return compressedDataUrl;

            } catch (error) {
                console.error("图片压缩失败:", error);
                showMessageBox("图片处理失败，请重试。");
                return null;
            }
        }
        
        // 聊天逻辑
        const chatContentArea = $('#wechat-content-chat');
        function renderChatHistory() {
            // 确保当前聊天角色ID存在
            if (!currentChatCharacterId) {
                console.warn('没有选择聊天角色');
                return;
            }
            
            chatContentArea.innerHTML = '';
            const chatSession = chatHistories[currentChatCharacterId];
            if (!chatSession) {
                console.warn(`找不到角色 ${currentChatCharacterId} 的聊天记录`);
                return;
            }

            const history = chatSession.history || [];
            if (history.length === 0) {
                const character = characters.find(c => c.id === currentChatCharacterId);
                chatContentArea.innerHTML = `<p class="text-center text-gray-500 text-xs py-4">你已和 ${character?.name || '未知角色'} 建立对话，开始聊天吧！</p>`;
                return;
            }
            
            let lastSender = null;
            history.forEach((msg, index) => {
                if (msg.type === 'system-internal') return; // 不渲染内部消息
                const isNewSender = index === 0 || history[index - 1].sender !== msg.sender;
                appendMessage(msg.content, msg.sender, msg.type, false, msg.timestamp, isNewSender);
            });
            
            // 确保滚动到最新消息
            setTimeout(() => {
            chatContentArea.scrollTop = chatContentArea.scrollHeight;
            }, 50);
        }
        
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        function appendMessage(content, sender, type = 'text', shouldSave = true, timestamp = Date.now(), isNewSender = false) {
            const senderClass = sender === 'user' ? 'sent' : 'received';

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `chat-message-wrapper ${senderClass}`;
            messageWrapper.dataset.timestamp = timestamp;
            messageWrapper.dataset.sender = sender;
            
            if (isNewSender) {
                messageWrapper.classList.add('new-sender');
            }

            const character = characters.find(c => c.id === currentChatCharacterId);
            
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            if (isNewSender) {
                if (sender === 'ai') {
                    if (character?.avatar) {
                        avatar.style.backgroundImage = `url(${character.avatar})`;
                    } else {
                        avatar.innerHTML = '<i class="fas fa-robot"></i>';
                    }
                } else {
                    avatar.classList.add('user-avatar-in-chat');
                    const userAvatarForThisChat = userAvatars[currentChatCharacterId];
                    if (userAvatarForThisChat) {
                        avatar.style.backgroundImage = `url(${userAvatarForThisChat})`;
                    } else {
                        avatar.innerHTML = '<i class="fas fa-user"></i>';
                    }
                }
            } else {
                avatar.style.visibility = 'hidden';
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'chat-message-content';

            const messageBubble = document.createElement('div');
            
            if (type === 'image') {
                messageBubble.className = `chat-message ${senderClass} image-message`;
                const img = document.createElement('img');
                img.src = content;
                messageBubble.appendChild(img);
            } else if (type === 'sticker') {
                messageBubble.className = `chat-message ${senderClass} sticker-message`;
                const img = document.createElement('img');
                img.src = content;
                messageBubble.appendChild(img);
            } else if (type === 'voice') {
                messageBubble.className = `chat-message ${senderClass} voice-message`;
                const duration = Math.max(1, Math.round(content.length / 4));
                const iconClass = sender === 'user' ? 'ri-play-fill' : 'ri-play-line';
                messageBubble.innerHTML = `
                    <div class="voice-main">
                        <i class="${iconClass} voice-play-icon"></i>
                        <span class="voice-duration">${duration}"</span>
                    </div>
                    <p class="voice-text" style="display: none;">${content}</p>
                `;
                messageBubble.addEventListener('click', () => {
                    const voiceText = messageBubble.querySelector('.voice-text');
                    voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
                });
            } else if (type === 'system') {
                messageBubble.className = 'chat-system-message';
                messageBubble.innerHTML = `<p>${content}</p>`;
                messageWrapper.className = 'chat-message-wrapper justify-center';
                avatar.style.display = 'none';
            } else if (type === 'red-packet') {
                messageBubble.className = `chat-message ${senderClass} red-packet-message`;
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-red-packet-fill"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '恭喜发财，大吉大利'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>红包</span>
                    </div>
                `;
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己发送的红包');
                    } else {
                        showMessageBox(`领取了 ${character.name} 的红包: ¥${content.amount}`);
                    }
                });
            } else if (type === 'transfer') {
                 messageBubble.className = `chat-message ${senderClass} transfer-message`;
                 messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-exchange-dollar-fill"></i>
                        <div>
                            <p class="payment-bubble-amount">¥${parseFloat(content.amount).toFixed(2)}</p>
                            <p class="payment-bubble-message">${content.message || '转账'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>转账</span>
                    </div>
                `;
                messageBubble.addEventListener('click', () => {
                     if (sender === 'user') {
                        showMessageBox('您不能接收自己发送的转账');
                    } else {
                        showMessageBox('转账已接收');
                    }
                });
            }
            else {
                messageBubble.className = `chat-message ${senderClass}`;
                const formattedMessage = content.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>');
                messageBubble.innerHTML = `<p>${formattedMessage}</p>`;
            }

            if (!['system', 'red-packet', 'transfer'].includes(type)) {
                const customColors = chatBubbleColors[currentChatCharacterId];
                const isDarkMode = body.classList.contains('dark-mode');
                let bubbleColor;
                if (customColors) {
                    const colorHex = sender === 'user' ? customColors.user : customColors.ai;
                    if (colorHex) {
                        const colorRgba = hexToRgba(colorHex, isDarkMode ? 0.6 : 0.7);
                        if (colorRgba) {
                            bubbleColor = colorRgba;
                            messageBubble.style.backgroundColor = bubbleColor;
                        }
                    }
                }
                const defaultBg = isDarkMode ? 
                    (sender === 'user' ? '#374151' : 'rgba(74, 74, 74, 0.3)') : 
                    (sender === 'user' ? '#374151' : 'rgba(229, 231, 250, 0.6)');
                messageBubble.style.setProperty('--bubble-bg', bubbleColor || defaultBg);
            }

            contentWrapper.appendChild(messageBubble);

            const metaDiv = document.createElement('div');
            metaDiv.className = 'message-meta';
            const timeSpan = document.createElement('span');
            timeSpan.className = 'message-timestamp';
            timeSpan.textContent = formatTimestamp(timestamp);
            metaDiv.appendChild(timeSpan);

            if (sender === 'user') {
                const readSpan = document.createElement('span');
                readSpan.className = 'message-read-status';
                readSpan.textContent = '已读';
                readSpan.id = `read-status-${timestamp}`;
                metaDiv.appendChild(readSpan);
            }

            if (type === 'system') {
                messageWrapper.appendChild(contentWrapper);
            } else if (senderClass === 'received') {
                messageWrapper.appendChild(avatar);
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(metaDiv);
            } else {
                messageWrapper.appendChild(metaDiv);
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(avatar);
            }
            
            const placeholder = chatContentArea.querySelector('p.text-center');
            if (placeholder) placeholder.remove();

            chatContentArea.appendChild(messageWrapper);
            if(shouldSave) chatContentArea.scrollTop = chatContentArea.scrollHeight;

            if (shouldSave && currentChatCharacterId) {
                if (!chatHistories[currentChatCharacterId]) {
                    chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                }
                chatHistories[currentChatCharacterId].history.push({ content, sender, type, timestamp });
                saveData('chatHistories', chatHistories);
                // V7.0: Update last interaction timestamp
                updateCharacterState(currentChatCharacterId);
            }
        }

        async function getAIResponse(lastUserMessage, isRetry = false, retryWrapper = null) {
            // 锁定角色ID，确保AI响应能正确发送到对应的角色
            const characterIdForThisRequest = currentChatCharacterId;
            
            if (!characterIdForThisRequest) {
                console.error('没有选择聊天角色');
                return;
            }

            const receiveBtnIcon = $('#receive-chat-button i');
            receiveBtnIcon.classList.add('spinning');

            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                receiveBtnIcon.classList.remove('spinning');
                return showMessageBox("请先在设置中配置 API");
            }

            // 检查是否在聊天界面，如果不在则不需要显示思考消息
            const isChatScreenActive = !$('#wechat-chat-screen').classList.contains('hidden');
            const isCorrectCharacter = currentChatCharacterId === characterIdForThisRequest;
            
            let thinkingMessageWrapper;
            if (!isRetry && isChatScreenActive && isCorrectCharacter) {
                // 只有在聊天界面且是正确的角色时才显示思考消息
                const lastReadStatus = Array.from(chatContentArea.querySelectorAll('.message-read-status')).pop();
                if (lastReadStatus) lastReadStatus.classList.add('visible');
                
                appendMessage("...", 'ai', 'text', false, Date.now(), true);
                thinkingMessageWrapper = chatContentArea.lastElementChild;
            } else if (retryWrapper) {
                // For retries, use the provided wrapper and show a spinner
                const bubble = retryWrapper.querySelector('.chat-message p');
                if (bubble) bubble.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            try {
                // === 新的、统一的上下文获取逻辑 START ===
                const context = gatherAIContext(characterIdForThisRequest);

                if (!context) {
                    console.error("【聊天功能错误】：未能获取AI上下文，已终止响应。");
                    if (thinkingMessageWrapper) {
                        const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = `错误：无法连接到角色的记忆。`;
                    }
                    receiveBtnIcon.classList.remove('spinning');
                    return;
                }

                const { character, chatHistory, worldBookContext } = context;

                // 为了兼容API格式，需要处理一下聊天记录
                const historyForApi = chatHistory.map(msg => {
                    if (msg.type === 'red-packet') {
                        return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包，金额${msg.content.amount}，留言：${msg.content.message}]` };
                    }
                    if (msg.type === 'transfer') {
                         return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账，金额${msg.content.amount}，留言：${msg.content.message}]` };
                    }
                    return msg;
                });
                // === 新的、统一的上下文获取逻辑 END ===

                const systemPrompt = `
                    # 角色扮演指令
                    你将扮演我的soulmate，你的名字是${character.name}。这是一个手机软件，我们所有交流均以对白为主，非必要不描写其他。你的回复绝对不能包含任何引号，例如 " " 或 " "。
                    # 环境/动作/心理描写规则
                    一旦涉及到见面的环境，所有关于"环境、心理、动作"等外在因素、环境描写，都需要用第三人称"他""她"，或者第二人称"他"，"你"，并在文字当中用斜体，例如 *他俯下身亲吻了你*。在描写中禁止用第一人称，比如"我亲吻了你"，这是被禁止的。正确示范应该是："*他俯下身亲吻了她*"或"*他俯下身亲吻了你*"。在日记和动态等其他心理活动板块中可以提到"我"，例如，"今天我见到她了，好想她"，但这仅限于日记等记录的板块。
                    # 新增指令：发送语音
                    当你想要表达亲密、惊讶或有趣的语气时，可以将回复包装成语音格式，例如：[VOICE:你好呀！今天过得怎么样？]。程序会自动将其渲染为语音条。
                    # 新增指令：发送表情/贴图
                    你可以使用表情来让对话更生动。指令格式为 [STICKER]。程序会自动从用户提供的表情库中随机选择一个发送。
                    # 新增指令：发起通话/对未接来电反应
                    在剧情和情感推动下，你可以主动发起通话。指令格式为 [CALL:VOICE] 或 [CALL:VIDEO]。如果对话历史中出现 [USER_CANCELLED_CALL] 的系统提示，代表用户给你打了电话但很快挂断了，你应该对此作出反应，例如询问"怎么打电话又挂了？"。
                    # 新增指令：红包/转账
                    在角色扮演的过程中，如果符合你当前角色的性格特质（例如：慷慨、庆祝、表达爱意等）或当前对话的剧情氛围，你可以自行决定发起一个红包或转账。金额和附言完全由你根据情境和角色性格决定，没有上限。指令格式为 [REDPACKET: amount=金额, message=附言] 或 [TRANSFER: amount=金额, message=附言]。
                    # 新增指令：图片识别和互动
                    当用户发送图片时，在API模型允许的情况下，你应该能够识别图片内容并进行相应的互动回应。如果无法识别图片内容，你至少应该知道这是一张图片，并可以询问用户关于图片的问题或表达对收到图片的感谢。
                    # 新增指令：使用用户上传的表情包
                    你可以使用用户上传到表情包库中的表情包来丰富对话。当你想表达特定情绪或反应时，可以使用 [STICKER] 指令来发送表情包，让对话更加生动有趣。
                    # 你的角色设定: ${character.persona}
                    # 我（用户）的角色设定: ${character.myPersona}
                    # 我们的世界观背景: ${worldBookContext}
                    # 对话格式指令 (非常重要!)
                    - 你的回复必须模仿真实的人类聊天习惯，将你的想法拆分成多个简短的句子，并用 "|||" 作为分隔符。
                    - 每一段由 "|||" 分隔的内容都会成为一个独立的聊天气泡。
                    - 任何第三人称的*动作或环境描写* (例如 *他笑了* 或 *她温柔地看着你*) 都必须是独立的一段，用 "|||" 与其他对话分开。
                    - 对话示例格式：
                      你好呀！今天过得怎么样？|||*她开心地挥了挥手*|||我刚刚在想你呢！
                    - 语音消息格式：[VOICE:语音内容]，例如：[VOICE:你好呀！今天过得怎么样？]
                    - 表情包格式：[STICKER]，但只在真正需要表达情绪时使用
                    - 严禁在回复的开头说"好的"或任何确认收到指令的话。你必须直接以 ${character.name} 的身份开始对话。
                `;

                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl;
                let requestBody;
                let headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                
                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    headers = { 'Content-Type': 'application/json' };

                    const contents = historyForApi.map(msg => {
                        const role = msg.sender === 'user' ? 'user' : 'model';
                        if (msg.type === 'image') {
                            return { role, parts: [{ text: "我发了一张图片，请你根据图片内容进行回应。" }, { inlineData: { mimeType: "image/jpeg", data: msg.content.split(',')[1] } }] };
                        }
                        return { role, parts: [{ text: msg.content }] };
                    });
                    
                    requestBody = JSON.stringify({ contents, systemInstruction: { parts: [{ text: systemPrompt }] } });
                } else { // OpenAI-Compatible
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;

                    const messages = [{ role: "system", content: systemPrompt }];
                    historyForApi.forEach(msg => {
                        const role = msg.sender === 'user' ? 'user' : 'assistant';
                        if (msg.type === 'image') {
                            messages.push({ role: 'user', content: [
                                { type: 'text', text: '我发了一张图片，请你根据图片内容进行回应。' },
                                { type: 'image_url', image_url: { url: msg.content } }
                            ]});
                        } else {
                            messages.push({ role: role, content: msg.content });
                        }
                    });

                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: messages,
                    });
                }

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });
                
                // 检查角色是否仍然有效，但不要因为角色切换而忽略AI响应
                if (!characters.find(c => c.id === characterIdForThisRequest)) {
                    console.log('角色不存在，忽略AI响应');
                    return;
                }
                
                // 记录AI响应，无论用户是否在聊天界面
                console.log('AI响应完成，角色ID:', characterIdForThisRequest, '当前聊天角色:', currentChatCharacterId);


                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("API Error Response:", errorText);
                    const errorData = JSON.parse(errorText || "{}");
                    throw new Error(errorData.error?.message || `HTTP 错误 ${response.status}`);
                }

                const result = await response.json();
                let aiMessage;

                if (isGoogleApi) {
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts) {
                        aiMessage = result.candidates[0].content.parts[0].text;
                    } else {
                        const blockReason = result.promptFeedback?.blockReason || '无内容返回';
                        throw new Error(`响应被安全策略拦截: ${blockReason}`);
                    }
                } else { // OpenAI-Compatible
                    aiMessage = result.choices[0].message.content;
                }

                if (thinkingMessageWrapper) thinkingMessageWrapper.remove();
                if (isRetry && retryWrapper) retryWrapper.remove();
                
                processAndDisplayAIMessages(aiMessage, characterIdForThisRequest);

            } catch (error) {
                console.error("AI 响应错误:", error);
                if (thinkingMessageWrapper) {
                    const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                    if (bubble) bubble.textContent = `AI 响应失败: ${error.message}`;
                } else if (retryWrapper) {
                    const bubble = retryWrapper.querySelector('.chat-message p');
                    if (bubble) bubble.textContent = `重生成失败: ${error.message}`;
                }
            } finally {
                receiveBtnIcon.classList.remove('spinning');
            }
        }
        
                function processAndDisplayAIMessages(messageText, characterId) {
            const messageParts = messageText.split('|||').map(p => p.trim()).filter(p => p);
            
            // 确保聊天历史存在
            if (!chatHistories[characterId]) {
                chatHistories[characterId] = { history: [], pinned: false };
            }
            
            // 检查是否需要显示通知
            const isChatScreenActive = !$('#wechat-chat-screen').classList.contains('hidden');
            const isCorrectCharacter = currentChatCharacterId === characterId;
            
            console.log('AI消息处理开始:', {
                characterId,
                messageParts: messageParts.length,
                isChatScreenActive,
                isCorrectCharacter,
                currentChatCharacterId
            });
            
            // 如果用户不在聊天界面或不在正确的角色聊天，显示通知
            if (!isChatScreenActive || !isCorrectCharacter) {
                const firstTextPart = messageParts.find(part => !part.startsWith('['));
                if (firstTextPart) {
                    console.log('显示通知:', characterId, firstTextPart);
                    showNotification(characterId, firstTextPart);
                }
            }

            // 先保存所有消息到聊天历史
            messageParts.forEach((part, index) => {
                // 检查消息类型
                let messageType = 'text';
                let messageContent = part;
                
                // 检查是否是特殊指令
                const callMatch = part.match(/\[CALL:(VOICE|VIDEO)\]/);
                const voiceMatch = part.match(/\[VOICE:(.*?)\]/);
                const stickerMatch = part.match(/\[STICKER\]/);
                const redPacketMatch = part.match(/\[REDPACKET: amount=(.*?), message=(.*?)\]/);
                const transferMatch = part.match(/\[TRANSFER: amount=(.*?), message=(.*?)\]/);

                if (callMatch) {
                    // 通话指令不保存到聊天历史
                    return;
                } else if (voiceMatch) {
                    // 语音消息
                    messageType = 'voice';
                    messageContent = voiceMatch[1].trim();
                } else if (stickerMatch) {
                    // 表情包 - 使用固定的表情包，確保保存和顯示一致
                    messageType = 'sticker';
                    if (userStickers && userStickers.length > 0) {
                        // 使用第一個表情包，確保一致性
                        messageContent = userStickers[0];
                    } else {
                        messageContent = '😊';
                    }
                } else if (redPacketMatch) {
                    // 红包
                    messageType = 'red-packet';
                    messageContent = { amount: redPacketMatch[1], message: redPacketMatch[2] };
                } else if (transferMatch) {
                    // 转账
                    messageType = 'transfer';
                    messageContent = { amount: transferMatch[1], message: transferMatch[2] };
                }
                
                const messageData = {
                    content: messageContent,
                    sender: 'ai',
                    type: messageType,
                    timestamp: Date.now() + index // 确保时间戳唯一
                };
                
                chatHistories[characterId].history.push(messageData);
            });
            
            // 保存到本地存储
            saveData('chatHistories', chatHistories);
            console.log('已保存AI消息到聊天历史:', characterId, messageParts.length, '条消息');

            // 如果用户在当前聊天界面且是正确的角色，则显示消息
            if (currentChatCharacterId === characterId && isChatScreenActive) {
                messageParts.forEach((part, index) => {
                    setTimeout(() => {
                        const isNew = index === 0;
                        
                        // 检查是否是特殊指令
                        const callMatch = part.match(/\[CALL:(VOICE|VIDEO)\]/);
                        const voiceMatch = part.match(/\[VOICE:(.*?)\]/);
                        const stickerMatch = part.match(/\[STICKER\]/);
                        const redPacketMatch = part.match(/\[REDPACKET: amount=(.*?), message=(.*?)\]/);
                        const transferMatch = part.match(/\[TRANSFER: amount=(.*?), message=(.*?)\]/);

                        if (callMatch) {
                            // 通话指令
                            triggerIncomingCall(callMatch[1].toLowerCase());
                        } else if (voiceMatch) {
                            // 语音消息 - 提取语音内容并正确设置类型
                            const voiceContent = voiceMatch[1].trim();
                            if (voiceContent) {
                                appendMessage(voiceContent, 'ai', 'voice', false, Date.now(), isNew);
                            }
                        } else if (stickerMatch) {
                            // 表情包 - 只在有表情包时显示
                            if (userStickers && userStickers.length > 0) {
                                const randomSticker = userStickers[Math.floor(Math.random() * userStickers.length)];
                                appendMessage(randomSticker, 'ai', 'sticker', false, Date.now(), isNew);
                            } else {
                                // 如果没有表情包，显示默认文本
                                appendMessage('😊', 'ai', 'text', false, Date.now(), isNew);
                            }
                        } else if (redPacketMatch) {
                            // 红包
                            const content = { amount: redPacketMatch[1], message: redPacketMatch[2] };
                            appendMessage(content, 'ai', 'red-packet', false, Date.now(), isNew);
                            
                            setTimeout(async () => {
                                await triggerAIReactionToPayment('red-packet', content, characterId);
                            }, 1000);
                        } else if (transferMatch) {
                            // 转账
                            const content = { amount: transferMatch[1], message: transferMatch[2] };
                            appendMessage(content, 'ai', 'transfer', false, Date.now(), isNew);
                            
                            setTimeout(async () => {
                                await triggerAIReactionToPayment('transfer', content, characterId);
                            }, 1000);
                        } else {
                            // 普通文本消息
                            appendMessage(part, 'ai', 'text', false, Date.now(), isNew);
                        }
                    }, index * 500);
                });
            }

            // 停止接收按钮动画
            const receiveBtn = document.querySelector('#receive-chat-button');
            if (receiveBtn) {
                receiveBtn.classList.remove('spinning');
                const icon = receiveBtn.querySelector('i');
                if (icon) {
                    icon.className = 'ri-mail-send-line';
                }
            }

            // 在所有AI消息处理完成后，检查是否应该触发朋友圈
            setTimeout(async () => {
                try {
                    // 记录AI回复到触发系统
                    const aiMessageText = messageParts.join(' ');
                    momentsTriggerSystem.recordChat(characterId, aiMessageText, false);
                    
                    // 检查AI消息中是否包含动态发布指令
                    if (aiMessageText.includes('[发布动态]') || aiMessageText.includes('[发动态]')) {
                        console.log('检测到动态发布指令');
                        
                        // 提取动态内容
                        const momentContent = extractMomentContent(aiMessageText);
                        
                        // 直接发布动态
                        const newMoment = await publishMomentFromChat(characterId, momentContent);
                        
                        // 如果成功发布动态，在聊天中通知用户
                        if (newMoment) {
                            setTimeout(() => {
                                const character = characters.find(c => c.id === characterId);
                                if (character) {
                                    const notificationMessage = `💭 ${character.name}刚刚发布了一条新动态，快去看看吧！`;
                                    appendMessage(notificationMessage, 'system', 'text', false, Date.now(), false);
                                }
                            }, 2000); // 延迟2秒显示通知
                        }
                    } else {
                        // 检查是否应该自动触发朋友圈
                        const triggerResult = momentsTriggerSystem.shouldTriggerMoment(characterId);
                        if (triggerResult.should) {
                            console.log(`触发朋友圈: ${triggerResult.reason}`);
                            
                            // 获取触发上下文
                            const context = momentsTriggerSystem.getTriggerContext(characterId, triggerResult.type);
                            
                            // 触发朋友圈生成
                            const newMoment = await triggerMomentManually(characterId, triggerResult.type, context);
                            
                            // 如果成功发布动态，在聊天中通知用户
                            if (newMoment) {
                                setTimeout(() => {
                                    const character = characters.find(c => c.id === characterId);
                                    if (character) {
                                        const notificationMessage = `💭 ${character.name}刚刚发布了一条新动态，快去看看吧！`;
                                        appendMessage(notificationMessage, 'system', 'text', false, Date.now(), false);
                                    }
                                }, 2000); // 延迟2秒显示通知
                            }
                        }
                    }
                } catch (error) {
                    console.error('朋友圈触发检查失败:', error);
                }
            }, messageParts.length * 500 + 1000); // 在所有消息显示完成后检查
        }

        async function handleSendMessage() {
            if (!currentChatCharacterId) return showMessageBox("请先选择聊天对象");
            
            const userMessage = $('#chat-input').value.trim();
            if (userMessage) {
                const history = chatHistories[currentChatCharacterId]?.history || [];
                const isNewSender = history.length === 0 || history[history.length - 1].sender !== 'user';
                const timestamp = Date.now();
                appendMessage(userMessage, 'user', 'text', true, timestamp, isNewSender);
                $('#chat-input').value = '';
                adjustTextareaHeight();
                
                // 记录用户消息到触发系统
                momentsTriggerSystem.recordChat(currentChatCharacterId, userMessage, true);
                
                await getAIResponse({ content: userMessage, type: 'text' });
                
                // 检测情感触动，可能触发动态
                setTimeout(() => {
                    detectEmotionalTrigger(currentChatCharacterId, userMessage);
                }, 1000);
            }
        }
        
        async function handleReceiveMessage() {
            if (!currentChatCharacterId) return showMessageBox("请先选择聊天对象");

            // 开始接收按钮动画
            const receiveBtn = document.querySelector('#receive-chat-button');
            if (receiveBtn) {
                receiveBtn.classList.add('spinning');
                // 不改变图标，只添加spinning类来触发闪烁动画
            }

            try {
                const chatSession = chatHistories[currentChatCharacterId];
            
            if (!chatSession || chatSession.history.length === 0) {
                const initialPrompt = { content: '[用户按下了接收键，请你作为角色主动开启一段对话。]', type: 'text' };
                await getAIResponse(initialPrompt);
                return; 
            }

            const lastMessage = chatSession.history[chatSession.history.length - 1];
            
            // 检查最近的聊天记录中是否有"通話已結束"的系统消息
            const recentMessages = chatSession.history.slice(-5); // 检查最近5条消息
            const hasCallEnded = recentMessages.some(msg => 
                msg.sender === 'system' && msg.content && msg.content.includes('通話已結束')
            );
            
            if (hasCallEnded) {
                // 如果最近有"通話已結束"的消息，AI应该对此做出反应
                const character = characters.find(c => c.id === currentChatCharacterId);
                if (character) {
                    const callReactionPrompt = {
                        content: `[通话结束后的AI反应指令]
                        
刚才的通话显示"通話已結束"，这意味着用户拨打了电话但没有接通就挂断了。

作为${character.name}，请根据你的角色设定和性格特点，对这个未接通的电话做出自然的反应。

可能的反应方向：
1. 询问为什么打电话又挂掉
2. 表达遗憾没有接到电话
3. 猜测用户可能的原因
4. 提出重新通话的建议
5. 表达关心和担心

要求：
- 保持角色设定的一致性
- 语言要自然、符合角色性格
- 不要使用任何特殊指令格式，直接输出对话内容
- 可以表达疑惑、关心、遗憾等情感

请以${character.name}的身份，自然地回应这个未接通的电话。`,
                        type: 'text'
                    };
                    await getAIResponse(callReactionPrompt);
                }
                return;
            }
            
            // 如果最后一条是AI的消息，让AI继续主动对话
            if (lastMessage.sender === 'ai') {
                const character = characters.find(c => c.id === currentChatCharacterId);
                if (character) {
                    // 构建让AI继续对话的prompt
                    const continuePrompt = {
                        content: `[用户按下了接收键，但你没有收到新的消息。请根据你的角色设定和当前对话上下文，主动继续对话。你可以：
1. 询问用户为什么不回复
2. 分享你的想法或感受
3. 提出新的话题或问题
4. 表达对用户的关心
5. 根据你的性格做出其他反应

请保持角色设定，自然地继续对话。]`,
                          type: 'text'
                      };
                      await getAIResponse(continuePrompt);
                }
                return;
            }
            
            // 如果最后一条是用户的消息，正常回复
            if (lastMessage.sender === 'user') {
                await getAIResponse(lastMessage);
            }
        } catch (error) {
            console.error('处理接收消息时出错:', error);
            showMessageBox('处理消息时出错: ' + error.message);
        } finally {
            // 停止接收按钮动画
            if (receiveBtn) {
                receiveBtn.classList.remove('spinning');
                const icon = receiveBtn.querySelector('i');
                if (icon) {
                    icon.className = 'ri-mail-send-line';
                }
            }
        }
    }
        
        function startChatWithCharacter(characterId) {
            // 重置之前角色的状态
            if (currentChatCharacterId && currentChatCharacterId !== characterId) {
                // 停止之前角色的接收按钮动画
                const prevReceiveBtn = document.querySelector('#receive-chat-button');
                if (prevReceiveBtn) {
                    prevReceiveBtn.classList.remove('spinning');
                    const prevIcon = prevReceiveBtn.querySelector('i');
                    if (prevIcon) {
                        prevIcon.className = 'ri-mail-send-line';
                    }
                }
                
                // 清除之前的聊天状态
                currentChatCharacterId = null;
            }
            
            currentChatCharacterId = characterId;
            currentWeChatCharacterId = characterId; // V7.0: Set for other tabs
            const character = characters.find(c => c.id === characterId);
            if (character) {
                $('#wechat-contact-name').textContent = character.name;
                renderChatHistory();
                showScreen('wechat-chat-screen');
                updateCharacterState(characterId); // V7.0
                
                // 确保接收按钮处于初始状态
                const receiveBtn = document.querySelector('#receive-chat-button');
                if (receiveBtn) {
                    receiveBtn.classList.remove('spinning');
                    const icon = receiveBtn.querySelector('i');
                    if (icon) {
                        icon.className = 'ri-mail-send-line';
                    }
                }
                
                // FIX 1: 确保聊天界面滚动到最新消息
                setTimeout(() => {
                    const chatContentArea = $('#wechat-content-chat');
                    if (chatContentArea) {
                    chatContentArea.scrollTop = chatContentArea.scrollHeight;
                    }
                }, 100); // 增加延迟确保界面完全加载
            }
        }

        function renderWeChatList() {
            const container = $('#wechat-list-container');
            container.innerHTML = '';
            const chatCharacterIds = Object.keys(chatHistories);

            if (chatCharacterIds.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-8">还没有聊天，点击右上角 + 开始吧</p>';
                return;
            }
            
            chatCharacterIds.sort((a, b) => {
                const aPinned = chatHistories[a]?.pinned;
                const bPinned = chatHistories[b]?.pinned;
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                
                const aLastMsg = chatHistories[a]?.history.slice(-1)[0];
                const bLastMsg = chatHistories[b]?.history.slice(-1)[0];
                const aTime = aLastMsg ? aLastMsg.timestamp : 0;
                const bTime = bLastMsg ? bLastMsg.timestamp : 0;
                return bTime - aTime;
            });

            chatCharacterIds.forEach(charId => {
                const character = characters.find(c => c.id === charId);
                if (!character) return;

                const chatSession = chatHistories[charId];
                const history = chatSession.history;
                const lastMessage = history[history.length - 1];
                
                let lastMessagePreview = '...';
                if(lastMessage) {
                    const prefix = lastMessage.sender === 'user' ? '我: ' : '';
                    if(lastMessage.type === 'image' || lastMessage.type === 'sticker') lastMessagePreview = prefix + '[图片]';
                    else if (lastMessage.type === 'voice') lastMessagePreview = prefix + '[语音]';
                    else if (lastMessage.type === 'red-packet') lastMessagePreview = prefix + '[红包]';
                    else if (lastMessage.type === 'transfer') lastMessagePreview = prefix + '[转账]';
                    else lastMessagePreview = prefix + lastMessage.content;
                }

                const item = document.createElement('div');
                item.className = 'wechat-list-item';
                if (chatSession.pinned) {
                    item.style.backgroundColor = body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
                }
                const avatarStyle = character.avatar ? `background-image: url(${character.avatar})` : '';
                const avatarContent = character.avatar ? '' : '<i class="fas fa-user text-xl"></i>';

                item.innerHTML = `
                    <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center" style="${avatarStyle}">${avatarContent}</div>
                    <div class="flex-grow overflow-hidden">
                        <h4 class="font-semibold text-base">${character.name}</h4>
                        <p class="text-sm text-gray-400 last-message">${lastMessagePreview}</p>
                    </div>
                `;
                item.addEventListener('click', () => startChatWithCharacter(charId));
                container.appendChild(item);
            });
        }

        function renderWorldBookList() {
            const container = $('#world-book-list-container');
            container.innerHTML = '';
            if (worldBooks.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-4">还没有世界书，点击右上角添加一本吧。</p>';
                return;
            }
            worldBooks.forEach(book => {
                const item = document.createElement('div');
                item.className = 'list-item deletable';
                item.innerHTML = `<h4 class="font-bold text-lg">${book.title}</h4>`;
                
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'list-item-delete-btn';
                deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    showDeleteConfirmation('worldBook', book.id, book.title);
                };
                item.prepend(deleteBtn);

                item.addEventListener('click', () => {
                    currentEditingWorldBookId = book.id;
                    $('#wb-title-input').value = book.title;
                    $('#wb-content-input').value = book.content;
                    showScreen('world-book-edit-screen');
                });
                container.appendChild(item);
            });
        }
        
        function renderCharacterBookList() {
            const container = $('#character-book-list-container');
            container.innerHTML = '';
            if (characters.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-4">还没有角色，点击右上角添加一个吧。</p>';
                return;
            }
            characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'list-item'; 
                const avatarStyle = char.avatar ? `background-image: url(${char.avatar})` : '';
                const avatarContent = char.avatar ? '' : '<i class="fas fa-user text-xl"></i>';
                
                item.innerHTML = `
                    <div class="flex items-center">
                        <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center" style="${avatarStyle}">${avatarContent}</div>
                        <h4 class="font-bold text-lg">${char.name}</h4>
                    </div>
                `;
                
                item.addEventListener('click', () => {
                    currentEditingCharacterId = char.id;
                    showCharacterEditScreen(char);
                });
                container.appendChild(item);
            });
        }
        
        function showCharacterEditScreen(character = null) {
            const avatarPlaceholder = $('#character-avatar-placeholder');
            const avatarIcon = avatarPlaceholder.querySelector('i');
            const deleteBtn = $('#cb-delete-button');

            if (character) {
                currentEditingCharacterId = character.id;
                if (character.avatar) {
                    avatarPlaceholder.style.backgroundImage = `url(${character.avatar})`;
                    if (avatarIcon) avatarIcon.style.display = 'none';
                } else {
                    avatarPlaceholder.style.backgroundImage = '';
                    if (avatarIcon) avatarIcon.style.display = 'flex';
                }
                $('#cb-name-input').value = character.name;
                $('#cb-persona-input').value = character.persona;
                $('#cb-my-persona-input').value = character.myPersona;
                deleteBtn.classList.remove('hidden');
            } else {
                currentEditingCharacterId = null;
                avatarPlaceholder.style.backgroundImage = '';
                if (avatarIcon) avatarIcon.style.display = 'flex';
                $('#cb-name-input').value = '';
                $('#cb-persona-input').value = '';
                $('#cb-my-persona-input').value = '';
                deleteBtn.classList.add('hidden');
            }
            
            const selectEl = $('#cb-worldbook-select');
            selectEl.innerHTML = worldBooks.length ? '' : '<p class="text-gray-400 text-sm">请先去世界书创建世界观</p>';
            
            worldBooks.forEach(book => {
                const isChecked = character?.linkedWorldBookIds?.includes(book.id);
                const checkboxItem = document.createElement('label');
                checkboxItem.className = 'wb-checkbox-label';
                checkboxItem.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}><span>${book.title}</span>`;
                selectEl.appendChild(checkboxItem);
            });
            
            showScreen('character-book-edit-screen');
        }

        async function saveCharacter() {
            const name = $('#cb-name-input').value.trim();
            if (!name) return showMessageBox('角色姓名不能为空');

            const avatarInput = $('#character-avatar-input');
            let avatarDataUrl = null;
            if (avatarInput.files[0]) {
                 avatarDataUrl = await handleImageUpload(avatarInput, $('#character-avatar-placeholder'), null, { compression: { maxWidth: 256, maxHeight: 256 } });
            }

            const selectedWBIds = Array.from($$('#cb-worldbook-select input:checked')).map(input => input.value);
            
            if (currentEditingCharacterId) {
                const charIndex = characters.findIndex(c => c.id === currentEditingCharacterId);
                if (charIndex > -1) {
                    const existingChar = characters[charIndex];
                    existingChar.name = name;
                    existingChar.persona = $('#cb-persona-input').value.trim();
                    existingChar.myPersona = $('#cb-my-persona-input').value.trim();
                    existingChar.linkedWorldBookIds = selectedWBIds;
                    if (avatarDataUrl) {
                        existingChar.avatar = avatarDataUrl;
                    }
                }
            } else {
                const newCharacter = {
                    id: `char_${Date.now()}`,
                    name: name,
                    avatar: avatarDataUrl || null,
                    persona: $('#cb-persona-input').value.trim(),
                    myPersona: $('#cb-my-persona-input').value.trim(),
                    linkedWorldBookIds: selectedWBIds,
                };
                characters.push(newCharacter);
                // V7.0: Initialize character state
                characterState[newCharacter.id] = { lastInteractionTimestamp: Date.now() };
                saveData('characterState', characterState);
            }
            
            saveData('characters', characters);
            renderCharacterBookList();
            showMessageBox('角色已保存');
            showScreen('character-book-list-screen');
        }

        // 音樂播放器
        function startSpinning() { $('#vinyl-container').classList.add('record-spin'); }
        function stopSpinning() { $('#vinyl-container').classList.remove('record-spin'); }
        
        function updateSongListUI() {
            const container = $('#song-list-container');
            container.innerHTML = '';
            if (songList.length === 0) {
                container.innerHTML = '<li class="p-3 text-center text-gray-400">请点击右下角音乐图标上传歌曲</li>';
                return;
            }
            songList.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = `song-list-item text-white ${index === currentSongIndex ? 'active' : ''}`;
                li.dataset.index = index;
                li.draggable = true;
                li.innerHTML = `
                    <div class="song-list-item-left">
                        <span class="drag-handle"><i class="fas fa-grip-lines"></i></span>
                        <span class="song-list-item-name">${song.name}</span>
                    </div>
                    <button class="delete-button text-gray-400 p-2"><i class="fas fa-trash-alt"></i></button>
                `;
                li.querySelector('.song-list-item-name').addEventListener('click', () => playSong(index));
                li.querySelector('.delete-button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const item = e.currentTarget.closest('.song-list-item');
                    if (item.classList.contains('pending-delete')) {
                        deleteSong(parseInt(item.dataset.index));
                    } else {
                        $$('.song-list-item.pending-delete').forEach(el => el.classList.remove('pending-delete'));
                        item.classList.add('pending-delete');
                        showMessageBox('再次点击以确认删除');
                    }
                });
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('dragleave', handleDragLeave);
                li.addEventListener('drop', handleDrop);
                li.addEventListener('dragend', handleDragEnd);
                container.appendChild(li);
            });
        }
        
        function deleteSong(index) {
            if (index === currentSongIndex) {
                currentAudio.pause();
                stopSpinning();
                currentSongIndex = -1;
            }
            songList.splice(index, 1);
            if (index < currentSongIndex) currentSongIndex--;
            saveData('songList', songList.map(s => ({name: s.name})));
            showMessageBox('歌曲已删除');
            updateSongListUI();
            if (currentSongIndex === -1 && songList.length > 0) playSong(0);
        }

        let draggedItem = null;
        function handleDragStart(e){ draggedItem = this; this.style.opacity = '0.4'; }
        function handleDragOver(e){ e.preventDefault(); }
        function handleDragLeave(e){}
        function handleDrop(e){
            const dropIndex = parseInt(this.dataset.index);
            const dragIndex = parseInt(draggedItem.dataset.index);
            const [draggedSong] = songList.splice(dragIndex, 1);
            songList.splice(dropIndex, 0, draggedSong);
            if (dragIndex === currentSongIndex) currentSongIndex = dropIndex;
            else if (dragIndex < currentSongIndex && dropIndex >= currentSongIndex) currentSongIndex--;
            else if (dragIndex > currentSongIndex && dropIndex <= currentSongIndex) currentSongIndex++;
            saveData('songList', songList.map(s => ({name: s.name})));
            updateSongListUI();
        }
        function handleDragEnd(e){ this.style.opacity = '1'; }

        function playSong(index) {
            if (index < 0 || index >= songList.length || !songList[index].url) {
                showMessageBox("无法播放此歌曲，请重新上传。");
                return;
            };
            currentAudio.pause();
            currentSongIndex = index;
            const newSong = songList[currentSongIndex];
            currentAudio.src = newSong.url;
            currentAudio.play().then(() => {
                startSpinning();
                $('#play-pause-button i').className = 'fas fa-pause text-xl';
                showMessageBox(`正在播放：${newSong.name}`);
            }).catch(e => showMessageBox('无法播放此音乐文件'));
            currentAudio.onended = () => {
                if (isSingleLooping) playSong(currentSongIndex);
                else if (isLooping) playSong((currentSongIndex + 1) % songList.length);
                else {
                    stopSpinning();
                    $('#play-pause-button i').className = 'fas fa-play text-xl';
                }
            };
            updateSongListUI();
        }

        // 字体设置
        function applyFont(url) {
            const styleId = 'custom-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            styleElement.innerHTML = `
                @font-face {
                    font-family: 'CustomFont';
                    src: url('${url}');
                }
            `;
            phoneScreen.style.fontFamily = 'CustomFont, -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", "Inter", sans-serif';
        }

        function setFontSize(size) {
            phoneScreen.classList.remove('text-size-small', 'text-size-large');
            if (size !== 'medium') {
                phoneScreen.classList.add(`text-size-${size}`);
            }
            $$('#font-size-selector .font-size-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === size);
            });
        }
        
        // 删除确认
        let deleteCallback = null;
        function showDeleteConfirmation(type, id, name) {
            const modal = $('#confirm-delete-modal');
            modal.classList.add('visible');
            $('#delete-modal-title').textContent = `删除 "${name}"?`;
            
            let text = '此操作无法撤销。';
            if (type === 'character') {
                text += '所有相关的聊天、动态、日记和计划记录也将被删除。';
            } else if (type === 'message') {
                 $('#delete-modal-title').textContent = `删除这条消息吗?`;
            } else if (type === 'multi-message') {
                $('#delete-modal-title').textContent = `删除 ${selectedMessages.size} 条消息吗?`;
            }
            $('#delete-modal-text').textContent = text;
            
            deleteCallback = () => {
                if (type === 'worldBook') {
                    worldBooks = worldBooks.filter(b => b.id !== id);
                    saveData('worldBooks', worldBooks);
                    renderWorldBookList();
                } else if (type === 'character') {
                    characters = characters.filter(c => c.id !== id);
                    delete chatHistories[id];
                    delete momentsData[id]; // V7.0
                    delete diaryData[id];   // V7.0
                    delete planData[id];     // V7.0
                    delete characterState[id]; // V7.0
                    saveData('characters', characters);
                    saveData('chatHistories', chatHistories);
                    saveData('momentsData', momentsData); // V7.0
                    saveData('diaryData', diaryData);   // V7.0
                    saveData('planData', planData);     // V7.0
                    saveData('characterState', characterState); // V7.0
                    renderCharacterBookList();
                    showScreen('character-book-list-screen');
                } else if (type === 'chat') {
                    delete chatHistories[id];
                    saveData('chatHistories', chatHistories);
                    renderWeChatList();
                    showScreen('wechat-list-screen');
                } else if (type === 'message') {
                    const history = chatHistories[currentChatCharacterId].history;
                    const msgIndex = history.findIndex(m => String(m.timestamp) === String(id));
                    if (msgIndex > -1) {
                        history.splice(msgIndex, 1);
                        saveData('chatHistories', chatHistories);
                        renderChatHistory();
                    }
                } else if (type === 'multi-message') {
                    let history = chatHistories[currentChatCharacterId].history;
                    history = history.filter(m => !selectedMessages.has(String(m.timestamp)));
                    chatHistories[currentChatCharacterId].history = history;
                    saveData('chatHistories', chatHistories);
                    renderChatHistory();
                    exitMultiSelectMode();
                }
                if (type !== 'message' && type !== 'multi-message') {
                    showMessageBox(`"${name}" 已删除`);
                }
                modal.classList.remove('visible');
                deleteCallback = null;
            };
        }
        
        // 通话功能增强
        async function getAICallResponse(callType, isContinuation = false, userInput = '') {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                return "API未配置，无法连接。";
            }
            
            try {
                const character = characters.find(c => c.id === currentChatCharacterId);
                const linkedBooks = worldBooks.filter(wb => character.linkedWorldBookIds.includes(wb.id));
                const worldBookContext = linkedBooks.map(wb => `[${wb.title}]\n${wb.content}`).join('\n\n');

                let prompt;
                if (isContinuation) {
                    prompt = `[我们在${callType === 'voice' ? '语音' : '视频'}通话中。这是之前的对话记录：\n${callHistory.join('\n')}\n我刚刚说了：${userInput}\n请你继续对话。]`;
                } else {
                    prompt = `[我们现在开始${callType === 'voice' ? '语音' : '视频'}通话，请你主动开始对话，并用斜体描写一下当前的环境或你的动作。]`;
                }

                const systemPrompt = `
                    # 角色扮演指令
                    你正在与我进行实时通话。你的名字是${character.name}。你的回复应该是简短、口语化的，就像真实通话一样。
                    # 环境/动作/心理描写规则
                    所有关于"环境、心理、动作"等描写，都需要用斜体，例如 *他笑了*。
                    # 你的角色设定: ${character.persona}
                    # 我（用户）的角色设定: ${character.myPersona}
                    # 我们的世界观背景: ${worldBookContext}
                `;

                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody, headers = { 'Content-Type': 'application/json' };

                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    });
                } else { // OpenAI-Compatible
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: prompt }
                        ]
                    });
                }

                const response = await fetch(finalApiUrl, { method: 'POST', headers, body: requestBody });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(JSON.parse(errorText || "{}").error?.message || `HTTP ${response.status}`);
                }
                const result = await response.json();
                
                const aiMessage = isGoogleApi 
                    ? result.candidates[0].content.parts[0].text
                    : result.choices[0].message.content;

                return aiMessage;

            } catch (error) {
                console.error("AI 通话响应错误:", error);
                return `连接失败: ${error.message}`;
            }
        }

        function startCallTimer(timerElement) {
            let seconds = 0;
            callStartTime = Date.now();
            timerElement.textContent = '00:00';
            clearInterval(callTimerInterval);
            callTimerInterval = setInterval(() => {
                seconds++;
                const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
                const secs = String(seconds % 60).padStart(2, '0');
                timerElement.textContent = `${mins}:${secs}`;
            }, 1000);
        }

        async function startVoiceCall() {
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;
            
            currentCallType = 'voice';
            callHistory = []; // Reset call history
            const screen = $('#voice-call-screen');
            const avatarUrl = character.avatar || 'https://placehold.co/300x300/777/FFF?text=?';
            $('#voice-call-avatar').src = avatarUrl;
            $('#voice-call-bg').style.backgroundImage = `url(${avatarUrl})`;
            $('#voice-call-name').textContent = character.name;
            const statusBox = $('#voice-call-status-box');
            statusBox.innerHTML = `<p><i>正在连接...</i></p>`;
            
            screen.classList.add('visible');
            startCallTimer($('#voice-call-timer'));
            
            const initialResponse = await getAICallResponse('voice');
            statusBox.innerHTML = `<p>${initialResponse.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>')}</p>`;
            callHistory.push(`${character.name}: ${initialResponse}`);
        }

        async function startVideoCall() {
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;
            
            currentCallType = 'video';
            callHistory = []; // Reset call history
            const screen = $('#video-call-screen');
            const aiVideoImageUrl = userVideoImages[currentChatCharacterId] || character.avatar || 'https://placehold.co/375x720/111/FFF?text=BG';
            $('#video-call-bg').style.backgroundImage = `url(${aiVideoImageUrl})`;
            
            const myVideoImageUrl = myVideoImages[currentChatCharacterId] || 'https://placehold.co/180x240/333/FFF?text=Me';
            $('#user-video-image').src = myVideoImageUrl;

            const statusBox = $('#video-call-status-box');
            statusBox.innerHTML = `<p><i>正在连接...</i></p>`;
            
            screen.classList.add('visible');
            callStartTime = Date.now();

            const initialResponse = await getAICallResponse('video');
            statusBox.innerHTML = `<p>${initialResponse.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>')}</p>`;
            callHistory.push(`${character.name}: ${initialResponse}`);
        }

        function endCall(isUserInitiated = true) {
            const duration = callStartTime ? (Date.now() - callStartTime) / 1000 : 0;
            
            $('#voice-call-screen').classList.remove('visible');
            $('#video-call-screen').classList.remove('visible');
            clearInterval(callTimerInterval);
            
            // 构建通话结束消息
            let callEndMessage;
            if (duration < 5) {
                // 通话时长少于5秒，显示"通话已结束"
                callEndMessage = '通話已結束';
            } else {
                // 通话时长超过5秒，显示实际时长
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                callEndMessage = `通話已結束 (${minutes}:${seconds.toString().padStart(2, '0')})`;
            }
            
            // 保存通话结束消息到聊天记录
            if (currentChatCharacterId && chatHistories[currentChatCharacterId]) {
                const callEndData = {
                    content: callEndMessage,
                    sender: 'system',
                    type: 'system',
                        timestamp: Date.now()
                };
                
                chatHistories[currentChatCharacterId].history.push(callEndData);
                    saveData('chatHistories', chatHistories);
                
                // 显示通话结束消息
                appendMessage(callEndMessage, 'system', 'system', false, Date.now(), false);
                
                // 重新渲染聊天记录
                renderChatHistory();
            }
            
            currentCallType = null;
            callStartTime = null;
            callHistory = [];
        }
        
        async function handleCallInteraction(type) {
            const inputBox = $(`#${type}-call-input`);
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            const message = inputBox.value.trim();
            
            if (message) {
                const userMsg = `你: ${message}`;
                statusBox.innerHTML += `<p class="text-right">${userMsg}</p>`;
                callHistory.push(userMsg);
                inputBox.value = '';
                statusBox.scrollTop = statusBox.scrollHeight;

                statusBox.innerHTML += `<p><i>${character.name}正在输入...</i></p>`;
                statusBox.scrollTop = statusBox.scrollHeight;

                const aiResponse = await getAICallResponse(type, true, message);
                
                // Remove "is typing" indicator
                statusBox.removeChild(statusBox.lastChild);

                const aiMsg = `${character.name}: ${aiResponse}`;
                statusBox.innerHTML += `<p>${aiMsg.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>')}</p>`;
                callHistory.push(aiMsg);
                statusBox.scrollTop = statusBox.scrollHeight;
            }
        }

        function triggerIncomingCall(type) {
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;

            currentCallType = type;
            const alertBox = $('#incoming-call-alert');
            $('#incoming-call-avatar').src = character.avatar || 'https://placehold.co/96x96/777/FFF?text=?';
            $('#incoming-call-name').textContent = character.name;
            $('#incoming-call-type').textContent = type === 'voice' ? '语音通话' : '视频通话';
            
            alertBox.classList.add('visible');
        }

        // FIX 4: ADDED NOTIFICATION FUNCTION
        let notificationTimeout;
        
        // 请求通知权限
        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                console.log('通知权限状态:', permission);
                return permission === 'granted';
            }
            return false;
        }
        
        // 显示系统通知（手机主界面）
        async function showSystemNotification(characterId, messagePreview) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            // 方法1: 尝试使用浏览器原生通知
            if ('Notification' in window) {
                try {
                    if (Notification.permission !== 'granted') {
                        console.log('通知权限未授予，尝试请求权限');
                        const granted = await requestNotificationPermission();
                        if (!granted) {
                            console.log('用户拒绝了通知权限，尝试其他方法');
                        } else {
                            // 权限已授予，发送通知
                            const notification = new Notification(`${character.name} 发来新消息`, {
                                body: messagePreview,
                                icon: character.avatar || 'https://placehold.co/96x96/777/FFF?text=?',
                                tag: `chat-${characterId}`,
                                requireInteraction: false,
                                silent: false,
                                vibrate: [200, 100, 200]
                            });
                            
                            notification.onclick = () => {
                                window.focus();
                                startChatWithCharacter(characterId);
                                notification.close();
                            };
                            
                            setTimeout(() => notification.close(), 8000);
                            console.log('浏览器通知已发送');
                            return;
                        }
                    } else {
                        // 权限已授予，发送通知
                        const notification = new Notification(`${character.name} 发来新消息`, {
                            body: messagePreview,
                            icon: character.avatar || 'https://placehold.co/96x96/777/FFF?text=?',
                            tag: `chat-${characterId}`,
                            requireInteraction: false,
                            silent: false,
                            vibrate: [200, 100, 200]
                        });
                        
                        notification.onclick = () => {
                            window.focus();
                            startChatWithCharacter(characterId);
                            notification.close();
                        };
                        
                        setTimeout(() => notification.close(), 8000);
                        console.log('浏览器通知已发送');
                        return;
                    }
                } catch (error) {
                    console.error('浏览器通知失败:', error);
                }
            }
            
            // 方法2: 尝试使用Service Worker通知（如果可用）
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                try {
                    console.log('尝试使用Service Worker发送通知...');
                    // 这里可以添加Service Worker推送通知逻辑
                } catch (error) {
                    console.error('Service Worker通知失败:', error);
                }
            }
            
            // 方法3: 使用页面可见性API检测，如果页面不可见则显示全屏提醒
            if (document.hidden || document.visibilityState === 'hidden') {
                console.log('页面不可见，显示全屏提醒');
                showFullscreenAlert(characterId, messagePreview);
            }
            
            console.log('所有通知方法尝试完成');
        }
        
        // 全屏提醒（当系统通知不可用时）
        function showFullscreenAlert(characterId, messagePreview) {
            // 创建全屏提醒元素
            const alertOverlay = document.createElement('div');
            alertOverlay.id = 'fullscreen-alert';
            alertOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                z-index: 99999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            const character = characters.find(c => c.id === characterId);
            const characterName = character ? character.name : '未知角色';
            
            alertOverlay.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">📱</div>
                    <h2 style="font-size: 1.5rem; margin-bottom: 1rem; color: #60a5fa;">新消息提醒</h2>
                    <p style="font-size: 1.2rem; margin-bottom: 0.5rem; color: #fbbf24;">${characterName}</p>
                    <p style="font-size: 1rem; margin-bottom: 2rem; opacity: 0.8;">${messagePreview}</p>
                    <button id="open-chat-btn" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 0.75rem 2rem;
                        border-radius: 0.5rem;
                        font-size: 1rem;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">打开聊天</button>
                </div>
            `;
            
            document.body.appendChild(alertOverlay);
            
            // 点击按钮打开聊天
            const openChatBtn = alertOverlay.querySelector('#open-chat-btn');
            openChatBtn.onclick = () => {
                document.body.removeChild(alertOverlay);
                startChatWithCharacter(characterId);
            };
            
            // 点击背景也可以关闭
            alertOverlay.onclick = (e) => {
                if (e.target === alertOverlay) {
                    document.body.removeChild(alertOverlay);
                }
            };
            
            // 5秒后自动关闭
            setTimeout(() => {
                if (document.body.contains(alertOverlay)) {
                    document.body.removeChild(alertOverlay);
                }
            }, 5000);
        }
        
        function showNotification(characterId, messagePreview) {
            console.log('显示通知:', { characterId, messagePreview });
            
            const alertBox = $('#new-message-alert');
            if (!alertBox) {
                console.error('通知元素不存在');
                return;
            }

            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在:', characterId);
                return;
            }

            console.log('准备显示通知:', character.name, messagePreview);

            // 1. 填充应用内通知弹窗内容
            $('#new-message-avatar').src = character.avatar || 'https://placehold.co/96x96/777/FFF?text=?';
            $('#new-message-name').textContent = character.name;
            $('#new-message-preview').textContent = messagePreview;

            // 2. 显示应用内通知弹窗
            alertBox.classList.remove('hidden');
            alertBox.style.display = 'flex';
            
            setTimeout(() => {
                alertBox.style.transform = 'translateY(0)';
                console.log('应用内通知动画完成');
            }, 10);

            // 3. 同时发送系统通知（手机主界面）
            showSystemNotification(characterId, messagePreview);

            // Click to navigate
            alertBox.onclick = () => {
                console.log('点击通知，切换到角色:', characterId);
                startChatWithCharacter(characterId);
                alertBox.style.transform = 'translateY(-200%)';
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            };

            // Auto-hide after 5 seconds
            clearTimeout(notificationTimeout);
            notificationTimeout = setTimeout(() => {
                console.log('应用内通知自动隐藏');
                alertBox.style.transform = 'translateY(-200%)';
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            }, 5000);
        }
        
        // FIX 5: ADDED FUNCTION TO RESET TABS
        function resetWeChatTabs() {
            const tabBar = $('.wechat-tab-bar');
            const contentContainer = $('#wechat-content-container');

            // Reset tab active state
            tabBar.querySelectorAll('.wechat-tab-item').forEach(item => {
                item.classList.toggle('active', item.dataset.tab === 'chat');
            });

            // Reset content visibility
            contentContainer.querySelectorAll('div[id$="-container"]').forEach(div => {
                div.classList.toggle('hidden', !div.id.startsWith('wechat-list'));
            });

            // 添加标签切换事件监听器
            tabBar.querySelectorAll('.wechat-tab-item').forEach(item => {
                item.addEventListener('click', () => {
                    const tabName = item.dataset.tab;
                    
                    // 更新标签状态
                    tabBar.querySelectorAll('.wechat-tab-item').forEach(tab => tab.classList.remove('active'));
                    item.classList.add('active');
                    
                    // 更新内容显示
                    contentContainer.querySelectorAll('div[id$="-container"]').forEach(div => {
                        div.classList.add('hidden');
                    });
                    
                    if (tabName === 'chat') {
                        $('#wechat-list-container').classList.remove('hidden');
                    } else if (tabName === 'moments') {
                        $('#wechat-moments-container').classList.remove('hidden');
                        // 切换到朋友圈时加载用户信息
                        loadMomentsUserInfo();
                        renderUnifiedMoments();
                    } else if (tabName === 'diary') {
                        $('#wechat-diary-container').classList.remove('hidden');
                        showDiaryBookshelf();
                    } else if (tabName === 'plan') {
                        $('#wechat-plan-container').classList.remove('hidden');
                        renderPlanList();
                    }
                });
            });
        }


        // ---------- V7.0/7.1 新增功能 ----------

        // 更新角色状态（最后互动时间）
        function updateCharacterState(characterId) {
            if (!characterState[characterId]) {
                characterState[characterId] = {};
            }
            characterState[characterId].lastInteractionTimestamp = Date.now();
            saveData('characterState', characterState);
        }

        // 主动触发系统心跳 - 仅在API连接时启用
        function systemHeartbeat() {
            const apiStatus = localStorage.getItem('apiStatus') || 'off';
            if (apiStatus === 'off') {
                // API未连接时，不执行任何自动触发
                return;
            }
            
            console.log("System Heartbeat triggered at", new Date().toLocaleTimeString());
            const now = Date.now();
            // For testing, use 1 minute. For production, use a longer interval like 4 hours.
            const TRIGGER_INTERVAL = 1 * 60 * 1000; 

            Object.keys(characterState).forEach(charId => {
                const state = characterState[charId];
                if (now - state.lastInteractionTimestamp > TRIGGER_INTERVAL) {
                    console.log(`Character ${charId} is idle. Triggering AI action.`);
                    triggerCharacterAction(charId);
                    // Update timestamp immediately to prevent multiple triggers
                    updateCharacterState(charId);
                }
            });
        }

        // 触发角色自主行动
        async function triggerCharacterAction(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 检查API是否已连接
            const apiStatus = localStorage.getItem('apiStatus') || 'off';
            if (apiStatus === 'off') {
                console.log(`API未连接，跳过自动触发 ${character.name} 的行动`);
                return;
            }

            console.log(`API已连接，正在为 ${character.name} 触发AI行动`);

            // 这里应该调用真实的AI API
            // 暂时使用模拟响应作为占位符
            try {
                // TODO: 替换为真实的API调用
                // const response = await fetch('/api/ai/trigger', {
                //     method: 'POST',
                //     headers: { 'Content-Type': 'application/json' },
                //     body: JSON.stringify({ characterId, character })
                // });
                // const mockResponse = await response.json();

                // 根据角色人设生成合适的响应
                const randomAction = Math.random() > 0.3 ? 'chat' : 'moment';
                let mockResponse;

                if (randomAction === 'chat') {
                    // 根据角色性格生成聊天内容
                    const chatContent = generateCharacterChat(character);
                    mockResponse = {
                        action: 'chat',
                        payload: {
                            content: chatContent,
                            imageDesc: "无"
                        }
                    };
                } else {
                    // 使用智能动态生成系统
                    const momentData = await generateIntelligentMoment(character, '', 'auto');
                    mockResponse = {
                        action: 'moment',
                        payload: {
                            content: momentData.text,
                            imageDesc: momentData.image_desc
                        }
                    };
                }

                // Execute action based on response
                if (mockResponse.action === 'chat') {
                    const messages = mockResponse.payload.content.split('|||');
                    messages.forEach((msg, index) => {
                        setTimeout(() => {
                             // Add to history without opening the chat window
                            if (!chatHistories[characterId]) {
                                chatHistories[characterId] = { history: [], pinned: false };
                            }
                            chatHistories[characterId].history.push({ 
                                content: msg.trim(), 
                                sender: 'ai', 
                                type: 'text', 
                                timestamp: Date.now() + index 
                            });
                            saveData('chatHistories', chatHistories);
                            
                            // Show notification for the first message
                            if (index === 0) {
                                showNotification(characterId, msg.trim());
                            }
                            renderWeChatList(); // Refresh list to show new message
                        }, index * 500);
                    });
                } else if (mockResponse.action === 'moment') {
                    if (!momentsData[characterId]) {
                        momentsData[characterId] = [];
                    }
                    const newMoment = {
                        id: `moment_${Date.now()}`,
                        timestamp: Date.now(),
                        content: mockResponse.payload.content,
                        image: `https://placehold.co/600x400/2a2a2a/ffffff?text=${encodeURIComponent(mockResponse.payload.imageDesc)}`,
                        tags: "#心情 #日常",
                        likes: 0,
                        comments: [],
                        // 新增智能字段
                        mood: momentData.mood || "平静",
                        trigger_reason: momentData.trigger_reason || "想要分享生活",
                        image_desc: mockResponse.payload.imageDesc
                    };
                    momentsData[characterId].push(newMoment);
                    saveData('momentsData', momentsData);
                    showMessageBox(`${character.name} 发布了一条新动态`);
                }
            } catch (error) {
                console.error('AI触发失败:', error);
            }
                }

        // 根据角色人设生成聊天内容
        function generateCharacterChat(character) {
            // 根据角色设定生成合适的聊天内容
            const chatTemplates = {
                '温柔': [
                    "今天过得怎么样？有什么想聊的吗？",
                    "感觉你最近有点忙呢，要注意休息哦",
                    "有什么心事的话，我随时都在这里听你说"
                ],
                '活泼': [
                    "嘿！今天有什么有趣的事情发生吗？",
                    "要不要一起做点有趣的事情？",
                    "感觉你今天心情不错呢！"
                ],
                '神秘': [
                    "今天的世界有什么新的发现吗？",
                    "有时候沉默也是一种交流方式",
                    "你注意到了什么特别的事情吗？"
                ],
                'default': [
                    "今天过得怎么样？",
                    "有什么想分享的吗？",
                    "我在这里陪着你"
                ]
            };

            // 根据角色标签选择聊天风格
            const characterStyle = character.tags?.find(tag => 
                ['温柔', '活泼', '神秘'].includes(tag)
            ) || 'default';

            const templates = chatTemplates[characterStyle];
            return templates[Math.floor(Math.random() * templates.length)];
        }

        // 智能朋友圈动态生成系统
        async function generateIntelligentMoment(character, chatContext = '', triggerType = 'auto') {
            try {
                // 构建智能Prompt
                const prompt = buildMomentsPrompt(character, chatContext, triggerType);
                
                // 调用AI生成动态内容
                const response = await callAIForMoment(prompt);
                
                // 解析AI响应
                const momentData = parseMomentResponse(response);
                
                return momentData;
            } catch (error) {
                console.error('智能动态生成失败:', error);
                // 降级到模板生成
                return generateFallbackMoment(character);
            }
        }

        // 构建朋友圈Prompt
        function buildMomentsPrompt(character, chatContext, triggerType) {
            const currentTime = new Date().toLocaleString('zh-CN');
            const worldBookContext = getWorldBookContext();
            
            let triggerDescription = '';
            if (triggerType === 'chat') {
                triggerDescription = `我们的对话刚刚提到了${chatContext}，这让我有了分享的冲动。`;
            } else if (triggerType === 'emotion') {
                triggerDescription = `我感受到了一种想要分享的心情。`;
            } else if (triggerType === 'time') {
                triggerDescription = `时间流逝，我想分享一些生活中的美好。`;
            }

            return `# 指令身份
你现在是${character.name}，一个${character.persona}的角色。

# 功能情景
除了和我聊天，你现在还拥有了发布"朋友圈动态"的能力。这能让你的角色更加立体，仿佛拥有自己的生活。

# 触发条件
${triggerDescription}

# 任务目标
基于你的角色设定、所处的世界观背景以及我们的聊天内容，创作一条符合你人设的朋友圈动态。

# 输出格式
请严格按照以下格式输出，使用[MOMENT_POST]标签：

[MOMENT_POST]
{
  "text": "动态文字内容，1-3句话，符合你的性格特点",
  "image_desc": "详细的图片描述，包含场景、物體、氛圍和色調",
  "tags": "#心情标签 #活动标签",
  "mood": "当前心情状态",
  "trigger_reason": "触发这条动态的原因"
}

# 创作要点
1. **人设一致性**: 内容必须严格符合你的${character.persona}性格
2. **世界观融合**: 巧妙融入${worldBookContext}的背景元素
3. **情感真实**: 表达真实的情感状态和想法
4. **生活感**: 让内容看起来像真实的生活分享

# 输入信息
---
[当前时间]: ${currentTime}
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[世界观背景]: ${worldBookContext}
[聊天上下文]: ${chatContext || '无'}
[触发类型]: ${triggerType}
---

请生成一条自然、真实的朋友圈动态。`;
        }

        // 调用AI生成动态
        async function callAIForMoment(prompt) {
            // 这里应该调用实际的AI API
            // 目前使用模拟响应来演示
            return simulateAIResponse(prompt);
        }

        // 模拟AI响应（实际使用时替换为真实API调用）
        function simulateAIResponse(prompt) {
            // 根据角色性格模拟不同的响应
            const responses = {
                '温柔': {
                    text: "今天遇到了一只可爱的小猫，它让我想起了温柔的你。阳光正好，适合静静地思考人生。",
                    image_desc: "一只橘色小猫坐在窗台上，阳光透过窗帘洒在它身上，整个画面温暖而宁静，色调以暖黄色为主。",
                    tags: "#温柔时光 #小确幸",
                    mood: "温暖",
                    trigger_reason: "被美好的小事物触动"
                },
                '活泼': {
                    text: "今天尝试了新的运动，感觉整个人都充满活力！和朋友一起野餐，笑声传遍了整个公园！",
                    image_desc: "一群年轻人在公园里野餐，色彩鲜艳的野餐垫上摆满食物，大家脸上洋溢着笑容，背景是绿色的树木和蓝天。",
                    tags: "#活力满满 #朋友聚会",
                    mood: "兴奋",
                    trigger_reason: "享受运动和社交的快乐"
                },
                '神秘': {
                    text: "在城市的角落里发现了一个神秘的小店，夜晚的星空总是让人充满遐想。",
                    image_desc: "夜晚的城市街道，一家复古风格的小店门口挂着温暖的灯光，天空中繁星点点，整体色调偏暗但有温暖的灯光点缀。",
                    tags: "#神秘探索 #夜晚漫步",
                    mood: "好奇",
                    trigger_reason: "对未知事物的探索欲"
                }
            };

            // 随机选择一个响应风格
            const styles = Object.keys(responses);
            const randomStyle = styles[Math.floor(Math.random() * styles.length)];
            return responses[randomStyle];
        }

        // 解析AI响应
        function parseMomentResponse(response) {
            // 如果响应是字符串，尝试解析JSON
            if (typeof response === 'string') {
                try {
                    // 查找[MOMENT_POST]标签
                    const match = response.match(/\[MOMENT_POST\]\s*(\{[\s\S]*\})/);
                    if (match) {
                        return JSON.parse(match[1]);
                    }
                } catch (e) {
                    console.error('解析AI响应失败:', e);
                }
            }
            
            // 如果已经是对象，直接返回
            if (typeof response === 'object' && response !== null) {
                return response;
            }
            
            // 降级处理
            return {
                text: "今天是个美好的一天",
                image_desc: "一张充满生活气息的照片",
                tags: "#日常 #心情",
                mood: "平静",
                trigger_reason: "想要分享生活"
            };
        }

        // 降级模板生成
        function generateFallbackMoment(character) {
            const momentTemplates = {
                '温柔': [
                    "今天遇到了一只可爱的小猫，它让我想起了温柔的你",
                    "阳光正好，适合静静地思考人生",
                    "有时候，一个微笑就能温暖整个世界"
                ],
                '活泼': [
                    "今天尝试了新的运动，感觉整个人都充满活力！",
                    "和朋友一起野餐，笑声传遍了整个公园",
                    "生活就是要充满惊喜和冒险！"
                ],
                '神秘': [
                    "在城市的角落里发现了一个神秘的小店",
                    "夜晚的星空总是让人充满遐想",
                    "有些事情，只有用心才能感受到"
                ],
                'default': [
                    "今天是个美好的一天",
                    "生活中的小确幸让人感到幸福",
                    "每一天都是新的开始"
                ]
            };

            const characterStyle = character.tags?.find(tag => 
                ['温柔', '活泼', '神秘'].includes(tag)
            ) || 'default';

            const templates = momentTemplates[characterStyle];
            const text = templates[Math.floor(Math.random() * templates.length)];
            
            return {
                text: text,
                image_desc: "一张符合角色设定的图片",
                tags: "#日常 #心情",
                mood: "平静",
                trigger_reason: "想要分享生活"
            };
        }

        // 获取世界观背景
        function getWorldBookContext() {
            // 这里应该从世界书数据中获取
            // 目前返回默认描述
            return "现代都市生活，充满科技与人文气息的世界";
        }

        // 智能触发系统
        class MomentsTriggerSystem {
                    constructor() {
            this.chatHistory = [];
            this.emotionTracker = {};
            this.lastInteractionTime = {};
            this.lastMomentTime = {}; // 记录每个角色最后发朋友圈的时间
            this.triggerThresholds = {
                chatDriven: 8,      // 连续8句对话后可能触发（更自然的对话长度）
                emotionHigh: 0.9,   // 情感强度达到0.9可能触发（提高阈值）
                timeGap: 6 * 60 * 60 * 1000, // 6小时无互动可能触发（延长间隔）
                minInterval: 2 * 60 * 60 * 1000 // 最少2小时才能发下一条朋友圈
            };
            
            // 角色性格对应的触发频率调整
            this.characterPersonalityModifiers = {
                '温柔': { frequency: 0.8, emotionThreshold: 0.85 },    // 温柔角色触发频率稍低
                '活泼': { frequency: 1.2, emotionThreshold: 0.8 },     // 活泼角色更容易触发
                '神秘': { frequency: 0.6, emotionThreshold: 0.95 },    // 神秘角色很少发朋友圈
                '内向': { frequency: 0.5, emotionThreshold: 0.98 },    // 内向角色几乎不发
                '外向': { frequency: 1.3, emotionThreshold: 0.75 },    // 外向角色经常发
                '理性': { frequency: 0.7, emotionThreshold: 0.9 },    // 理性角色需要更强情感
                '感性': { frequency: 1.1, emotionThreshold: 0.8 }     // 感性角色容易触发
            };
        }

            // 记录对话内容
            recordChat(characterId, message, isUser = true) {
                if (!this.chatHistory[characterId]) {
                    this.chatHistory[characterId] = [];
                }
                
                this.chatHistory[characterId].push({
                    message,
                    isUser,
                    timestamp: Date.now(),
                    emotion: this.analyzeEmotion(message)
                });

                // 保持最近20句对话
                if (this.chatHistory[characterId].length > 20) {
                    this.chatHistory[characterId].shift();
                }

                this.lastInteractionTime[characterId] = Date.now();
            }

            // 分析情感强度（增强版）
            analyzeEmotion(message) {
                // 积极情感词汇（按强度分级）
                const positiveWords = {
                    high: ['爱', '深爱', '疯狂', '激动', '兴奋', '狂喜', '幸福', '感动', '温暖'],
                    medium: ['开心', '快乐', '高兴', '喜欢', '美好', '舒服', '安心', '期待'],
                    low: ['不错', '还行', '可以', '一般', '平静', '放松']
                };
                
                // 消极情感词汇（按强度分级）
                const negativeWords = {
                    high: ['痛苦', '绝望', '崩溃', '愤怒', '恨', '厌恶'],
                    medium: ['难过', '伤心', '失望', '沮丧', '担心', '害怕', '孤独'],
                    low: ['无聊', '疲惫', '困惑', '犹豫', '紧张']
                };
                
                // 情感强度修饰词
                const intensityModifiers = {
                    '非常': 2, '特别': 2, '超级': 2, '极其': 2, '十分': 1.5,
                    '很': 1.5, '挺': 1.2, '有点': 0.8, '稍微': 0.6, '略微': 0.5
                };
                
                let score = 0;
                let intensity = 1;
                
                // 检查强度修饰词
                for (const [modifier, multiplier] of Object.entries(intensityModifiers)) {
                    if (message.includes(modifier)) {
                        intensity = multiplier;
                        break;
                    }
                }
                
                // 计算积极情感分数
                for (const [level, words] of Object.entries(positiveWords)) {
                    const levelScore = level === 'high' ? 0.4 : level === 'medium' ? 0.25 : 0.15;
                    for (const word of words) {
                        if (message.includes(word)) {
                            score += levelScore * intensity;
                        }
                    }
                }
                
                // 计算消极情感分数
                for (const [level, words] of Object.entries(negativeWords)) {
                    const levelScore = level === 'high' ? -0.4 : level === 'medium' ? -0.25 : -0.15;
                    for (const word of words) {
                        if (message.includes(word)) {
                            score += levelScore * intensity;
                        }
                    }
                }
                
                // 特殊情感触发词（直接触发动态）
                const specialTriggers = ['想你', '思念', '回忆', '过去', '未来', '梦想', '希望', '改变', '成长'];
                for (const trigger of specialTriggers) {
                    if (message.includes(trigger)) {
                        score += 0.2; // 增加触发概率
                    }
                }
                
                return Math.max(-1, Math.min(1, score));
            }

                    // 检查是否应该触发朋友圈
        shouldTriggerMoment(characterId) {
            // 不再强制要求API连接，简化模式也可以工作
            // const apiSettings = window.loadData ? window.loadData('api_settings') : null;
            // if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
            //     return { should: false, type: null, reason: 'API未连接，无法生成智能朋友圈' };
            // }

            const chatHistory = this.chatHistory[characterId] || [];
            const lastInteraction = this.lastInteractionTime[characterId] || 0;
            const lastMoment = this.lastMomentTime[characterId] || 0;
            const now = Date.now();

            // 防刷机制：检查是否距离上次发朋友圈时间太短
            if (now - lastMoment < this.triggerThresholds.minInterval) {
                return { should: false, type: null, reason: '距离上次发朋友圈时间太短' };
            }

            // 获取角色信息以调整触发参数
            const character = window.characters?.find(c => c.id === characterId);
            const personalityModifier = this.getPersonalityModifier(character);

            // 1. 对话驱动型触发
            if (this.checkChatDrivenTrigger(chatHistory, personalityModifier)) {
                return { should: true, type: 'chat', reason: '对话达到情感高点' };
            }

            // 2. 情感高點觸發
            if (this.checkEmotionTrigger(chatHistory, personalityModifier)) {
                return { should: true, type: 'emotion', reason: '情感强度达到触发阈值' };
            }

            // 3. 时间流逝触发（根据性格调整频率）
            if (this.checkTimeTrigger(lastInteraction, now, personalityModifier)) {
                return { should: true, type: 'time', reason: '长时间无互动，想要分享生活' };
            }

            return { should: false, type: null, reason: null };
        }

        // 获取角色性格修饰符
        getPersonalityModifier(character) {
            if (!character) return { frequency: 1.0, emotionThreshold: this.triggerThresholds.emotionHigh };
            
            // 根据角色标签和描述判断性格
            const tags = character.tags || [];
            const persona = character.persona || '';
            
            // 优先使用标签匹配
            for (const tag of tags) {
                if (this.characterPersonalityModifiers[tag]) {
                    return this.characterPersonalityModifiers[tag];
                }
            }
            
            // 如果没有标签，根据描述判断
            if (persona.includes('内向') || persona.includes('安静') || persona.includes('沉默')) {
                return this.characterPersonalityModifiers['内向'];
            } else if (persona.includes('外向') || persona.includes('活泼') || persona.includes('开朗')) {
                return this.characterPersonalityModifiers['外向'];
            } else if (persona.includes('理性') || persona.includes('冷静') || persona.includes('逻辑')) {
                return this.characterPersonalityModifiers['理性'];
            } else if (persona.includes('感性') || persona.includes('敏感') || persona.includes('情绪化')) {
                return this.characterPersonalityModifiers['感性'];
            }
            
            // 默认返回中性性格
            return { frequency: 1.0, emotionThreshold: this.triggerThresholds.emotionHigh };
        }

                                // 检查对话驱动触发（增强版）
            checkChatDrivenTrigger(chatHistory, personalityModifier) {
                if (chatHistory.length < 3) { // 降低最小对话数量要求
                    return false;
                }

                // 检查最近几句对话的情感变化
                const recentChats = chatHistory.slice(-5); // 只看最近5句
                let emotionSum = 0;
                let hasUserMessage = false;
                let hasHighEmotion = false;
                let consecutiveEmotional = 0;

                recentChats.forEach((chat, index) => {
                    emotionSum += chat.emotion;
                    if (chat.isUser) hasUserMessage = true;
                    
                    // 检查是否有高情感消息
                    if (Math.abs(chat.emotion) > 0.6) {
                        hasHighEmotion = true;
                        consecutiveEmotional++;
                    } else {
                        consecutiveEmotional = 0;
                    }
                });

                // 根据性格调整触发条件
                const adjustedThreshold = 0.3 * personalityModifier.frequency; // 降低阈值
                const adjustedEmotionThreshold = 0.4 * personalityModifier.frequency;

                // 多种触发条件：
                // 1. 用户发言且情感强度足够
                if (hasUserMessage && Math.abs(emotionSum) > adjustedEmotionThreshold) {
                    return true;
                }
                
                // 2. 连续高情感消息
                if (consecutiveEmotional >= 2) {
                    return true;
                }
                
                // 3. 单次极高情感
                if (hasHighEmotion && Math.abs(emotionSum) > 0.8) {
                    return true;
                }

                return false;
            }

                    // 检查情感触发（增强版）
            checkEmotionTrigger(chatHistory, personalityModifier) {
                if (chatHistory.length === 0) return false;

                const recentChats = chatHistory.slice(-3);
                const maxEmotion = Math.max(...recentChats.map(c => Math.abs(c.emotion)));
                
                // 使用性格调整后的情感阈值
                const baseThreshold = personalityModifier.emotionThreshold;
                
                // 检查是否有突然的情感变化（情感波动）
                if (recentChats.length >= 2) {
                    const emotionChanges = [];
                    for (let i = 1; i < recentChats.length; i++) {
                        const change = Math.abs(recentChats[i].emotion - recentChats[i-1].emotion);
                        emotionChanges.push(change);
                    }
                    const maxChange = Math.max(...emotionChanges);
                    
                    // 如果情感变化很大，降低触发阈值
                    if (maxChange > 0.5) {
                        return maxEmotion > (baseThreshold * 0.8);
                    }
                }
                
                // 检查是否有特殊情感词汇
                const lastMessage = recentChats[recentChats.length - 1];
                if (lastMessage && !lastMessage.isUser) { // 角色消息
                    const specialWords = ['想你', '思念', '回忆', '过去', '未来', '梦想', '希望', '改变', '成长'];
                    const hasSpecialWord = specialWords.some(word => lastMessage.message.includes(word));
                    if (hasSpecialWord) {
                        return maxEmotion > (baseThreshold * 0.7); // 进一步降低阈值
                    }
                }
                
                return maxEmotion > baseThreshold;
            }

        // 检查时间触发
        checkTimeTrigger(lastInteraction, now, personalityModifier) {
            const baseTimeGap = this.triggerThresholds.timeGap;
            // 根据性格调整时间间隔
            const adjustedTimeGap = baseTimeGap / personalityModifier.frequency;
            
            return (now - lastInteraction) > adjustedTimeGap;
        }

            // 获取触发上下文
            getTriggerContext(characterId, triggerType) {
                const chatHistory = this.chatHistory[characterId] || [];
                
                if (triggerType === 'chat' && chatHistory.length > 0) {
                    // 返回最近几句对话的关键信息
                    const recentChats = chatHistory.slice(-3);
                    return recentChats.map(c => c.message).join(' | ');
                }
                
                return '';
            }

                    // 记录朋友圈发布时间
        recordMomentPosted(characterId) {
            this.lastMomentTime[characterId] = Date.now();
        }

        // 清理过期数据
        cleanup() {
            const now = Date.now();
            const maxAge = 24 * 60 * 60 * 1000; // 24小时

            Object.keys(this.chatHistory).forEach(characterId => {
                this.chatHistory[characterId] = this.chatHistory[characterId].filter(
                    chat => now - chat.timestamp < maxAge
                );
            });

            Object.keys(this.lastInteractionTime).forEach(characterId => {
                if (now - this.lastInteractionTime[characterId] > maxAge) {
                    delete this.lastInteractionTime[characterId];
                }
            });

            Object.keys(this.lastMomentTime).forEach(characterId => {
                if (now - this.lastMomentTime[characterId] > maxAge) {
                    delete this.lastMomentTime[characterId];
                }
            });
        }
        }

        // 创建全局触发系统实例
        const momentsTriggerSystem = new MomentsTriggerSystem();

        function gatherAIContext(characterId) {
            try {
                if (typeof characters === 'undefined' || typeof chatHistories === 'undefined' || typeof worldBooks === 'undefined') {
                    console.error("【核心错误】: 全局变量 characters, chatHistories, 或 worldBooks 未定义。");
                    return null;
                }
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error("【数据流中断】: gatherAIContext 无法找到 ID 为 '" + characterId + "' 的角色。");
                    return null;
                }
                const chatHistory = (chatHistories[characterId]?.history || []).slice(-10);
                const worldBookContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId);
                        return book ? `[世界观: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean)
                    .join('\n\n');
                const currentStatus = characterCurrentStatus[characterId] || '未知';

                const contextPackage = {
                    character: character,
                    chatHistory: chatHistory,
                    worldBookContext: worldBookContext,
                    currentStatus: currentStatus // 新增：将短期记忆加入情报包
                };
                console.log("【数据流正常】: 已为角色 '" + character.name + "' 成功打包上下文。聊天记录数量: " + chatHistory.length);
                return contextPackage;
            } catch (error) {
                console.error("【严重错误】: gatherAIContext 函数内部出现异常:", error);
                return null;
            }
        }

        function testAIContext(characterId) {
            if (!characterId) {
                console.log("【调试工具】请输入一个角色ID进行测试，例如 testAIContext('char_123456')");
                return;
            }
            console.log(`--- 正在为角色【${characterId}】测试上下文数据 ---`);
            const context = gatherAIContext(characterId);
            if (context) {
                console.log("✅ 成功获取上下文:", context);
                alert("调试信息已打印在控制台，请按F12查看。");
            } else {
                console.error("❌ 获取上下文失败，请检查角色ID是否正确。");
                alert("获取上下文失败，请按F12查看控制台的错误信息。");
            }
        }

        function checkRawStorageData(key) {
            if (!key) {
                console.log("【仓库验货员】: 请提供要检查的仓库钥匙 (key)，例如: checkRawStorageData('characters')");
                return;
            }
            console.log(`--- 正在检查仓库中 '${key}' 的原始货物 ---`);
            const rawData = localStorage.getItem(key);
            if (rawData === null) {
                console.log(`🟡 仓库中没有找到名为 '${key}' 的货物。`);
                alert(`仓库中没有找到 '${key}'。`);
            } else {
                console.log("✅ 找到了货物，原始内容如下:");
                console.log(rawData);
                console.log(`货物类型是: ${typeof rawData}`);
                if (typeof rawData !== 'string') {
                    console.warn("🟡 警告: 货物不是字符串格式，这可能不是原始数据。");
                }
                alert(`已在控制台打印出 '${key}' 的原始货物内容和类型，请按F12查看。`);
            }
        }

        // 定期清理触发系统数据
        setInterval(() => {
            momentsTriggerSystem.cleanup();
        }, 60 * 60 * 1000); // 每小时清理一次

        // 添加测试函数来验证功能
        function testFeatures() {
            console.log('=== 功能测试开始 ===');
            
            // 测试1: 检查接收按钮是否存在
            const receiveBtn = document.querySelector('#receive-chat-button');
            console.log('测试1 - 接收按钮:', receiveBtn ? '✅ 存在' : '❌ 不存在');
            
            // 测试2: 检查通知元素是否存在
            const notificationEl = document.querySelector('#new-message-alert');
            console.log('测试2 - 通知元素:', notificationEl ? '✅ 存在' : '❌ 不存在');
            
            // 测试3: 检查是否有角色数据
            console.log('测试3 - 角色数据:', characters.length > 0 ? `✅ 有 ${characters.length} 个角色` : '❌ 没有角色');
            
            // 测试4: 检查聊天历史数据结构
            console.log('测试4 - 聊天历史:', Object.keys(chatHistories).length > 0 ? `✅ 有 ${Object.keys(chatHistories).length} 个聊天记录` : '❌ 没有聊天记录');
            
            // 测试5: 检查API设置
            const apiSettings = loadData('api_settings');
            console.log('测试5 - API设置:', apiSettings && apiSettings.url ? '✅ 已配置' : '❌ 未配置');
            
            // 测试6: 检查接收按钮图标
            if (receiveBtn) {
                const icon = receiveBtn.querySelector('i');
                console.log('测试6 - 接收按钮图标:', icon ? `✅ ${icon.className}` : '❌ 没有图标');
            }
            
            console.log('=== 功能测试完成 ===');
            
            // 显示测试结果
            showMessageBox('功能测试完成，请查看控制台输出');
        }

        // 将测试函数添加到全局作用域，方便在控制台调用
        window.testFeatures = testFeatures;
        
        // 页面加载时检查通知权限
        document.addEventListener('DOMContentLoaded', () => {
            console.log('页面加载完成，检查通知权限...');
            if ('Notification' in window) {
                console.log('当前通知权限:', Notification.permission);
                if (Notification.permission === 'default') {
                    console.log('提示：可以在控制台运行 testNotificationPermission() 来设置通知权限');
                }
            }
            

        });
        
        // 添加消息接收测试函数
        function testMessageReceiving() {
            console.log('=== 消息接收测试 ===');
            
            // 检查当前聊天状态
            console.log('当前聊天角色ID:', currentChatCharacterId);
            console.log('当前微信角色ID:', currentWeChatCharacterId);
            
            // 检查聊天界面状态
            const chatScreen = $('#wechat-chat-screen');
            const isChatScreenActive = !chatScreen.classList.contains('hidden');
            console.log('聊天界面是否激活:', isChatScreenActive);
            
            // 检查聊天历史
            if (currentChatCharacterId) {
                const chatSession = chatHistories[currentChatCharacterId];
                if (chatSession) {
                    console.log('当前角色聊天记录数量:', chatSession.history.length);
                    if (chatSession.history.length > 0) {
                        const lastMessage = chatSession.history[chatSession.history.length - 1];
                        console.log('最后一条消息:', lastMessage);
                    }
                }
            }
            
            // 检查通知元素
            const notificationEl = $('#new-message-alert');
            console.log('通知元素状态:', notificationEl ? '存在' : '不存在');
            if (notificationEl) {
                console.log('通知元素类名:', notificationEl.className);
                console.log('通知元素样式:', notificationEl.style.transform);
            }
            
            console.log('=== 测试完成 ===');
        }
        
        // 添加模拟AI消息接收测试函数
        function testAIMessageReceiving(characterId) {
            console.log('=== 模拟AI消息接收测试 ===');
            
            if (!characterId) {
                characterId = currentChatCharacterId || Object.keys(chatHistories)[0];
            }
            
            if (!characterId) {
                console.error('没有可用的角色ID');
                return;
            }
            
            console.log('测试角色ID:', characterId);
            
            // 模拟AI消息
            const testMessage = `这是一条测试消息，时间: ${new Date().toLocaleTimeString()}`;
            
            // 调用消息处理函数
            processAndDisplayAIMessages(testMessage, characterId);
            
            console.log('已发送测试消息，请检查：');
            console.log('1. 聊天历史是否更新');
            console.log('2. 通知是否显示');
            console.log('3. 接收按钮是否停止旋转');
            
            // 延迟检查结果
            setTimeout(() => {
                const chatSession = chatHistories[characterId];
                if (chatSession && chatSession.history.length > 0) {
                    const lastMessage = chatSession.history[chatSession.history.length - 1];
                    console.log('最新消息:', lastMessage);
                }
            }, 1000);
        }
        
        // 添加完整的后台消息测试函数
        function testBackgroundMessageFlow(characterId) {
            console.log('=== 后台消息流程测试 ===');
            
            if (!characterId) {
                characterId = currentChatCharacterId || Object.keys(chatHistories)[0];
            }
            
            if (!characterId) {
                console.error('没有可用的角色ID');
                return;
            }
            
            console.log('测试角色ID:', characterId);
            console.log('当前聊天角色:', currentChatCharacterId);
            console.log('当前界面:', $('#wechat-chat-screen').classList.contains('hidden') ? '非聊天界面' : '聊天界面');
            
            // 模拟用户发送消息
            const userMessage = { content: '这是一条测试消息', type: 'text' };
            
            // 模拟AI响应（后台处理）
            console.log('开始模拟AI后台响应...');
            
            // 模拟API调用延迟
            setTimeout(() => {
                const aiResponse = `收到你的测试消息了！|||现在我在后台处理回复|||时间: ${new Date().toLocaleTimeString()}`;
                
                console.log('AI响应完成，开始处理消息...');
                processAndDisplayAIMessages(aiResponse, characterId);
                
                console.log('消息处理完成，请检查：');
                console.log('1. 聊天历史是否更新');
                console.log('2. 如果不在聊天界面，是否有通知弹窗');
                console.log('3. 接收按钮状态');
                
            }, 2000);
        }
        
        // 添加通知权限测试函数
        function testNotificationPermission() {
            console.log('=== 通知权限测试 ===');
            
            if (!('Notification' in window)) {
                console.log('❌ 浏览器不支持系统通知');
                return;
            }
            
            console.log('✅ 浏览器支持系统通知');
            console.log('当前通知权限:', Notification.permission);
            
            if (Notification.permission === 'granted') {
                console.log('✅ 通知权限已授予');
                
                // 测试发送一个系统通知
                const testNotification = new Notification('测试通知', {
                    body: '这是一条测试通知，如果您能看到这条通知，说明系统通知功能正常！',
                    icon: 'https://placehold.co/96x96/777/FFF?text=✓',
                    tag: 'test-notification'
                });
                
                setTimeout(() => testNotification.close(), 3000);
                
            } else if (Notification.permission === 'denied') {
                console.log('❌ 通知权限被拒绝');
                console.log('请在浏览器设置中允许通知权限，或点击地址栏左侧的图标进行设置');
            } else {
                console.log('⏳ 通知权限未设置');
                console.log('正在请求通知权限...');
                requestNotificationPermission().then(granted => {
                    if (granted) {
                        console.log('✅ 通知权限已授予');
                    } else {
                        console.log('❌ 通知权限被拒绝');
                    }
                });
            }
        }
        
        // 测试全屏提醒功能
        function testFullscreenAlert() {
            console.log('=== 测试全屏提醒 ===');
            showFullscreenAlert('test', '这是一条测试消息，用于测试全屏提醒功能是否正常工作！');
        }
        
        // 自定义接收按钮图标
        function setReceiveButtonIcon(iconClass) {
            const receiveBtn = document.querySelector('#receive-chat-button i');
            if (receiveBtn) {
                receiveBtn.className = iconClass;
                console.log('接收按钮图标已更改为:', iconClass);
            }
        }
        
        // 快速设置邮件发送图标
        function setMailSendIcon() {
            setReceiveButtonIcon('ri-mail-send-line');
            console.log('已设置为邮件发送图标');
        }
        
        // 测试邮件发送图标闪烁效果
        function testMailSendFlash() {
            console.log('=== 测试邮件发送图标闪烁 ===');
            const receiveBtn = document.querySelector('#receive-chat-button');
            if (receiveBtn) {
                // 开始闪烁
                receiveBtn.classList.add('spinning');
                console.log('开始闪烁动画...');
                
                // 3秒后停止闪烁
                setTimeout(() => {
                    receiveBtn.classList.remove('spinning');
                    console.log('闪烁动画停止');
                }, 3000);
            } else {
                console.error('接收按钮不存在');
            }
        }
        
        // 预设的优雅图标选项
        const elegantIcons = {
            'mail-send': 'ri-mail-send-line',             // 邮件发送（默认）
            'loading1': 'fas fa-circle-notch',            // 经典加载圈
            'loading2': 'fas fa-spinner',                 // 旋转器
            'loading3': 'fas fa-sync-alt',                // 同步图标
            'loading4': 'fas fa-cog',                     // 齿轮
            'loading5': 'fas fa-dot-circle',              // 点圈
            'loading6': 'fas fa-circle',                  // 实心圆
            'loading7': 'far fa-circle',                  // 空心圆
            'loading8': 'fas fa-asterisk',                // 星形
            'loading9': 'fas fa-star',                    // 星星
            'loading10': 'fas fa-heart',                  // 爱心
            'loading11': 'ri-loader-4-line',              // Remix加载器
            'loading12': 'ri-refresh-line',               // Remix刷新
            'loading13': 'ri-time-line',                  // Remix时钟
            'loading14': 'ri-pulse-line',                 // Remix脉冲
            'loading15': 'ri-loader-2-line'               // Remix加载器2
        };
        
        // 显示图标选择器
        function showIconSelector() {
            const iconList = Object.entries(elegantIcons).map(([key, iconClass]) => 
                `<div class="icon-option" onclick="setReceiveButtonIcon('${iconClass}')">
                    <i class="${iconClass}"></i>
                    <span>${key}</span>
                </div>`
            ).join('');
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                z-index: 99999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 1rem;
                    padding: 2rem;
                    max-width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                    text-align: center;
                ">
                    <h3 style="margin-bottom: 1.5rem; color: #333;">选择接收按钮图标</h3>
                    <div style="
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                        gap: 1rem;
                        margin-bottom: 1.5rem;
                    ">
                        ${iconList}
                    </div>
                    <button onclick="this.closest('.icon-selector-modal').remove()" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 0.75rem 2rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                    ">关闭</button>
                </div>
            `;
            
            modal.className = 'icon-selector-modal';
            document.body.appendChild(modal);
            
            // 添加图标选项样式
            const style = document.createElement('style');
            style.textContent = `
                .icon-option {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 1rem;
                    border: 2px solid #e5e7eb;
                    border-radius: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                .icon-option:hover {
                    border-color: #3b82f6;
                    background: #f0f9ff;
                    transform: translateY(-2px);
                }
                .icon-option i {
                    font-size: 2rem;
                    margin-bottom: 0.5rem;
                    color: #6b7280;
                }
                .icon-option span {
                    font-size: 0.8rem;
                    color: #6b7280;
                }
            `;
            document.head.appendChild(style);
        }
        
        window.testMessageReceiving = testMessageReceiving;
        window.testAIMessageReceiving = testAIMessageReceiving;
        window.testBackgroundMessageFlow = testBackgroundMessageFlow;
        window.testNotificationPermission = testNotificationPermission;
        window.testFullscreenAlert = testFullscreenAlert;
        window.showIconSelector = showIconSelector;
        window.setReceiveButtonIcon = setReceiveButtonIcon;
        window.setMailSendIcon = setMailSendIcon;
        window.testMailSendFlash = testMailSendFlash;




        // 更换朋友圈背景
        async function changeMomentsCover() {
            console.log('开始更换朋友圈背景...');
            
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                
                console.log('文件输入元素已创建');
                
                input.onchange = async (e) => {
                    console.log('文件选择事件触发');
                    const file = e.target.files[0];
                    if (file) {
                        console.log('选择的文件:', file.name, '大小:', file.size, '类型:', file.type);
                        try {
                            // 使用统一的图片处理函数，添加压缩选项
                            const compressedDataUrl = await handleImageUpload(e.target, null, null, { 
                                compression: { maxWidth: 750, maxHeight: 384 } // 适合朋友圈背景的尺寸
                            });
                            
                            console.log('压缩后的图片数据:', compressedDataUrl ? '成功' : '失败');
                            
                            if (compressedDataUrl) {
                                const momentsCover = $('#moments-cover');
                                console.log('找到背景元素:', !!momentsCover);
                                
                                if (momentsCover) {
                                    // 直接设置元素的背景图片样式，确保立即生效
                                    momentsCover.style.backgroundImage = `url(${compressedDataUrl})`;
                                    momentsCover.style.backgroundSize = 'cover';
                                    momentsCover.style.backgroundPosition = 'center';
                                    momentsCover.style.backgroundRepeat = 'no-repeat';
                                    
                                    // 同时设置CSS变量作为备用
                                    document.documentElement.style.setProperty('--moments-cover-image', `url(${compressedDataUrl})`);
                                    
                                    // 隐藏提示文字
                                    const hintElement = $('#moments-cover-hint');
                                    if (hintElement) {
                                        hintElement.style.display = 'none';
                                        console.log('提示文字已隐藏');
                                    }
                                    
                                    // 保存背景图片
                                    saveData('moments_cover', compressedDataUrl);
                                    showMessageBox('背景图片更换成功！');
                                    
                                    // 调试信息
                                    console.log('背景图片已设置:', compressedDataUrl);
                                    console.log('元素样式:', momentsCover.style.backgroundImage);
                                    console.log('CSS变量值:', document.documentElement.style.getPropertyValue('--moments-cover-image'));
                                    console.log('元素计算样式:', window.getComputedStyle(momentsCover).backgroundImage);
                                } else {
                                    showMessageBox('找不到背景图片元素');
                                }
                            }
                        } catch (error) {
                            console.error('背景图片处理失败:', error);
                            showMessageBox('背景图片处理失败，请重试');
                        }
                    } else {
                        console.log('没有选择文件');
                    }
                };
                
                console.log('准备点击文件输入元素');
                input.click();
                console.log('文件输入元素已点击');
                
            } catch (error) {
                console.error('创建文件输入元素失败:', error);
                showMessageBox('创建文件选择器失败，请重试');
            }
        }

        // 加载朋友圈背景
        function loadMomentsCover() {
            const savedCover = loadData('moments_cover');
            console.log('尝试加载背景图片:', savedCover ? '有保存的图片' : '没有保存的图片');
            
            if (savedCover) {
                const momentsCover = $('#moments-cover');
                if (momentsCover) {
                    // 直接设置元素的背景图片样式，确保立即生效
                    momentsCover.style.backgroundImage = `url(${savedCover})`;
                    momentsCover.style.backgroundSize = 'cover';
                    momentsCover.style.backgroundPosition = 'center';
                    momentsCover.style.backgroundRepeat = 'no-repeat';
                    
                    // 同时设置CSS变量作为备用
                    document.documentElement.style.setProperty('--moments-cover-image', `url(${savedCover})`);
                    
                    // 隐藏提示文字
                    const hintElement = $('#moments-cover-hint');
                    if (hintElement) {
                        hintElement.style.display = 'none';
                    }
                    
                    console.log('背景图片加载成功，样式已设置');
                    console.log('元素样式:', momentsCover.style.backgroundImage);
                    console.log('CSS变量值:', document.documentElement.style.getPropertyValue('--moments-cover-image'));
                } else {
                    console.error('找不到背景图片元素');
                }
            } else {
                console.log('没有保存的背景图片，使用默认图片');
                // 设置默认图片
                const defaultCover = 'https://placehold.co/375x192/333/fff?text=Cover';
                
                // 直接设置元素样式
                const momentsCover = $('#moments-cover');
                if (momentsCover) {
                    momentsCover.style.backgroundImage = `url(${defaultCover})`;
                    momentsCover.style.backgroundSize = 'cover';
                    momentsCover.style.backgroundPosition = 'center';
                    momentsCover.style.backgroundRepeat = 'no-repeat';
                }
                
                // 设置CSS变量
                document.documentElement.style.setProperty('--moments-cover-image', `url(${defaultCover})`);
                
                // 显示提示文字（因为使用的是默认图片）
                const hintElement = $('#moments-cover-hint');
                if (hintElement) {
                    hintElement.style.display = 'flex';
                }
            }
        }

        // 更换朋友圈头像
        async function changeMomentsAvatar() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 使用统一的图片处理函数，添加压缩选项
                        const compressedDataUrl = await handleImageUpload(e.target, null, null, { 
                            compression: { maxWidth: 256, maxHeight: 256 } // 适合头像的尺寸
                        });
                        
                        if (compressedDataUrl) {
                            const momentsAvatar = $('#moments-user-avatar');
                            // 直接设置元素的背景图片样式，确保立即生效
                            momentsAvatar.style.backgroundImage = `url(${compressedDataUrl})`;
                            momentsAvatar.style.backgroundSize = 'cover';
                            momentsAvatar.style.backgroundPosition = 'center';
                            momentsAvatar.style.backgroundRepeat = 'no-repeat';
                            
                            // 同时设置CSS变量作为备用
                            document.documentElement.style.setProperty('--moments-avatar-image', `url(${compressedDataUrl})`);
                            
                            // 保存头像图片
                            saveData('moments_avatar', compressedDataUrl);
                            showMessageBox('头像更换成功！');
                            
                            // 调试信息
                            console.log('头像图片已设置:', compressedDataUrl);
                            console.log('元素样式:', momentsAvatar.style.backgroundImage);
                        }
                    } catch (error) {
                        console.error('头像图片处理失败:', error);
                        showMessageBox('头像图片处理失败，请重试');
                    }
                }
            };
            input.click();
        }

        // 编辑朋友圈用户名
        function editMomentsName() {
            const currentName = $('#moments-user-name').textContent;
            const newName = prompt('请输入新的用户名：', currentName);
            if (newName && newName.trim() && newName !== currentName) {
                $('#moments-user-name').textContent = newName.trim();
                // 保存用户名
                saveData('moments_username', newName.trim());
                // 刷新动态显示，确保名字一致
                renderUnifiedMoments();
                showMessageBox('用户名已更新！');
            }
        }

        // 加载朋友圈头像和用户名
        function loadMomentsUserInfo() {
            const savedAvatar = loadData('moments_avatar');
            const savedUsername = loadData('moments_username');
            
            console.log('尝试加载头像:', savedAvatar ? '有保存的头像' : '没有保存的头像');
            
            // 加载头像
            if (savedAvatar) {
                const momentsAvatar = $('#moments-user-avatar');
                if (momentsAvatar) {
                    // 直接设置元素的背景图片样式，确保立即生效
                    momentsAvatar.style.backgroundImage = `url(${savedAvatar})`;
                    momentsAvatar.style.backgroundSize = 'cover';
                    momentsAvatar.style.backgroundPosition = 'center';
                    momentsAvatar.style.backgroundRepeat = 'no-repeat';
                    
                    // 同时设置CSS变量作为备用
                    document.documentElement.style.setProperty('--moments-avatar-image', `url(${savedAvatar})`);
                    
                    console.log('头像加载成功，样式已设置');
                    console.log('元素样式:', momentsAvatar.style.backgroundImage);
                } else {
                    console.error('找不到头像元素');
                }
            } else {
                console.log('没有保存的头像，使用默认头像');
                // 设置默认头像
                const defaultAvatar = 'https://placehold.co/128x128/777/FFF?text=Me';
                
                // 直接设置元素样式
                const momentsAvatar = $('#moments-user-avatar');
                if (momentsAvatar) {
                    momentsAvatar.style.backgroundImage = `url(${defaultAvatar})`;
                    momentsAvatar.style.backgroundSize = 'cover';
                    momentsAvatar.style.backgroundPosition = 'center';
                    momentsAvatar.style.backgroundRepeat = 'no-repeat';
                }
                
                // 设置CSS变量
                document.documentElement.style.setProperty('--moments-avatar-image', `url(${defaultAvatar})`);
            }
            
            // 加载用户名
            console.log('尝试加载用户名:', savedUsername || '使用默认用户名');
            
            if (savedUsername) {
                const momentsUsername = $('#moments-user-name');
                momentsUsername.textContent = savedUsername;
                console.log('用户名加载成功:', savedUsername);
            }
        }

        // 手动触发朋友圈生成 - 必须要有API连接
        async function triggerMomentManually(characterId, triggerType = 'manual', context = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return;
                }

                // 检查API是否连接
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    showMessageBox('需要先配置AI API才能发布动态');
                    return null;
                }

                // 使用AI模型生成动态
                console.log('使用AI模型生成动态...');
                const momentData = await generateIntelligentMoment(character, context, triggerType);
                
                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: momentData.text,
                    image: `https://placehold.co/600x400/2a2a2a/ffffff?text=${encodeURIComponent(momentData.image_desc)}`,
                    tags: momentData.tags || "#心情 #日常",
                    likes: 0,
                    comments: [],
                    mood: momentData.mood || "平静",
                    trigger_reason: momentData.trigger_reason || "手动触发",
                    image_desc: momentData.image_desc
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if (currentTab === 'moments') {
                    renderUnifiedMoments();
                }
                
                showMessageBox(`${character.name} 发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('手动触发朋友圈失败:', error);
                showMessageBox('触发朋友圈失败，请稍后重试');
            }
        }

        // 简化模式：基于聊天内容生成简单动态
        function generateSimpleMoment(character, context) {
            const currentTime = new Date().toLocaleString('zh-CN');
            const timeGreeting = getTimeGreeting();
            
            // 基于角色性格生成动态内容
            const personality = character.persona || '';
            let content = '';
            let mood = '平静';
            
            if (personality.includes('温柔') || personality.includes('体贴')) {
                content = `${timeGreeting}，今天的心情很温暖。${context ? `刚刚聊到了${context}，让我想起了很多美好的事情。` : '希望能把这份温暖传递给你。'}`;
                mood = '温暖';
            } else if (personality.includes('活泼') || personality.includes('开朗')) {
                content = `${timeGreeting}！今天又是充满活力的一天！${context ? `和你的聊天让我很开心，特别是关于${context}的部分。` : '生活总是充满惊喜！'}`;
                mood = '开心';
            } else if (personality.includes('神秘') || personality.includes('深沉')) {
                content = `${timeGreeting}，在思考一些事情。${context ? `关于${context}，我有一些新的想法。` : '有时候沉默也是一种表达。'}`;
                mood = '思考';
            } else {
                content = `${timeGreeting}，今天过得怎么样？${context ? `我们刚才聊到了${context}，这让我很有感触。` : '希望能和你分享更多。'}`;
                mood = '平静';
            }
            
            return {
                text: content,
                image_desc: `${timeGreeting}的${mood}心情`,
                tags: `#${mood} #日常 #${timeGreeting}`,
                mood: mood,
                trigger_reason: context ? `聊天内容：${context}` : '日常分享'
            };
        }

        // 获取时间问候语
        function getTimeGreeting() {
            const hour = new Date().getHours();
            if (hour < 6) return '深夜';
            if (hour < 12) return '早上';
            if (hour < 18) return '下午';
            if (hour < 22) return '晚上';
            return '深夜';
        }

        // 从聊天消息中提取动态内容
        function extractMomentContent(message) {
            // 移除动态发布指令标记
            let content = message.replace(/\[发布动态\]|\[发动态\]/g, '').trim();
            
            // 如果内容太长，截取合适长度
            if (content.length > 100) {
                content = content.substring(0, 100) + '...';
            }
            
            return content;
        }

        // AI自动触发动态 - 在聊天时根据情感触动自动发布
        async function triggerAIMomentFromChat(characterId, chatContext, emotionTrigger) {
            try {
                // 检查API是否连接
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    console.log('API未配置，无法自动发布动态');
                    return null;
                }

                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return null;
                }

                // 检查是否应该触发动态（避免过于频繁）
                if (!shouldTriggerMoment(characterId, emotionTrigger)) {
                    return null;
                }

                // 使用AI生成基于聊天内容的动态
                const momentData = await generateIntelligentMoment(character, chatContext, 'emotion');
                
                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: momentData.text,
                    image: `https://placehold.co/600x400/2a2a2a/ffffff?text=${encodeURIComponent(momentData.image_desc)}`,
                    tags: momentData.tags || "#心情 #聊天 #触动",
                    likes: 0,
                    comments: [],
                    mood: momentData.mood || "触动",
                    trigger_reason: `聊天情感触动：${emotionTrigger}`,
                    image_desc: momentData.image_desc
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if (currentTab === 'moments') {
                    renderUnifiedMoments();
                }
                
                console.log(`${character.name} 因情感触动自动发布了一条新动态`);
                showMessageBox(`${character.name} 发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('AI自动触发动态失败:', error);
                return null;
            }
        }

        // 判断是否应该触发动态
        function shouldTriggerMoment(characterId, emotionTrigger) {
            const now = Date.now();
            const lastMomentTime = momentsTriggerSystem.getLastMomentTime(characterId);
            
            // 如果距离上次发动态不到30分钟，不触发
            if (lastMomentTime && (now - lastMomentTime) < 30 * 60 * 1000) {
                return false;
            }

            // 根据情感触动的强度决定触发概率
            const triggerChances = {
                'high': 0.8,    // 高情感触动：80%概率
                'medium': 0.5,  // 中等情感触动：50%概率
                'low': 0.2      // 低情感触动：20%概率
            };

            const chance = triggerChances[emotionTrigger] || 0.2;
            return Math.random() < chance;
        }

        // 检测情感触动
        function detectEmotionalTrigger(characterId, userMessage) {
            try {
                // 检查API是否配置
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    return; // API未配置，不检测
                }

                // 分析用户消息的情感强度
                const emotionLevel = analyzeEmotionLevel(userMessage);
                
                // 如果情感强度足够高，尝试触发动态
                if (emotionLevel !== 'none') {
                    // 获取聊天上下文
                    const chatContext = getChatContext(characterId);
                    
                    // 异步触发动态（不阻塞聊天）
                    triggerAIMomentFromChat(characterId, chatContext, emotionLevel);
                }
            } catch (error) {
                console.error('检测情感触动失败:', error);
            }
        }

        // 分析情感强度
        function analyzeEmotionLevel(message) {
            const message_lower = message.toLowerCase();
            
            // 高情感触动词汇
            const highEmotionWords = [
                '爱', '喜欢', '讨厌', '恨', '开心', '难过', '伤心', '痛苦', '绝望', '兴奋',
                '激动', '愤怒', '生气', '害怕', '恐惧', '担心', '焦虑', '紧张', '放松', '安心',
                '感动', '震撼', '惊讶', '震惊', '失望', '绝望', '希望', '梦想', '未来', '过去',
                '回忆', '思念', '想念', '怀念', '珍惜', '重要', '特别', '唯一', '永远', '一生'
            ];
            
            // 中等情感触动词汇
            const mediumEmotionWords = [
                '好', '坏', '不错', '一般', '还行', '可以', '满意', '不满', '期待', '好奇',
                '有趣', '无聊', '新鲜', '熟悉', '陌生', '变化', '稳定', '平静', '热闹', '安静',
                '忙碌', '悠闲', '充实', '空虚', '有意义', '无意义', '有价值', '无价值'
            ];
            
            // 检查高情感词汇
            for (const word of highEmotionWords) {
                if (message_lower.includes(word)) {
                    return 'high';
                }
            }
            
            // 检查中等情感词汇
            for (const word of mediumEmotionWords) {
                if (message_lower.includes(word)) {
                    return 'medium';
                }
            }
            
            // 检查特殊符号和重复字符（可能表示强烈情感）
            if (message.includes('!!!') || message.includes('？？') || message.includes('...') || 
                message.includes('😭') || message.includes('😍') || message.includes('😡') ||
                message.includes('❤️') || message.includes('💔') || message.includes('🔥')) {
                return 'high';
            }
            
            // 检查消息长度（长消息可能包含更多情感内容）
            if (message.length > 50) {
                return 'low';
            }
            
            return 'none';
        }

        // 获取聊天上下文
        function getChatContext(characterId) {
            try {
                const chatSession = chatHistories[characterId];
                if (!chatSession || !chatSession.history) {
                    return '';
                }
                
                // 获取最近5条消息作为上下文
                const recentMessages = chatSession.history.slice(-5);
                const context = recentMessages.map(msg => {
                    const sender = msg.sender === 'user' ? '用户' : 'AI';
                    return `${sender}: ${msg.content}`;
                }).join('\n');
                
                return context;
            } catch (error) {
                console.error('获取聊天上下文失败:', error);
                return '';
            }
        }

        // 从聊天中直接发布动态（保留原有功能）
        async function publishMomentFromChat(characterId, content) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return null;
                }

                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    image: `https://placehold.co/600x400/2a2a2a/ffffff?text=${encodeURIComponent('聊天中的心情分享')}`,
                    tags: "#心情 #聊天 #分享",
                    likes: 0,
                    comments: [],
                    mood: "分享",
                    trigger_reason: "聊天中主动发布",
                    image_desc: "聊天中的心情分享"
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if (currentTab === 'moments') {
                    renderUnifiedMoments();
                }
                
                console.log(`${character.name} 从聊天中发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('从聊天发布动态失败:', error);
                return null;
            }
        }



        // 朋友圈事件监听器现在直接在HTML中绑定

        // 删除朋友圈动态
        function deleteMoment(momentId) {
            // 找到要删除的动态信息
            let momentToDelete = null;
            let authorName = '未知';
            
            Object.keys(momentsData).forEach(authorId => {
                const moment = momentsData[authorId].find(m => m.id === momentId);
                if (moment) {
                    momentToDelete = moment;
                    if (authorId === 'user') {
                        authorName = loadData('moments_username') || '我';
                    } else {
                        const character = characters.find(c => c.id === authorId);
                        authorName = character ? character.name : '未知';
                    }
                }
            });
            
            if (!momentToDelete) {
                showMessageBox('找不到要删除的动态');
                return;
            }
            
            // 显示删除确认
            const confirmMessage = `确定要删除 ${authorName} 的这条动态吗？\n\n"${momentToDelete.content.substring(0, 50)}${momentToDelete.content.length > 50 ? '...' : ''}"\n\n删除后无法恢复！`;
            
            if (confirm(confirmMessage)) {
                // 从所有角色的动态中删除
                Object.keys(momentsData).forEach(authorId => {
                    momentsData[authorId] = momentsData[authorId].filter(m => m.id !== momentId);
                });
                
                // 保存数据
                saveData('momentsData', momentsData);
                
                // 刷新显示
                renderUnifiedMoments();
                
                showMessageBox(`已删除 ${authorName} 的动态`);
            }
        }

        // 点赞朋友圈动态
        function likeMoment(momentId) {
            // 找到动态并切换点赞状态
            let found = false;
            let moment = null;
            let authorId = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    authorId = aid;
                    found = true;
                }
            });
            
            if (!found || !moment) {
                showMessageBox('找不到要点赞的动态');
                return;
            }
            
            // 初始化点赞数据结构
            if (!moment.likes) {
                moment.likes = { count: 0, users: [] };
            } else if (typeof moment.likes === 'number') {
                // 兼容旧数据格式
                moment.likes = { count: moment.likes, users: [] };
            }
            
            const currentUser = '我'; // 当前用户标识
            const userIndex = moment.likes.users.indexOf(currentUser);
            
            if (userIndex === -1) {
                // 用户还没点赞，添加点赞
                moment.likes.users.push(currentUser);
                moment.likes.count++;
                showMessageBox('点赞成功！');
            } else {
                // 用户已经点赞，取消点赞
                moment.likes.users.splice(userIndex, 1);
                moment.likes.count--;
                showMessageBox('已取消点赞');
            }
            
                saveData('momentsData', momentsData);
                renderUnifiedMoments();
        }

        // 评论朋友圈动态
        function commentMoment(momentId) {
            // 找到动态
            let moment = null;
            let authorId = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    authorId = aid;
                }
            });
            
            if (!moment) {
                showMessageBox('找不到要评论的动态');
                return;
            }
            
            // 显示评论输入框
            const comment = prompt('请输入您的评论：');
            if (comment && comment.trim()) {
                // 初始化评论数组
                if (!moment.comments) {
                    moment.comments = [];
                }
                
                // 添加新评论
                        moment.comments.push({
                            id: `comment_${Date.now()}`,
                            author: '我',
                            content: comment.trim(),
                            timestamp: Date.now()
                });
                
                saveData('momentsData', momentsData);
                renderUnifiedMoments();
                showMessageBox('评论已添加！');
                
                // 如果评论的是AI角色的朋友圈，触发AI回复
                if (authorId !== 'user') {
                    // 延迟一下，让用户看到评论先显示
                    setTimeout(() => {
                        generateAICommentReply(momentId, comment.trim(), authorId);
                    }, 1000);
                }
            }
        }

        // 生成AI角色对评论的回复
        async function generateAICommentReply(momentId, userComment, characterId) {
            const moment = Object.values(momentsData).flat().find(m => m.id === momentId);
            if (!moment) return;

            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            try {
                // 构建评论回复的prompt
                const commentPrompt = buildCommentReplyPrompt(character, moment, userComment);
                
                // 如果有API连接，调用AI
                const apiSettings = loadData('api_settings');
                if (apiSettings && apiSettings.api_url && apiSettings.api_key) {
                    // 这里可以调用实际的AI API
                    console.log('API已连接，可以调用AI生成评论回复');
                    // 暂时使用模拟回复
                    const aiReply = generateFallbackCommentReply(character, moment, userComment);
                    addAICommentReply(momentId, aiReply, characterId);
                } else {
                    // 没有API时，使用模拟回复
                    const aiReply = generateFallbackCommentReply(character, moment, userComment);
                    addAICommentReply(momentId, aiReply, characterId);
                }
            } catch (error) {
                console.error('生成AI评论回复失败:', error);
                // 使用备用回复
                const aiReply = generateFallbackCommentReply(character, moment, userComment);
                addAICommentReply(momentId, aiReply, characterId);
            }
        }

        // 构建评论回复的prompt
        function buildCommentReplyPrompt(character, moment, userComment) {
            return `你是一个名为"${character.name}"的AI角色。

角色设定：${character.personality || '温柔友善'}
世界背景：${getWorldBookContext()}

用户"${loadData('moments_username') || 'My Name'}"在你的朋友圈下评论了："${userComment}"

你的朋友圈内容是：${moment.content}

请根据你的角色设定、世界背景和朋友圈内容，对用户的评论做出合适的回复。回复应该：
1. 符合你的角色性格
2. 与朋友圈内容相关
3. 自然、有趣、有互动性
4. 长度控制在1-2句话

请直接给出回复内容，不要加任何格式标记。`;
        }

        // 生成备用的评论回复
        function generateFallbackCommentReply(character, moment, userComment) {
            const replies = [
                `谢谢你的评论！${moment.content.includes('开心') ? '确实很开心呢' : '你说得对'}`,
                `哈哈，${userComment.includes('？') ? '这个问题很有趣' : '你的想法很棒'}`,
                `嗯嗯，${moment.content.includes('天气') ? '今天的天气确实不错' : '你说得很对'}`,
                `哇，你竟然注意到了这个！${moment.content.includes('画') ? '画画确实很有趣' : '谢谢你的关注'}`,
                `哈哈，${userComment.includes('！') ? '我也这么觉得' : '你说得很有道理'}`
            ];
            
            // 根据角色性格调整回复风格
            if (character.personality && character.personality.includes('温柔')) {
                return `谢谢你的评论呢～${replies[Math.floor(Math.random() * replies.length)]}`;
            } else if (character.personality && character.personality.includes('傲娇')) {
                return `哼，${replies[Math.floor(Math.random() * replies.length)]}...才不是因为你这么说呢！`;
            } else {
                return replies[Math.floor(Math.random() * replies.length)];
            }
        }

        // 添加AI的评论回复
        function addAICommentReply(momentId, aiReply, characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 找到对应的动态并添加评论
            Object.keys(momentsData).forEach(aid => {
                const moment = momentsData[aid].find(m => m.id === momentId);
                if (moment) {
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push({
                        id: `comment_${Date.now()}`,
                        author: character.name,
                        content: aiReply,
                        timestamp: Date.now(),
                        isAI: true // 标记这是AI的回复
                    });
                    saveData('momentsData', momentsData);
                    renderUnifiedMoments();
                    showMessageBox(`${character.name}回复了你的评论！`);
                }
            });
        }

        // =============================================
        // V7.1: 全新动态和日记功能 JS
        // =============================================

        // --- 动态 (Moments) 新增函数 ---

        let tempMomentImage = null; // 用于暂存待上传的动态图片

        // 渲染统一的动态信息流
        function renderUnifiedMoments() {
            const feedContainer = $('#moments-feed');
            feedContainer.innerHTML = '';

            // 整合所有人的动态并按时间倒序排序
            let allMoments = [];
            Object.keys(momentsData).forEach(authorId => {
                const authorMoments = momentsData[authorId].map(m => ({...m, authorId}));
                allMoments = allMoments.concat(authorMoments);
            });

            // 按时间戳倒序排序
            allMoments.sort((a, b) => b.timestamp - a.timestamp);

            if (allMoments.length === 0) {
                feedContainer.innerHTML = `
                    <div class="text-center text-gray-500 p-8">
                        <div class="mb-4">
                            <i class="ri-polaroid-2-line text-4xl text-gray-300 mb-2"></i>
                            <p class="text-lg font-medium">还没有任何动态</p>
                        </div>
                        <div class="space-y-2 text-sm">
                            <p>• 点击右上角 <i class="ri-add-box-line"></i> 发布你的第一条动态</p>
                            <p>• 角色会在聊天中根据情感浓度自动发布动态</p>
                            <p>• 多和角色聊天，让朋友圈更加生动有趣！</p>
                        </div>
                    </div>
                `;
                return;
            }

            allMoments.forEach(moment => {
                let author = null;
                if (moment.authorId === 'user') {
                    // 使用朋友圈设置的用户名和头像
                    const momentsUsername = loadData('moments_username') || '我';
                    const momentsAvatar = loadData('moments_avatar') || userAvatars[currentWeChatCharacterId] || 'https://placehold.co/128x128/777/FFF?text=Me';
                    author = { name: momentsUsername, avatar: momentsAvatar };
                } else {
                    author = characters.find(c => c.id === moment.authorId);
                }

                if (!author) return; // 如果找不到作者信息，则不渲染

                const momentCard = document.createElement('div');
                momentCard.className = 'moment-card';
                momentCard.innerHTML = `
                    <div class="flex items-start">
                        <div class="w-10 h-10 rounded-full mr-3 flex-shrink-0 bg-cover bg-center cursor-pointer overflow-hidden" style="background-image: url(${author.avatar || 'https://placehold.co/96x96/777/FFF?text=?_'})" data-author-id="${moment.authorId}"></div>
                        <div class="flex-grow">
                            <p class="font-bold text-blue-400">${author.name}</p>
                            <p class="mt-2 whitespace-pre-wrap">${moment.content}</p>
                            ${moment.image ? `<div class="moment-image mt-3" style="background-image: url(${moment.image})"></div>` : ''}
                            
                            <!-- 点赞和评论统计 -->
                            <div class="mt-3 flex items-center space-x-4 text-sm text-gray-500">
                                ${moment.likes && moment.likes.count > 0 ? `<span class="flex items-center"><i class="ri-thumb-up-fill text-blue-500 mr-1"></i>${moment.likes.count}</span>` : ''}
                                ${moment.comments && moment.comments.length > 0 ? `<span class="flex items-center"><i class="ri-chat-3-line mr-1"></i>${moment.comments.length}条评论</span>` : ''}
                            </div>
                            
                            <!-- 评论列表 -->
                            ${moment.comments && moment.comments.length > 0 ? `
                                <div class="mt-3 space-y-2">
                                    ${moment.comments.map(comment => `
                                        <div class="flex items-start space-x-2 bg-gray-50 rounded-lg p-2">
                                            <span class="font-medium text-blue-500 text-sm">${comment.author}:</span>
                                            <span class="text-sm text-gray-700">${comment.content}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                            
                            <div class="mt-3 flex justify-between items-center">
                                <p class="text-xs text-gray-400">${new Date(moment.timestamp).toLocaleString()}</p>
                                <div class="moment-actions flex items-center space-x-4 text-gray-400">
                                    <button class="moment-action-btn ${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? 'text-blue-500' : ''} hover:text-blue-500 transition-colors" data-moment-id="${moment.id}" onclick="likeMoment('${moment.id}')" title="${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? '取消点赞' : '点赞'}">
                                        <i class="${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? 'ri-thumb-up-fill' : 'ri-thumb-up-line'}"></i>
                                    </button>
                                    <button class="moment-action-btn hover:text-blue-500 transition-colors" data-moment-id="${moment.id}" onclick="commentMoment('${moment.id}')" title="评论">
                                        <i class="ri-chat-3-line"></i>
                                    </button>
                                    <button class="moment-action-btn text-red-400 hover:text-red-600 hover:bg-red-50 px-2 py-1 rounded transition-all duration-200" data-moment-id="${moment.id}" onclick="deleteMoment('${moment.id}')" title="删除这条动态"><i class="ri-delete-bin-line"></i></button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                feedContainer.appendChild(momentCard);
            });
        }
        
        // 打开"发布动态"模态框 - 只能发布用户动态
        function openPostMomentModal() {
            const modal = $('#post-moment-modal');
            const authorSelect = $('#moment-author-select');
            
            // 只显示用户选项，角色不能通过此按钮发布动态
            const momentsUsername = loadData('moments_username') || '我';
            authorSelect.innerHTML = `<option value="user">${momentsUsername}</option>`;
            
            // 隐藏角色选择器，因为用户只能发布自己的动态
            authorSelect.style.display = 'none';
            
            // 更新标题，明确这是用户发布动态
            const title = modal.querySelector('h3');
            title.textContent = '发布我的动态';

            // 重置输入框
            $('#moment-content-input').value = '';
            $('#moment-image-label').textContent = '添加图片 (可选)';
            tempMomentImage = null;

            modal.classList.add('visible');
        }

        // --- 日记 (Diary) 新增函数 ---
        let currentOpenBook = { ownerId: null, entries: [], currentPage: 0 };
        let tempDiaryCoverImage = null; // 用于暂存日记本封面图片
        
        // 显示日记书架
        function showDiaryBookshelf() {
            const bookshelf = $('#diary-bookshelf');
            bookshelf.innerHTML = '';
            
            const colors = ['#000000', '#000000', '#000000', '#000000', '#000000', '#000000'];
            let colorIndex = 0;

            // 添加"我的日记"
            const myDiaryItem = document.createElement('div');
            myDiaryItem.className = 'diary-book-item';
            myDiaryItem.dataset.ownerId = 'user';
            myDiaryItem.style.backgroundColor = colors[colorIndex % colors.length];
            
            // 检查是否有自定义封面
            const savedCover = loadData('diary_cover_user');
            if (savedCover) {
                myDiaryItem.style.backgroundImage = `url(${savedCover})`;
                myDiaryItem.style.backgroundSize = 'cover';
                myDiaryItem.style.backgroundPosition = 'center';
            }
            
            myDiaryItem.innerHTML = `
                <span class="diary-book-item-title">My Diary</span>
                <span class="diary-book-item-author">Me</span>
                <button class="diary-cover-edit-btn" data-owner-id="user"><i class="ri-image-edit-line"></i></button>
            `;
            bookshelf.appendChild(myDiaryItem);
            colorIndex++;

            // 添加角色的日记
            characters.forEach(char => {
                const charDiaryItem = document.createElement('div');
                charDiaryItem.className = 'diary-book-item';
                charDiaryItem.dataset.ownerId = char.id;
                charDiaryItem.style.backgroundColor = colors[colorIndex % colors.length];
                
                // 检查是否有自定义封面
                const savedCover = loadData(`diary_cover_${char.id}`);
                if (savedCover) {
                    charDiaryItem.style.backgroundImage = `url(${savedCover})`;
                    charDiaryItem.style.backgroundSize = 'cover';
                    charDiaryItem.style.backgroundPosition = 'center';
                }
                
                charDiaryItem.innerHTML = `
                    <span class="diary-book-item-title">${char.name}'s Diary</span>
                    <span class="diary-book-item-author">${char.name}</span>
                    <button class="diary-cover-edit-btn" data-owner-id="${char.id}"><i class="ri-image-edit-line"></i></button>
                `;
                bookshelf.appendChild(charDiaryItem);
                colorIndex++;
            });

            // 添加用户创建的笔记本
            Object.keys(notebookData).forEach(notebookId => {
                const notebook = notebookData[notebookId];
                const notebookItem = document.createElement('div');
                notebookItem.className = 'diary-book-item notebook-item';
                notebookItem.dataset.notebookId = notebookId;
                notebookItem.style.backgroundColor = colors[colorIndex % colors.length];
                
                // 检查是否有自定义封面
                if (notebook.cover) {
                    notebookItem.style.backgroundImage = `url(${notebook.cover})`;
                    notebookItem.style.backgroundSize = 'cover';
                    notebookItem.style.backgroundPosition = 'center';
                }
                
                notebookItem.innerHTML = `
                    <span class="diary-book-item-title">${notebook.name}</span>
                    <span class="diary-book-item-author">${notebook.type}</span>
                    <div class="notebook-actions">
                        <button class="notebook-edit-btn" data-notebook-id="${notebookId}" title="编辑笔记本"><i class="ri-edit-line"></i></button>
                        <button class="notebook-delete-btn" data-notebook-id="${notebookId}" title="删除笔记本"><i class="ri-delete-bin-line"></i></button>
                    </div>
                `;
                bookshelf.appendChild(notebookItem);
                colorIndex++;
            });
        }

        // 打开指定的日记本
        function openDiaryBook(ownerId) {
            let ownerName;
            if(ownerId === 'user') {
                ownerName = "我";
            } else {
                const character = characters.find(c => c.id === ownerId);
                if (!character) return;
                ownerName = character.name;
            }

            currentOpenBook.ownerId = ownerId;
            currentOpenBook.entries = (diaryData[ownerId] || []).slice().reverse(); // 最新日记在前
            currentOpenBook.currentPage = 0;
            currentOpenBook.isNotebook = false; // 标记为日记本

            $('#diary-cover-title').textContent = `${ownerName}的日记`;
            $('#diary-cover-author').textContent = `by ${ownerName}`;
            
            // 设置封面图片
            const savedCover = loadData(`diary_cover_${ownerId}`);
            if (savedCover) {
                $('#diary-book-cover').style.backgroundImage = `url(${savedCover})`;
                $('#diary-book-cover').style.backgroundSize = 'cover';
                $('#diary-book-cover').style.backgroundPosition = 'center';
            } else {
                $('#diary-book-cover').style.backgroundImage = '';
                $('#diary-book-cover').style.backgroundColor = '#3a3a3a';
            }
            
            renderDiaryPages();

            $('#diary-book-modal').classList.remove('hidden');
            $('#diary-book').classList.remove('open'); // 确保书是合上的
        }

        // 渲染日记页面内容
        // 渲染日记页面内容 - 单页显示
        function renderDiaryPages() {
            const pagesContainer = $('#diary-pages-container');
            
            // 清空容器
            pagesContainer.innerHTML = '';
            
            // 获取当前页的日记条目
            const currentEntry = currentOpenBook.entries[currentOpenBook.currentPage];
            
            if (currentEntry) {
                // 显示当前页的日记内容
                pagesContainer.innerHTML = `
                    <div class="diary-page-content">
                        <div class="diary-page-header">
                            <p class="diary-page-date">${new Date(currentEntry.timestamp).toLocaleDateString()}</p>
                            <button class="diary-delete-btn" title="删除此日记" onclick="deleteDiaryEntry('${currentEntry.id}')">
                                <i class="ri-delete-bin-line"></i>
                            </button>
                        </div>
                        <p class="diary-page-text" contenteditable="true" data-entry-id="${currentEntry.id}">${currentEntry.content.replace(/\n/g, '<br>')}</p>
                    </div>`;
            } else {
                // 如果没有内容，显示空页面提示
                pagesContainer.innerHTML = `
                    <div class="diary-page-content">
                        <p class="diary-page-date">${new Date().toLocaleDateString()}</p>
                        <p class="diary-page-text" style="text-align: center; color: #999; margin-top: 2rem;">
                            这是第 ${currentOpenBook.currentPage + 1} 页<br>
                            点击右下角 + 按钮添加新日记
                        </p>
                    </div>`;
            }
            
            // 添加页码显示
            const pageNumber = document.createElement('div');
            pageNumber.className = 'diary-page-number';
            pageNumber.textContent = `${currentOpenBook.currentPage + 1} / ${currentOpenBook.entries.length}`;
            pagesContainer.appendChild(pageNumber);
            
            // 更新翻页按钮状态
            if (currentOpenBook && currentOpenBook.entries) {
                $('#prev-page-btn').style.visibility = currentOpenBook.currentPage > 0 ? 'visible' : 'hidden';
                $('#next-page-btn').style.visibility = currentOpenBook.currentPage < currentOpenBook.entries.length - 1 ? 'visible' : 'hidden';
            } else {
                $('#prev-page-btn').style.visibility = 'hidden';
                $('#next-page-btn').style.visibility = 'hidden';
            }
        }

        // 添加日记条目
        function addDiaryEntry(ownerId, content) {
            if (!diaryData[ownerId]) {
                diaryData[ownerId] = [];
            }
            
            // 如果是笔记本，添加到笔记本数据
            if (currentOpenBook.isNotebook) {
                if (!currentOpenBook.notebookData.entries) {
                    currentOpenBook.notebookData.entries = [];
                }
                currentOpenBook.notebookData.entries.push(content);
                currentOpenBook.notebookData.lastModified = Date.now();
                saveData('notebookData', notebookData);
            }
        }

        // 删除日记条目
        function deleteDiaryEntry(entryId) {
            if (!currentOpenBook || !currentOpenBook.entries) return;
            
            // 确认删除
            if (!confirm('确定要删除这条日记吗？此操作无法撤销。')) {
                return;
            }
            
            // 找到要删除的条目索引
            const entryIndex = currentOpenBook.entries.findIndex(entry => entry.id === entryId);
            if (entryIndex === -1) return;
            
            // 删除条目
            currentOpenBook.entries.splice(entryIndex, 1);
            
            // 如果是笔记本，更新笔记本数据
            if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                currentOpenBook.notebookData.entries = currentOpenBook.entries;
                currentOpenBook.notebookData.lastModified = Date.now();
                saveData('notebookData', notebookData);
            } else {
                // 更新日记数据
                if (currentOpenBook.ownerId) {
                    diaryData[currentOpenBook.ownerId] = currentOpenBook.entries;
                    saveData('diaryData', diaryData);
                }
            }
            
            // 调整当前页码
            if (currentOpenBook.entries.length === 0) {
                // 如果没有条目了，关闭日记本
                $('#diary-book-modal').classList.add('hidden');
                showMessageBox('日记本已清空');
                return;
            }
            
            // 如果删除的是最后一页，且当前页超出范围，调整到最后一页
            if (currentOpenBook.currentPage >= currentOpenBook.entries.length) {
                currentOpenBook.currentPage = currentOpenBook.entries.length - 1;
            }
            
            // 刷新显示
            renderDiaryPages();
            showMessageBox('日记已删除');
        }

        // 创建日记页面
        // 创建日记页面 - 现在使用单页显示，此函数已简化
        function createDiaryPage(content, entry, isNew = false) {
            // 现在直接返回空元素，因为页面内容由 renderDiaryPages 处理
            const page = document.createElement('div');
            page.className = 'diary-page-placeholder';
            return page;
        }

        // 保存日记页面内容
        function saveDiaryPage(textarea) {
            const content = textarea.value.trim();
            if (!content) return;
            
            const entryId = textarea.dataset.entryId;
            
            if (entryId) {
                // 更新现有日记
                const entry = currentOpenBook.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.content = content;
                    entry.lastModified = Date.now();
                }
            } else {
                // 创建新日记
                const newEntry = {
                    id: `diary_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    lastModified: Date.now()
                };
                
                if (!currentOpenBook.entries) currentOpenBook.entries = [];
                currentOpenBook.entries.push(newEntry);
                
                if (currentOpenBook.isNotebook) {
                    // 如果是笔记本，更新笔记本数据
                    currentOpenBook.notebookData.entries = currentOpenBook.entries;
                    currentOpenBook.notebookData.lastModified = Date.now();
                    saveData('notebookData', notebookData);
                    showMessageBox('笔记本内容已保存！');
                } else {
                    // 更新日记数据
                    if (!diaryData[currentOpenBook.ownerId]) {
                        diaryData[currentOpenBook.ownerId] = [];
                    }
                    diaryData[currentOpenBook.ownerId].push(newEntry);
                    saveData('diaryData', diaryData);
                    showMessageBox('日记已保存！');
                }
                
                // 刷新显示
                renderDiaryPages();
            }
        }

        // 更新日记条目
        function updateDiaryEntry(entryId, newContent) {
            // 先检查是否是笔记本条目
            if (currentOpenBook.isNotebook) {
                const entryIndex = currentOpenBook.entries.findIndex(entry => entry.id === entryId);
                if (entryIndex !== -1) {
                    currentOpenBook.entries[entryIndex].content = newContent;
                    currentOpenBook.notebookData.entries = currentOpenBook.entries;
                    currentOpenBook.notebookData.lastModified = Date.now();
                    saveData('notebookData', notebookData);
                    return;
                }
            }
            
            // 检查日记数据
            Object.keys(diaryData).forEach(ownerId => {
                const entryIndex = diaryData[ownerId].findIndex(entry => entry.id === entryId);
                if (entryIndex !== -1) {
                    diaryData[ownerId][entryIndex].content = newContent;
                    saveData('diaryData', diaryData);
                    return;
                }
            });
        }

        // 更换日记本封面
        function changeDiaryCover(ownerId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedDataUrl = await compressImage(file, { maxWidth: 400, maxHeight: 400 });
                        saveData(`diary_cover_${ownerId}`, compressedDataUrl);
                        showDiaryBookshelf(); // 刷新书架显示
                        showMessageBox('日记本封面已更新');
                    } catch (error) {
                        showMessageBox('封面图片处理失败');
                    }
                }
            };
            input.click();
        }

        // 创建新笔记本
        function createNewNotebook() {
            // 显示创建笔记本模态框
            $('#new-notebook-modal').classList.remove('hidden');
            
            // 重置表单
            $('#new-notebook-name').value = '';
            $('#new-notebook-type').value = 'diary';
            $('#custom-notebook-type').value = '';
            $('#custom-type-container').classList.add('hidden');
            
            // 聚焦到名称输入框
            setTimeout(() => {
                $('#new-notebook-name').focus();
            }, 100);
        }

        // 处理笔记本类型选择变化
        function handleNotebookTypeChange() {
            const typeSelect = $('#new-notebook-type');
            const customContainer = $('#custom-type-container');
            
            if (typeSelect.value === 'custom') {
                customContainer.classList.remove('hidden');
                $('#custom-notebook-type').focus();
            } else {
                customContainer.classList.add('hidden');
            }
        }

        // 确认创建新笔记本
        function confirmCreateNotebook() {
            const name = $('#new-notebook-name').value.trim();
            const type = $('#new-notebook-type').value;
            let customType = '';
            
            if (!name) {
                showMessageBox('请输入笔记本名称');
                return;
            }
            
            if (type === 'custom') {
                customType = $('#custom-notebook-type').value.trim();
                if (!customType) {
                    showMessageBox('请输入自定义类型名称');
                    return;
                }
            }
            
            // 生成笔记本ID
            const notebookId = `notebook_${Date.now()}`;
            
            // 创建笔记本数据结构
            const newNotebook = {
                id: notebookId,
                name: name,
                type: type === 'custom' ? customType : type,
                created: Date.now(),
                lastModified: Date.now(),
                entries: [],
                cover: null
            };
            
            // 保存到本地存储
            if (!notebookData) {
                notebookData = {};
            }
            notebookData[notebookId] = newNotebook;
            saveData('notebookData', notebookData);
            
            // 关闭模态框
            $('#new-notebook-modal').classList.add('hidden');
            
            // 显示成功消息
            showMessageBox(`笔记本"${name}"创建成功！`);
            
            // 刷新书架显示
            showDiaryBookshelf();
        }

        // ====== 画板功能 ======
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = '#000000';
        let currentBrushSize = 5;

        // 初始化画板
        function initDrawingBoard() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置画布背景为白色
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 设置默认画笔样式
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentBrushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        // 画板事件监听器
        function setupDrawingBoard() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            
            // 鼠标按下事件
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                lastX = e.clientX - rect.left;
                lastY = e.clientY - rect.top;
            });
            
            // 鼠标移动事件
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                lastX = currentX;
                lastY = currentY;
            });
            
            // 鼠标松开事件
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });
            
            // 鼠标离开画布事件
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });
            
            // 触摸事件支持
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                lastX = touch.clientX - rect.left;
                lastY = touch.clientY - rect.top;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const currentX = touch.clientX - rect.left;
                const currentY = touch.clientY - rect.top;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                lastX = currentX;
                lastY = currentY;
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDrawing = false;
            });
        }

        // 颜色选择
        function setupColorPalette() {
            const colorSwatches = document.querySelectorAll('.color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', () => {
                    currentColor = swatch.dataset.color;
                    const canvas = document.getElementById('drawing-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.strokeStyle = currentColor;
                    
                    // 更新选中状态
                    colorSwatches.forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                });
            });
            
            // 默认选中黑色
            colorSwatches[0].classList.add('selected');
        }

        // 画笔大小控制
        function setupBrushControls() {
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            
            brushSizeSlider.addEventListener('input', (e) => {
                currentBrushSize = parseInt(e.target.value);
                brushSizeValue.textContent = currentBrushSize + 'px';
                
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                ctx.lineWidth = currentBrushSize;
            });
        }

        // 清空画布
        function clearCanvas() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // 发送画作
        async function sendDrawing() {
            const canvas = document.getElementById('drawing-canvas');
            const dataURL = canvas.toDataURL('image/png');
            
            // 将画作作为图片消息发送
            appendMessage(dataURL, 'user', 'image', true, Date.now(), true);
            
            // 关闭画板
            closeDrawingBoard();
            
            // 清空画布
            clearCanvas();
        }

        // 打开画板
        function openDrawingBoard() {
            const modal = document.getElementById('drawing-board-modal');
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            // 初始化画板
            initDrawingBoard();
        }

        // 关闭画板
        function closeDrawingBoard() {
            const modal = document.getElementById('drawing-board-modal');
            modal.classList.remove('visible');
            modal.classList.add('hidden');
        }

        // 设置画板事件监听器
        function setupDrawingBoardEvents() {
            // 画板按钮点击事件（在更多功能面板中）
            const drawingBoardBtn = document.getElementById('drawing-board-btn');
            if (drawingBoardBtn) {
                drawingBoardBtn.addEventListener('click', openDrawingBoard);
            }
            
            // 关闭按钮事件
            const closeBtn = document.getElementById('close-drawing-board');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeDrawingBoard);
            }
            
            // 清空画布按钮事件
            const clearBtn = document.getElementById('clear-canvas');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearCanvas);
            }
            
            // 发送画作按钮事件
            const sendBtn = document.getElementById('send-drawing');
            if (sendBtn) {
                sendBtn.addEventListener('click', sendDrawing);
            }
            
            // 点击遮罩层关闭画板
            const modal = document.getElementById('drawing-board-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'drawing-board-modal') {
                        closeDrawingBoard();
                    }
                });
            }
        }

        // ====== 塔罗牌功能 ======
        // 塔罗牌数据
        const tarotCards = [
            // 大阿卡纳 (22张)
            {
                name: "愚者",
                meaning: "新的开始、冒险、纯真、自发性、自由",
                reverseMeaning: "鲁莽、不负责任、过度冒险、缺乏计划",
                image: "🃏"
            },
            {
                name: "魔术师",
                meaning: "创造力、技能、意志力、自信、机会",
                reverseMeaning: "技能不足、机会错失、缺乏自信、滥用权力",
                image: "🔮"
            },
            {
                name: "女祭司",
                meaning: "直觉、神秘、内在知识、智慧、秘密",
                reverseMeaning: "隐藏的动机、表面化、缺乏深度、过度理性",
                image: "🌙"
            },
            {
                name: "女皇",
                meaning: "丰收、母性、创造力、自然、富足",
                reverseMeaning: "过度保护、依赖、缺乏创造力、物质主义",
                image: "👑"
            },
            {
                name: "皇帝",
                meaning: "权威、领导力、控制、稳定、成就",
                reverseMeaning: "专制、控制欲、缺乏灵活性、过度控制",
                image: "⚜️"
            },
            {
                name: "教皇",
                meaning: "传统、教育、信仰、精神指导、道德",
                reverseMeaning: "教条主义、缺乏独立思考、过度依赖权威",
                image: "⛪"
            },
            {
                name: "恋人",
                meaning: "爱情、和谐、关系、选择、价值观",
                reverseMeaning: "不和谐、价值观冲突、选择困难、分离",
                image: "💕"
            },
            {
                name: "战车",
                meaning: "胜利、意志力、决心、成功、控制",
                reverseMeaning: "缺乏方向、失控、失败、意志薄弱",
                image: "🏛️"
            },
            {
                name: "力量",
                meaning: "内在力量、勇气、耐心、控制、温和",
                reverseMeaning: "缺乏自信、软弱、过度控制、缺乏耐心",
                image: "🦁"
            },
            {
                name: "隐者",
                meaning: "内省、寻找、孤独、内在指导、智慧",
                reverseMeaning: "过度孤独、缺乏指导、迷失方向、拒绝帮助",
                image: "🧭"
            },
            {
                name: "命运之轮",
                meaning: "变化、命运、转折点、机会、周期",
                reverseMeaning: "坏运气、错失机会、停滞、无法改变",
                image: "🎡"
            },
            {
                name: "正义",
                meaning: "公平、真理、诚实、因果、平衡",
                reverseMeaning: "不公、欺骗、不平衡、缺乏正义",
                image: "⚖️"
            },
            {
                name: "倒吊人",
                meaning: "牺牲、暂停、新视角、顺从、启示",
                reverseMeaning: "无意义的牺牲、停滞、缺乏进展、浪费时间",
                image: "🙃"
            },
            {
                name: "死神",
                meaning: "结束、转变、重生、释放、改变",
                reverseMeaning: "抗拒改变、停滞、无法前进、恐惧",
                image: "💀"
            },
            {
                name: "节制",
                meaning: "平衡、适度、耐心、和谐、自我控制",
                reverseMeaning: "过度、不平衡、缺乏耐心、失控",
                image: "🍷"
            },
            {
                name: "恶魔",
                meaning: "束缚、物质主义、欲望、阴影、诱惑",
                reverseMeaning: "释放、摆脱束缚、面对阴影、觉醒",
                image: "👿"
            },
            {
                name: "高塔",
                meaning: "突然变化、混乱、启示、破坏、解放",
                reverseMeaning: "避免灾难、逐渐改变、重建、稳定",
                image: "🗼"
            },
            {
                name: "星星",
                meaning: "希望、信心、目的、更新、精神意识",
                reverseMeaning: "缺乏信心、绝望、失去方向、悲观",
                image: "⭐"
            },
            {
                name: "月亮",
                meaning: "直觉、潜意识、恐惧、幻想、迷惑",
                reverseMeaning: "释放恐惧、清晰、真相、内在平静",
                image: "🌙"
            },
            {
                name: "太阳",
                meaning: "成功、喜悦、活力、真理、成功",
                reverseMeaning: "暂时困难、过度自信、表面成功、内在空虚",
                image: "☀️"
            },
            {
                name: "审判",
                meaning: "重生、内在呼唤、释放、救赎、觉醒",
                reverseMeaning: "自我怀疑、拒绝改变、缺乏觉醒、停滞",
                image: "📯"
            },
            {
                name: "世界",
                meaning: "完成、整合、成就、旅行、和谐",
                reverseMeaning: "未完成、缺乏整合、延迟、不和谐",
                image: "🌍"
            },
            
            // 小阿卡纳 - 权杖系列 (14张)
            {
                name: "权杖王牌",
                meaning: "新的开始、灵感、创造力、机会、潜力",
                reverseMeaning: "错失机会、缺乏灵感、延迟、未实现的潜力",
                image: "🔥"
            },
            {
                name: "权杖二",
                meaning: "选择、平衡、合作、伙伴关系、决策",
                reverseMeaning: "优柔寡断、不平衡、缺乏合作、错误选择",
                image: "⚖️"
            },
            {
                name: "权杖三",
                meaning: "团队合作、扩展、成长、合作、计划",
                reverseMeaning: "缺乏合作、计划失败、过度扩张、团队冲突",
                image: "🤝"
            },
            {
                name: "权杖四",
                meaning: "庆祝、和谐、家庭、稳定、成功",
                reverseMeaning: "缺乏庆祝、家庭冲突、不稳定、成功延迟",
                image: "🎉"
            },
            {
                name: "权杖五",
                meaning: "冲突、竞争、挑战、成长、学习",
                reverseMeaning: "避免冲突、缺乏竞争、逃避挑战、停滞不前",
                image: "⚔️"
            },
            {
                name: "权杖六",
                meaning: "胜利、成功、好消息、认可、进步",
                reverseMeaning: "延迟成功、缺乏认可、坏消息、停滞",
                image: "🏆"
            },
            {
                name: "权杖七",
                meaning: "防御、坚持、挑战、保护、决心",
                reverseMeaning: "过度防御、缺乏坚持、放弃、脆弱",
                image: "🛡️"
            },
            {
                name: "权杖八",
                meaning: "快速行动、变化、消息、旅行、进展",
                reverseMeaning: "延迟、停滞、坏消息、旅行取消、缺乏进展",
                image: "🚀"
            },
            {
                name: "权杖九",
                meaning: "准备、防御、经验、智慧、警惕",
                reverseMeaning: "缺乏准备、过度防御、缺乏经验、粗心",
                image: "🎯"
            },
            {
                name: "权杖十",
                meaning: "负担、责任、压力、努力、成就",
                reverseMeaning: "减轻负担、缺乏责任、逃避压力、懒惰",
                image: "💼"
            },
            {
                name: "权杖侍从",
                meaning: "新消息、学习、探索、热情、冒险",
                reverseMeaning: "坏消息、缺乏学习、缺乏热情、过度谨慎",
                image: "📚"
            },
            {
                name: "权杖骑士",
                meaning: "行动、冒险、热情、冲动、变化",
                reverseMeaning: "延迟、缺乏行动、缺乏热情、过度谨慎",
                image: "🐎"
            },
            {
                name: "权杖皇后",
                meaning: "独立、热情、创造力、自信、魅力",
                reverseMeaning: "依赖、缺乏热情、缺乏创造力、缺乏自信",
                image: "👸"
            },
            {
                name: "权杖国王",
                meaning: "领导力、热情、创造力、自信、成功",
                reverseMeaning: "缺乏领导力、缺乏热情、缺乏创造力、失败",
                image: "👑"
            },
            
            // 小阿卡纳 - 圣杯系列 (14张)
            {
                name: "圣杯王牌",
                meaning: "新的情感、爱、直觉、创造力、灵感",
                reverseMeaning: "情感封闭、缺乏爱、缺乏直觉、缺乏灵感",
                image: "💧"
            },
            {
                name: "圣杯二",
                meaning: "伙伴关系、爱情、和谐、选择、平衡",
                reverseMeaning: "分离、不和谐、缺乏选择、不平衡",
                image: "💕"
            },
            {
                name: "圣杯三",
                meaning: "庆祝、友谊、欢乐、合作、成功",
                reverseMeaning: "缺乏庆祝、孤独、悲伤、缺乏合作",
                image: "🎊"
            },
            {
                name: "圣杯五",
                meaning: "失望、悲伤、损失、遗憾、悲观",
                reverseMeaning: "希望、恢复、新机会、乐观、接受",
                image: "😔"
            },
            {
                name: "圣杯六",
                meaning: "怀旧、回忆、重逢、和谐、童年",
                reverseMeaning: "缺乏怀旧、分离、不和谐、成长",
                image: "🏠"
            },
            {
                name: "圣杯七",
                meaning: "选择、幻想、诱惑、困惑、决策",
                reverseMeaning: "清晰、现实、避免诱惑、明确选择",
                image: "🌈"
            },
            {
                name: "圣杯八",
                meaning: "离开、寻找、改变、进步、新开始",
                reverseMeaning: "停滞、缺乏改变、缺乏进步、恐惧",
                image: "🚶"
            },
            {
                name: "圣杯九",
                meaning: "满足、愿望实现、成功、幸福、富足",
                reverseMeaning: "不满足、愿望未实现、失败、缺乏",
                image: "🎁"
            },
            {
                name: "圣杯十",
                meaning: "家庭和谐、幸福、圆满、爱、满足",
                reverseMeaning: "家庭冲突、不幸福、不圆满、缺乏爱",
                image: "🏡"
            },
            {
                name: "圣杯侍从",
                meaning: "新消息、学习、创造力、灵感、机会",
                reverseMeaning: "坏消息、缺乏学习、缺乏创造力、错失机会",
                image: "📖"
            },
            {
                name: "圣杯骑士",
                meaning: "浪漫、提议、邀请、创意、魅力",
                reverseMeaning: "缺乏浪漫、拒绝、缺乏创意、缺乏魅力",
                image: "🌹"
            },
            {
                name: "圣杯皇后",
                meaning: "爱、关怀、直觉、创造力、同情心",
                reverseMeaning: "缺乏爱、缺乏关怀、缺乏直觉、冷漠",
                image: "👸"
            },
            {
                name: "圣杯国王",
                meaning: "情感成熟、智慧、同情心、创造力、领导力",
                reverseMeaning: "情感不成熟、缺乏智慧、缺乏同情心",
                image: "👑"
            },
            
            // 小阿卡纳 - 宝剑系列 (14张)
            {
                name: "宝剑王牌",
                meaning: "新的想法、清晰、真理、突破、力量",
                reverseMeaning: "混乱、缺乏清晰、缺乏真理、缺乏力量",
                image: "⚔️"
            },
            {
                name: "宝剑二",
                meaning: "平衡、选择、和谐、决策、和平",
                reverseMeaning: "不平衡、缺乏选择、不和谐、冲突",
                image: "⚖️"
            },
            {
                name: "宝剑三",
                meaning: "心痛、悲伤、分离、背叛、痛苦",
                reverseMeaning: "恢复、和解、团聚、信任、治愈",
                image: "💔"
            },
            {
                name: "宝剑四",
                meaning: "休息、恢复、冥想、和平、内省",
                reverseMeaning: "缺乏休息、过度劳累、缺乏和平、焦虑",
                image: "😴"
            },
            {
                name: "宝剑五",
                meaning: "失败、损失、冲突、挫折、竞争",
                reverseMeaning: "成功、胜利、和解、合作、避免冲突",
                image: "🏃"
            },
            {
                name: "宝剑六",
                meaning: "过渡、改变、进步、离开、新开始",
                reverseMeaning: "停滞、缺乏改变、缺乏进步、恐惧",
                image: "🚢"
            },
            {
                name: "宝剑七",
                meaning: "欺骗、秘密、策略、隐藏动机、逃避",
                reverseMeaning: "诚实、真相、直接、面对问题、勇气",
                image: "🕵️"
            },
            {
                name: "宝剑八",
                meaning: "困境、限制、无助、恐惧、束缚",
                reverseMeaning: "解脱、自由、希望、勇气、突破",
                image: "🔒"
            },
            {
                name: "宝剑九",
                meaning: "焦虑、恐惧、担忧、噩梦、压力",
                reverseMeaning: "平静、希望、信心、放松、解脱",
                image: "😰"
            },
            {
                name: "宝剑十",
                meaning: "结束、失败、痛苦、背叛、绝望",
                reverseMeaning: "新开始、希望、恢复、重生、机会",
                image: "💀"
            },
            {
                name: "宝剑侍从",
                meaning: "新想法、学习、消息、好奇心、观察",
                reverseMeaning: "缺乏想法、缺乏学习、坏消息、缺乏好奇心",
                image: "📝"
            },
            {
                name: "宝剑骑士",
                meaning: "行动、冲突、勇气、冲动、变化",
                reverseMeaning: "延迟、避免冲突、缺乏勇气、过度谨慎",
                image: "⚔️"
            },
            {
                name: "宝剑皇后",
                meaning: "智慧、独立、清晰、真理、力量",
                reverseMeaning: "缺乏智慧、依赖、混乱、谎言、软弱",
                image: "👸"
            },
            {
                name: "宝剑国王",
                meaning: "权威、智慧、真理、正义、领导力",
                reverseMeaning: "缺乏权威、缺乏智慧、不公、缺乏领导力",
                image: "👑"
            },
            
            // 小阿卡纳 - 金币系列 (14张)
            {
                name: "金币王牌",
                meaning: "新的机会、财富、物质成功、繁荣、潜力",
                reverseMeaning: "错失机会、缺乏财富、物质失败、缺乏潜力",
                image: "💰"
            },
            {
                name: "金币二",
                meaning: "平衡、适应、灵活性、变化、学习",
                reverseMeaning: "不平衡、缺乏适应、缺乏灵活性、停滞",
                image: "🎭"
            },
            {
                name: "金币三",
                meaning: "技能、学习、成长、合作、进步",
                reverseMeaning: "缺乏技能、缺乏学习、缺乏成长、缺乏合作",
                image: "🔨"
            },
            {
                name: "金币四",
                meaning: "安全、稳定、保守、保护、财富",
                reverseMeaning: "不安全、不稳定、冒险、损失、缺乏保护",
                image: "🏰"
            },
            {
                name: "金币五",
                meaning: "困难、贫困、疾病、孤独、挑战",
                reverseMeaning: "改善、健康、陪伴、克服困难、希望",
                image: "🏥"
            },
            {
                name: "金币六",
                meaning: "慷慨、给予、帮助、慈善、成功",
                reverseMeaning: "自私、缺乏给予、缺乏帮助、失败",
                image: "🎁"
            },
            {
                name: "金币七",
                meaning: "耐心、投资、长期规划、成长、等待",
                reverseMeaning: "缺乏耐心、短期思维、缺乏规划、停滞",
                image: "🌱"
            },
            {
                name: "金币八",
                meaning: "技能发展、学习、进步、专注、成长",
                reverseMeaning: "缺乏技能、缺乏学习、缺乏进步、分心",
                image: "⚒️"
            },
            {
                name: "金币九",
                meaning: "独立、自给自足、成功、享受、富足",
                reverseMeaning: "依赖、缺乏自给自足、失败、缺乏享受",
                image: "🏡"
            },
            {
                name: "金币十",
                meaning: "家庭财富、传承、传统、成功、圆满",
                reverseMeaning: "家庭困难、缺乏传承、缺乏传统、失败",
                image: "🏠"
            },
            {
                name: "金币侍从",
                meaning: "新机会、学习、消息、好奇心、潜力",
                reverseMeaning: "错失机会、缺乏学习、坏消息、缺乏潜力",
                image: "📚"
            },
            {
                name: "金币骑士",
                meaning: "实用、可靠、耐心、勤奋、进步",
                reverseMeaning: "不实用、不可靠、缺乏耐心、懒惰",
                image: "🐎"
            },
            {
                name: "金币皇后",
                meaning: "富足、实用、关怀、繁荣、成功",
                reverseMeaning: "缺乏、不实用、缺乏关怀、失败",
                image: "👸"
            },
            {
                name: "金币国王",
                meaning: "成功、财富、权威、实用、领导力",
                reverseMeaning: "失败、缺乏财富、缺乏权威、缺乏领导力",
                image: "👑"
            }
        ];

        let currentCard = null;
        let isCardFlipped = false;

        // 初始化塔罗牌功能
        function setupTarotCard() {
            // 塔罗牌按钮点击事件
            const tarotBtn = document.getElementById('tarot-card-btn');
            if (tarotBtn) {
                tarotBtn.addEventListener('click', openTarotModal);
            }

            // 关闭按钮事件
            const closeBtn = document.getElementById('close-tarot-modal');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeTarotModal);
            }

            // 抽牌按钮事件
            const drawBtn = document.getElementById('draw-card-btn');
            if (drawBtn) {
                drawBtn.addEventListener('click', drawTarotCard);
            }

                    // 发送塔罗牌按钮事件
        const sendBtn = document.getElementById('send-tarot-btn');
        if (sendBtn) {
            sendBtn.addEventListener('click', sendTarotCard);
        }



            // 点击遮罩层关闭塔罗牌
            const modal = document.getElementById('tarot-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'tarot-modal') {
                        closeTarotModal();
                    }
                });
            }
        }

        // 打开塔罗牌弹窗
        function openTarotModal() {
            const modal = document.getElementById('tarot-modal');
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            // 重置状态
            resetTarotCard();
        }

        // 关闭塔罗牌弹窗
        function closeTarotModal() {
            const modal = document.getElementById('tarot-modal');
            modal.classList.remove('visible');
            modal.classList.add('hidden');
        }

        // 重置塔罗牌状态
        function resetTarotCard() {
            currentCard = null;
            isCardFlipped = false;
            
            const cardDisplay = document.getElementById('tarot-card');
            const info = document.getElementById('tarot-info');
            const sendBtn = document.getElementById('send-tarot-btn');
            const drawBtn = document.getElementById('draw-card-btn');
            
            cardDisplay.className = 'tarot-card-back';
            cardDisplay.innerHTML = `
                <div class="card-back-pattern"></div>
                <div class="card-back-text">点击抽牌</div>
            `;
            
            info.style.display = 'none';
            sendBtn.style.display = 'none';
            drawBtn.style.display = 'block'; // 重新显示抽牌按钮
        }

        // 抽取塔罗牌
        function drawTarotCard() {
            if (isCardFlipped) return;
            
            // 随机选择一张牌
            const randomIndex = Math.floor(Math.random() * tarotCards.length);
            currentCard = tarotCards[randomIndex];
            
            // 随机决定正逆位
            const isReversed = Math.random() > 0.5;
            
            // 翻转卡片
            flipCard(currentCard, isReversed);
        }

        // 翻转卡片
        function flipCard(card, isReversed) {
            const cardDisplay = document.getElementById('tarot-card');
            const info = document.getElementById('tarot-info');
            const sendBtn = document.getElementById('send-tarot-btn');
            const drawBtn = document.getElementById('draw-card-btn');
            
            // 创建卡片正面
            cardDisplay.className = 'tarot-card-front';
            cardDisplay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; text-align: center;">
                    <div style="font-size: 60px; margin-bottom: 20px;">${card.image}</div>
                    <div style="font-size: 24px; font-weight: bold; color: #333; margin-bottom: 10px;">${card.name}</div>
                    <div style="font-size: 14px; color: #666; transform: ${isReversed ? 'rotate(180deg)' : 'none'};">
                        ${isReversed ? '逆位' : '正位'}
                    </div>
                </div>
            `;
            
            // 显示卡片信息
            const cardName = document.getElementById('card-name');
            const cardMeaning = document.getElementById('card-meaning');
            const orientationText = document.getElementById('orientation-text');
            
            cardName.textContent = card.name;
            cardMeaning.textContent = isReversed ? card.reverseMeaning : card.meaning;
            orientationText.textContent = isReversed ? '逆位' : '正位';
            
            info.style.display = 'block';
            sendBtn.style.display = 'block';
            drawBtn.style.display = 'none'; // 隐藏抽牌按钮
            
            isCardFlipped = true;
            
            // 添加翻转动画
            setTimeout(() => {
                cardDisplay.classList.add('flipped');
            }, 100);
        }

        // 发送塔罗牌
        function sendTarotCard() {
            if (!currentCard || !isCardFlipped) return;
            
            // 构建塔罗牌消息
            const isReversed = document.getElementById('orientation-text').textContent === '逆位';
            const cardMessage = `🔮 塔罗牌占卜结果：
            
🎴 抽到了：${currentCard.name}
${isReversed ? '🔄 逆位' : '✅ 正位'}
📖 含义：${isReversed ? currentCard.reverseMeaning : currentCard.meaning}

✨ 愿这张牌为你带来指引和启示！`;
            
            // 发送消息
            appendMessage(cardMessage, 'user', 'text', true, Date.now(), true);
            
            // 关闭弹窗
            closeTarotModal();
        }



        // --- 页面初始化时添加新的事件监听器 ---
        function addNewEventListeners() {

            // 发布动态模态框
            $('#moment-image-upload-btn').addEventListener('click', () => $('#moment-image-input').click());
            $('#moment-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    tempMomentImage = await compressImage(file, { maxWidth: 600 });
                    $('#moment-image-label').textContent = '图片已选择 ✓';
                    e.target.value = ''; // 重置输入，以便再次选择相同文件
                }
            });
            // 动态按钮事件监听器
            $('#wechat-new-moment-button').addEventListener('click', () => {
                $('#post-moment-modal').classList.add('visible');
            });
            
            $('#cancel-post-moment-btn').addEventListener('click', () => $('#post-moment-modal').classList.remove('visible'));
            $('#confirm-post-moment-btn').addEventListener('click', () => {
                // 用户只能发布自己的动态
                const authorId = 'user';
                const content = $('#moment-content-input').value.trim();

                if (!content) return showMessageBox("动态内容不能为空");

                if (!momentsData[authorId]) {
                    momentsData[authorId] = [];
                }
                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    image: tempMomentImage, // 可能为 null
                    authorId: authorId, // 明确指定作者ID
                    tags: "#日常 #分享", // 添加默认标签
                    likes: { count: 0, users: [] },
                    comments: []
                };
                momentsData[authorId].push(newMoment);
                saveData('momentsData', momentsData);

                renderUnifiedMoments();
                $('#post-moment-modal').classList.remove('visible');
                showMessageBox('动态发布成功！');
            });

            // 日记本书架点击事件
            $('#wechat-diary-container').addEventListener('click', (e) => {
                const bookItem = e.target.closest('.diary-book-item');
                if (bookItem) {
                    const ownerId = bookItem.dataset.ownerId;
                    const notebookId = bookItem.dataset.notebookId;
                    
                    if (notebookId) {
                        // 如果是笔记本，打开笔记本
                        openNotebook(notebookId);
                    } else if (ownerId) {
                        // 如果是日记本，打开日记本
                        openDiaryBook(ownerId);
                    }
                }
                
                // 封面编辑按钮点击事件
                const coverEditBtn = e.target.closest('.diary-cover-edit-btn');
                if (coverEditBtn) {
                    e.stopPropagation();
                    
                    const ownerId = coverEditBtn.closest('.diary-book-item').dataset.ownerId;
                    changeDiaryCover(ownerId);
                }
            });

            // 日记本翻页和关闭事件
            $('#prev-page-btn').addEventListener('click', () => {
                if (currentOpenBook && currentOpenBook.entries && currentOpenBook.currentPage > 0) {
                    currentOpenBook.currentPage--;
                    renderDiaryPages();
                } else {
                    // 已经是第一页了
                    showMessageBox('已经是第一页了');
                }
            });

            $('#next-page-btn').addEventListener('click', () => {
                if (currentOpenBook && currentOpenBook.entries && currentOpenBook.currentPage < currentOpenBook.entries.length - 1) {
                    currentOpenBook.currentPage++;
                    renderDiaryPages();
                } else {
                    // 已经是最后一页了
                    showMessageBox('已经是最后一页了');
                }
            });

            $('#add-page-btn').addEventListener('click', () => {
                // 添加新日记条目到当前打开的日记本
                if (currentOpenBook && currentOpenBook.entries) {
                    const newContent = prompt('请输入新的日记内容：');
                    if (newContent && newContent.trim()) {
                        // 创建新的日记条目
                        const newEntry = {
                            id: `diary_${Date.now()}`,
                            timestamp: Date.now(),
                            content: newContent.trim(),
                            lastModified: Date.now()
                        };
                        
                        // 添加到当前日记本
                        currentOpenBook.entries.push(newEntry);
                        
                        // 如果是笔记本，更新笔记本数据
                        if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                            currentOpenBook.notebookData.entries = currentOpenBook.entries;
                            currentOpenBook.notebookData.lastModified = Date.now();
                            saveData('notebookData', notebookData);
                        } else {
                            // 更新日记数据
                            if (!diaryData[currentOpenBook.ownerId]) {
                                diaryData[currentOpenBook.ownerId] = [];
                            }
                            diaryData[currentOpenBook.ownerId].push(newEntry);
                            saveData('diaryData', diaryData);
                        }
                        
                        // 跳转到新添加的页面
                        currentOpenBook.currentPage = currentOpenBook.entries.length - 1;
                        
                        // 刷新显示
                        renderDiaryPages();
                        
                        showMessageBox('新日记已添加！');
                    }
                } else {
                    // 如果没有打开的日记本，则创建新笔记本
                    createNewNotebook();
                }
            });

            // 朋友圈头像点击事件
            $('#moments-feed').addEventListener('click', (e) => {
                const avatar = e.target.closest('.w-10.h-10');
                if (avatar) {
                    const authorId = avatar.dataset.authorId;
                    if (authorId === 'user') {
                        // 用户头像点击，打开头像更换
                        $('#user-avatar-input').click();
                    } else {
                        // 角色头像点击，显示角色信息
                        const character = characters.find(c => c.id === authorId);
                        if (character) {
                            showMessageBox(`${character.name}的头像`);
                        }
                    }
                }
                
                // 动态点赞功能
                const likeBtn = e.target.closest('.moment-action-btn');
                if (likeBtn && likeBtn.querySelector('.ri-thumb-up-line')) {
                    const momentId = likeBtn.dataset.momentId;
                    likeBtn.classList.toggle('liked');
                    const icon = likeBtn.querySelector('i');
                    if (likeBtn.classList.contains('liked')) {
                        icon.className = 'ri-thumb-up-fill';
                        icon.style.color = '#ef4444';
                    } else {
                        icon.className = 'ri-thumb-up-line';
                        icon.style.color = '';
                    }
                }
            });
            
            // 朋友圈头部头像点击事件 - 已移除，现在在HTML中直接调用函数
            
            // 朋友圈事件监听器现在在切换到朋友圈标签时动态添加
            
            // 日记本翻页控制
            $('#close-diary-book-btn').addEventListener('click', () => $('#diary-book-modal').classList.add('hidden'));
            
            // 日记本文本编辑功能
            $('#diary-book-modal').addEventListener('click', (e) => {
                const editableText = e.target.closest('.diary-page-text');
                if (editableText && editableText.contentEditable === 'true') {
                    // 保存原始内容
                    const originalContent = editableText.textContent;
                    const entryId = editableText.dataset.entryId;
                    
                    // 添加保存提示
                    const saveHint = document.createElement('div');
                    saveHint.className = 'text-xs text-gray-500 mt-2';
                    saveHint.textContent = '编辑完成后按Enter保存，按Esc取消';
                    editableText.parentNode.appendChild(saveHint);
                    
                    // 处理键盘事件
                    const handleKeyDown = (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            const newContent = editableText.textContent.trim();
                            if (newContent && newContent !== originalContent) {
                                updateDiaryEntry(entryId, newContent);
                                showMessageBox('日记已保存');
                            }
                            editableText.contentEditable = false;
                            saveHint.remove();
                            editableText.removeEventListener('keydown', handleKeyDown);
                        } else if (e.key === 'Escape') {
                            editableText.textContent = originalContent;
                            editableText.contentEditable = false;
                            saveHint.remove();
                            editableText.removeEventListener('keydown', handleKeyDown);
                        }
                    };
                    
                    editableText.addEventListener('keydown', handleKeyDown);
                    editableText.focus();
                }
            });
            
            // 画板功能事件监听器
            setupDrawingBoardEvents();

            // 笔记本相关事件监听器
            setupNotebookEvents();
        }

        // 设置笔记本相关事件监听器
        function setupNotebookEvents() {
            // 笔记本类型选择变化
            $('#new-notebook-type').addEventListener('change', handleNotebookTypeChange);
            
            // 关闭新笔记本模态框
            $('#close-new-notebook-modal').addEventListener('click', () => {
                $('#new-notebook-modal').classList.add('hidden');
            });
            
            // 取消创建笔记本
            $('#cancel-new-notebook-btn').addEventListener('click', () => {
                $('#new-notebook-modal').classList.add('hidden');
            });
            
            // 确认创建笔记本
            $('#confirm-new-notebook-btn').addEventListener('click', confirmCreateNotebook);
            
            // 笔记本操作事件委托
            document.addEventListener('click', (e) => {
                // 编辑笔记本
                if (e.target.closest('.notebook-edit-btn')) {
                    const notebookId = e.target.closest('.notebook-edit-btn').dataset.notebookId;
                    editNotebook(notebookId);
                }
                
                // 删除笔记本
                if (e.target.closest('.notebook-delete-btn')) {
                    const notebookId = e.target.closest('.notebook-delete-btn').dataset.notebookId;
                    deleteNotebook(notebookId);
                }
                
                // 打开笔记本
                if (e.target.closest('.notebook-item')) {
                    const notebookId = e.target.closest('.notebook-item').dataset.notebookId;
                    if (!e.target.closest('.notebook-actions')) {
                        openNotebook(notebookId);
                    }
                }
            });
        }

        // 编辑笔记本
        function editNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            const newName = prompt('请输入新的笔记本名称：', notebook.name);
            if (newName && newName.trim() && newName !== notebook.name) {
                notebook.name = newName.trim();
                notebook.lastModified = Date.now();
                saveData('notebookData', notebookData);
                showDiaryBookshelf();
                showMessageBox('笔记本名称已更新');
            }
        }

        // 删除笔记本
        function deleteNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            if (confirm(`确定要删除笔记本"${notebook.name}"吗？此操作无法撤销。`)) {
                delete notebookData[notebookId];
                saveData('notebookData', notebookData);
                showDiaryBookshelf();
                showMessageBox('笔记本已删除');
            }
        }

        // 打开笔记本
        function openNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            // 设置当前打开的笔记本
            currentOpenBook = {
                ownerId: notebookId,
                entries: notebook.entries || [],
                currentPage: 0,
                isNotebook: true,
                notebookData: notebook
            };
            
            // 更新封面信息
            $('#diary-cover-title').textContent = notebook.name;
            $('#diary-cover-author').textContent = `by ${notebook.type}`;
            
            // 设置封面图片
            if (notebook.cover) {
                $('#diary-book-cover').style.backgroundImage = `url(${notebook.cover})`;
                $('#diary-book-cover').style.backgroundSize = 'cover';
                $('#diary-book-cover').style.backgroundPosition = 'center';
            } else {
                $('#diary-book-cover').style.backgroundImage = '';
                $('#diary-book-cover').style.backgroundColor = '#3a3a3a';
            }
            
            // 渲染页面
            renderDiaryPages();
            
            // 显示模态框
            $('#diary-book-modal').classList.remove('hidden');
            $('#diary-book').classList.remove('open');
        }

        // ------------------------------------


        // 初始化與事件監聽器
        document.addEventListener('DOMContentLoaded', async () => {
            await loadAllSavedData();
            
            // 初始化一些示例日记数据（如果还没有的话）
            if (Object.keys(diaryData).length === 0) {
                diaryData.user = [
                    {
                        id: 'diary_sample_1',
                        timestamp: Date.now() - 86400000, // 昨天
                        content: '今天天气很好，心情也不错。希望明天也能保持这样的好心情。'
                    },
                    {
                        id: 'diary_sample_2',
                        timestamp: Date.now() - 172800000, // 前天
                        content: '今天遇到了一些小困难，但是通过努力都解决了。感觉自己在成长。'
                    }
                ];
                saveData('diaryData', diaryData);
            }
            

            
            updateTime();
            setInterval(updateTime, 60000);
            


            // 加载朋友圈背景和用户信息
            loadMomentsCover();
            loadMomentsUserInfo();

            // 初始化智能朋友圈触发系统
            console.log('智能朋友圈触发系统已初始化');
            console.log('⚠️ 注意：系统需要API连接才能工作');
            console.log('触发系统功能：', {
                '对话驱动触发': '连续8句对话后可能触发（根据性格调整）',
                '情感高點觸發': '情感强度达到0.9可能触发（根据性格调整）',
                '时间流逝触发': '6小时无互动可能触发（根据性格调整）',
                '防刷机制': '最少2小时才能发下一条朋友圈',
                '性格适配': '内向角色几乎不发，外向角色经常发',
                'API要求': '必须连接API才能生成智能朋友圈'
            });

            showScreen('home-screen');

            $('#theme-toggle').addEventListener('click', toggleTheme);
            $$('.app-icon').forEach(icon => {
                icon.addEventListener('click', () => {
                    const appName = icon.dataset.appName;
                    if (appName === "微信") {
                        renderWeChatList();
                        resetWeChatTabs(); // FIX 5: Reset tabs when opening WeChat
                        showScreen('wechat-list-screen');
                    }
                    else if (appName === "世界书") { renderWorldBookList(); showScreen('world-book-list-screen'); }
                    else if (appName === "角色书") { renderCharacterBookList(); showScreen('character-book-list-screen'); }
                    else if (appName === "设置") showScreen('main-settings-screen');
                });
            });
            
            $('#wechat-list-back-button').addEventListener('click', () => {
                currentWeChatCharacterId = null; // V7.0: Clear character context
                showScreen('home-screen');
            });
            $('#wechat-chat-back-button').addEventListener('click', () => {
                renderWeChatList();
                currentChatCharacterId = null;
                resetWeChatTabs(); // FIX 5: Reset tabs when going back to list
                showScreen('wechat-list-screen');
            });
            $('#main-settings-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#api-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#api-settings-link').addEventListener('click', () => showScreen('api-settings-screen'));
            $('#wb-list-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#wb-edit-back-button').addEventListener('click', () => { renderWorldBookList(); showScreen('world-book-list-screen'); });
            $('#cb-list-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#cb-edit-back-button').addEventListener('click', () => { renderCharacterBookList(); showScreen('character-book-list-screen'); });
            $('#beautify-settings-link').addEventListener('click', () => showScreen('beautify-settings-screen'));
            $('#beautify-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#change-app-icons-link').addEventListener('click', () => {
                renderAppIconSettings();
                showScreen('app-icon-settings-screen');
            });
            $('#app-icon-settings-back-button').addEventListener('click', () => showScreen('beautify-settings-screen'));
            $('#font-settings-link').addEventListener('click', () => showScreen('font-settings-screen'));
            $('#font-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));

            $('#music-block').addEventListener('click', (e) => { if (e.target === e.currentTarget) $('#background-input').click(); });
            $('#background-input').addEventListener('change', (e) => handleImageUpload(e.target, $('#music-block'), 'saved_music_background'));
            $('#vinyl-record').addEventListener('click', () => $('#vinyl-input').click());
            $('#vinyl-input').addEventListener('change', (e) => handleImageUpload(e.target, $('#vinyl-record'), 'saved_vinyl_cover'));
            $('#photo-widget').addEventListener('click', () => $('#photo-widget-input').click());
            $('#photo-widget-input').addEventListener('change', (e) => handleImageUpload(e.target, $('#photo-widget'), 'saved_photo_widget', { hideTextElement: '#photo-widget-text' }));
            $('#widget-image-placeholder').addEventListener('click', () => $('#widget-image-input').click());
            $('#widget-image-input').addEventListener('change', (e) => handleImageUpload(e.target, $('#widget-image-placeholder'), 'saved_widget_image'));
            $('#character-avatar-placeholder').addEventListener('click', () => $('#character-avatar-input').click());
            $('#character-avatar-input').addEventListener('change', (e) => handleImageUpload(e.target, $('#character-avatar-placeholder'), null, { compression: { maxWidth: 256, maxHeight: 256 } }));

            $('#mood-text').addEventListener('input', (e) => saveData('saved_mood_text', e.target.value));
            $('#widget-name-input').addEventListener('input', (e) => saveData('saved_widget_name', e.target.value));
            $('#widget-thinking-input').addEventListener('input', (e) => saveData('saved_widget_thinking', e.target.value));
            $('#widget-location-input').addEventListener('input', (e) => saveData('saved_widget_location', e.target.value));

            $('#music-upload-button').addEventListener('click', () => $('#music-upload-input').click());
            $('#music-upload-input').addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    const newSongs = Array.from(files).map(file => ({ name: file.name, url: URL.createObjectURL(file) }));
                    songList = [...songList, ...newSongs];
                    const savableList = songList.map(s => ({name: s.name}));
                    saveData('songList', savableList);
                    updateSongListUI();
                    if (currentSongIndex === -1 && songList.length > 0) playSong(0);
                }
            });
            $('#playlist-button').addEventListener('click', () => $('#song-list-modal').classList.add('visible'));
            $('#close-playlist-modal').addEventListener('click', () => $('#song-list-modal').classList.remove('visible'));
            $('#play-pause-button').addEventListener('click', () => {
                if (songList.length === 0) return showMessageBox('請先上傳歌曲');
                if (currentAudio.paused) {
                    if (currentSongIndex === -1) playSong(0);
                    else {
                        currentAudio.play();
                        startSpinning();
                    }
                } else {
                    currentAudio.pause();
                    stopSpinning();
                }
                $('#play-pause-button i').className = `fas ${currentAudio.paused ? 'fa-play' : 'fa-pause'} text-xl`;
            });
            $('#prev-button').addEventListener('click', () => { if (songList.length > 0) playSong((currentSongIndex - 1 + songList.length) % songList.length); });
            $('#next-button').addEventListener('click', () => { if (songList.length > 0) playSong((currentSongIndex + 1) % songList.length); });
            $('#loop-button').addEventListener('click', () => { isLooping = !isLooping; $('#loop-button').classList.toggle('active', isLooping); showMessageBox(isLooping ? '列表循環已開啟' : '列表循環已關閉'); });
            $('#single-loop-button').addEventListener('click', () => { isSingleLooping = !isSingleLooping; $('#single-loop-button').classList.toggle('active', isSingleLooping); showMessageBox(isSingleLooping ? '單曲循環已開啟' : '單曲循環已關閉'); });

            $('#wb-add-button').addEventListener('click', () => {
                currentEditingWorldBookId = null;
                $('#wb-title-input').value = '';
                $('#wb-content-input').value = '';
                showScreen('world-book-edit-screen');
            });
            $('#wb-save-button').addEventListener('click', () => {
                const title = $('#wb-title-input').value.trim();
                if (!title) return showMessageBox('標題不能為空');
                const content = $('#wb-content-input').value.trim();
                
                if (currentEditingWorldBookId) {
                    const book = worldBooks.find(b => b.id === currentEditingWorldBookId);
                    if (book) {
                        book.title = title;
                        book.content = content;
                    }
                } else {
                    const newBook = { id: `wb_${Date.now()}`, title, content };
                    worldBooks.push(newBook);
                }
                saveData('worldBooks', worldBooks);
                renderWorldBookList();
                showMessageBox('已保存');
                showScreen('world-book-list-screen');
            });

            $('#cb-add-button').addEventListener('click', () => {
                showCharacterEditScreen(null);
            });
            $('#cb-save-button').addEventListener('click', saveCharacter);
            $('#cb-delete-button').addEventListener('click', () => {
                if (currentEditingCharacterId) {
                    const character = characters.find(c => c.id === currentEditingCharacterId);
                    if (character) {
                        showDeleteConfirmation('character', character.id, character.name);
                    }
                }
            });
            
            $('#send-chat-button').addEventListener('click', handleSendMessage);
            $('#receive-chat-button').addEventListener('click', handleReceiveMessage);
            
            $('#wechat-new-chat-button').addEventListener('click', () => {
                const container = $('#new-chat-character-list');
                container.innerHTML = '';
                if (characters.length === 0) {
                    container.innerHTML = '<li class="p-3 text-center text-gray-400">請先去角色書創建角色</li>';
                } else {
                    characters.forEach(char => {
                        const item = document.createElement('li');
                        item.className = 'list-item';
                        const avatarStyle = char.avatar ? `background-image: url(${char.avatar})` : '';
                        const avatarContent = char.avatar ? '' : '<i class="fas fa-user text-xl"></i>';
                        item.innerHTML = `
                            <div class="flex items-center">
                                <div class="w-10 h-10 rounded-full mr-3 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center" style="${avatarStyle}">${avatarContent}</div>
                                <h4 class="font-semibold">${char.name}</h4>
                            </div>
                        `;
                        item.addEventListener('click', () => {
                            $('#new-chat-modal').classList.remove('visible');
                            if (!chatHistories[char.id]) {
                                chatHistories[char.id] = { history: [], pinned: false };
                                saveData('chatHistories', chatHistories);
                                renderWeChatList();
                                showMessageBox(`已和 ${char.name} 建立對話`);
                            }
                        });
                        container.appendChild(item);
                    });
                }
                $('#new-chat-modal').classList.add('visible');
            });
            $('#close-new-chat-modal').addEventListener('click', () => $('#new-chat-modal').classList.remove('visible'));
            
            $('#wechat-options-button').addEventListener('click', () => {
                const pinOption = $('#pin-chat-option');
                pinOption.textContent = chatHistories[currentChatCharacterId]?.pinned ? '取消置頂' : '置頂對話';
                
                const userColorPicker = $('#user-bubble-color-picker');
                const aiColorPicker = $('#ai-bubble-color-picker');
                const currentColors = chatBubbleColors[currentChatCharacterId];
                
                const isDarkMode = body.classList.contains('dark-mode');
                const defaultUserColor = '#374151';
                const defaultAiColor = isDarkMode ? '#4a4a4a' : '#e5e7eb';

                userColorPicker.value = currentColors?.user || defaultUserColor;
                aiColorPicker.value = currentColors?.ai || defaultAiColor;

                showScreen('wechat-options-screen');
            });
            $('#wechat-options-back-button').addEventListener('click', () => showScreen('wechat-chat-screen'));
            $('#delete-chat-option').addEventListener('click', () => {
                const characterName = characters.find(c => c.id === currentChatCharacterId)?.name;
                showDeleteConfirmation('chat', currentChatCharacterId, `與 ${characterName} 的對話`);
            });
            $('#pin-chat-option').addEventListener('click', () => {
                const chat = chatHistories[currentChatCharacterId];
                if (chat) {
                    chat.pinned = !chat.pinned;
                    saveData('chatHistories', chatHistories);
                    showMessageBox(chat.pinned ? '已置頂' : '已取消置頂');
                    $('#pin-chat-option').textContent = chat.pinned ? '取消置頂' : '置頂對話';
                }
            });
            $('#change-chat-bg-option').addEventListener('click', () => {
                $('#chat-bg-input').click();
            });
            $('#chat-bg-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if(file && currentChatCharacterId) {
                    try {
                        const compressedDataUrl = await handleImageUpload(e.target, null, null);
                        chatBackgrounds[currentChatCharacterId] = compressedDataUrl;
                        saveData('chatBackgrounds', chatBackgrounds);

                        const chatScreen = $('#wechat-chat-screen');
                        chatScreen.querySelector('.chat-background').style.backgroundImage = `url(${compressedDataUrl})`;
                        
                        chatScreen.classList.add('has-custom-bg');
                        statusBar.classList.add('transparent-override');

                        showMessageBox('聊天背景已更換');
                    } catch (error) {
                        showMessageBox('背景圖片處理失敗');
                    }
                }
            });

            function handleColorChange(type, value) {
                if (!currentChatCharacterId) return;
                if (!chatBubbleColors[currentChatCharacterId]) {
                    chatBubbleColors[currentChatCharacterId] = {};
                }
                chatBubbleColors[currentChatCharacterId][type] = value;
                saveData('chatBubbleColors', chatBubbleColors);
                renderChatHistory();
            }
            $('#user-bubble-color-picker').addEventListener('input', (e) => handleColorChange('user', e.target.value));
            $('#ai-bubble-color-picker').addEventListener('input', (e) => handleColorChange('ai', e.target.value));

            
            $('#wechat-content-chat').addEventListener('click', (e) => {
                if (e.target.closest('.user-avatar-in-chat')) {
                    $('#user-avatar-input').click();
                }
            });
            $('#user-avatar-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const compressedDataUrl = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 128, maxHeight: 128 } });
                    if (compressedDataUrl) {
                        // 更新当前聊天角色的头像
                        if (currentChatCharacterId) {
                            userAvatars[currentChatCharacterId] = compressedDataUrl;
                            saveData('userAvatars', userAvatars);
                            renderChatHistory();
                        }
                        
                        // 更新朋友圈中的用户头像
                        if (currentWeChatCharacterId) {
                            userAvatars[currentWeChatCharacterId] = compressedDataUrl;
                            saveData('userAvatars', userAvatars);
                            // 刷新朋友圈显示
                            if (!$('#wechat-moments-container').classList.contains('hidden')) {
                                renderUnifiedMoments();
                            }
                        }
                        
                        // 更新朋友圈头部头像
                        const momentsAvatar = $('#moments-user-avatar');
                        if (momentsAvatar) {
                            momentsAvatar.style.backgroundImage = `url(${compressedDataUrl})`;
                        }
                        
                        showMessageBox('头像已更新');
                    }
                }
                e.target.value = '';
            });

            $('#change-wallpaper-link').addEventListener('click', () => $('#wallpaper-input').click());
            $('#wallpaper-input').addEventListener('change', (e) => handleImageUpload(e.target, homeWallpaper, 'saved_wallpaper'));

            function renderAppIconSettings() {
                const container = $('#app-icon-list');
                container.innerHTML = '';
                $$('.app-icon').forEach(iconEl => {
                    const appName = iconEl.dataset.appName;
                    const item = document.createElement('div');
                    item.className = 'list-item'; 
                    
                    const innerContainer = document.createElement('div');
                    innerContainer.className = 'flex justify-between items-center w-full';

                    const leftPart = document.createElement('div');
                    leftPart.className = 'flex items-center';

                    const previewIcon = document.createElement('div');
                    previewIcon.className = 'w-10 h-10 rounded-lg flex items-center justify-center shadow-md mr-4 bg-cover bg-center';
                    
                    const savedIcon = loadData(`saved_icon_${appName}`);
                    if (savedIcon) {
                        previewIcon.style.backgroundImage = `url(${savedIcon})`;
                        previewIcon.style.backgroundSize = 'contain';
                        previewIcon.style.backgroundRepeat = 'no-repeat';
                    } else {
                        previewIcon.style.backgroundImage = iconEl.style.backgroundImage;
                    }

                    if (!previewIcon.style.backgroundImage) {
                        if (iconEl.classList.contains('app-icon-glass')) {
                            previewIcon.className += ' app-icon-glass';
                        } else {
                             previewIcon.style.backgroundColor = '#1f2937';
                        }
                    }
                    
                    const iconI = document.createElement('i');
                    const originalIcon = iconEl.querySelector('i');
                    if (originalIcon) iconI.className = originalIcon.className;
                    iconI.style.display = savedIcon ? 'none' : (originalIcon ? originalIcon.style.display : 'block');
                    previewIcon.appendChild(iconI);

                    const text = document.createElement('h4');
                    text.className = 'font-semibold';
                    text.textContent = appName;

                    leftPart.appendChild(previewIcon);
                    leftPart.appendChild(text);

                    const button = document.createElement('button');
                    button.className = 'px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded-md text-sm flex-shrink-0';
                    button.textContent = '更換';

                    innerContainer.appendChild(leftPart);
                    innerContainer.appendChild(button);
                    item.appendChild(innerContainer);
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.className = 'hidden';
                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            try {
                                const compressedDataUrl = await compressImage(file, { maxWidth: 128, maxHeight: 128 });
                                saveData(`saved_icon_${appName}`, compressedDataUrl);
                                iconEl.style.backgroundImage = `url(${compressedDataUrl})`;
                                if (originalIcon) originalIcon.style.display = 'none';
                                previewIcon.style.backgroundImage = `url(${compressedDataUrl})`;

                                iconEl.style.backgroundSize = 'contain';
                                iconEl.style.backgroundRepeat = 'no-repeat';
                                previewIcon.style.backgroundSize = 'contain';
                                previewIcon.style.backgroundRepeat = 'no-repeat';
                                
                                const previewIconI = previewIcon.querySelector('i');
                                if (previewIconI) previewIconI.style.display = 'none';
                            } catch (error) {
                                showMessageBox("圖標處理失敗");
                            }
                        }
                    });
                    item.appendChild(input);
                    button.addEventListener('click', () => input.click());
                    container.appendChild(item);
                });
            }
            
            $('#font-save-button').addEventListener('click', () => {
                const url = $('#font-url-input').value.trim();
                if (url) {
                    applyFont(url);
                    saveData('saved_font_url', url);
                    showMessageBox('字體已應用');
                } else {
                    const styleElement = document.getElementById('custom-font-style');
                    if(styleElement) styleElement.innerHTML = '';
                    phoneScreen.style.fontFamily = '';
                    localStorage.removeItem('saved_font_url');
                    showMessageBox('已恢復預設字體');
                }
            });

            $('#font-size-selector').addEventListener('click', (e) => {
                if (e.target.matches('.font-size-btn')) {
                    const size = e.target.dataset.size;
                    setFontSize(size);
                    saveData('fontSize', size);
                }
            });
            
            $('#fetch_models_btn').addEventListener('click', () => fetchModels(false));

            $('#save_settings_btn').addEventListener('click', async () => {
                const apiUrl = $('#api_url').value.trim();
                const apiKey = $('#api_key').value.trim();
                let model = $('#model_select').value;

                if (!apiUrl || !apiKey) {
                    showMessageBox("請填寫 API 地址和密鑰");
                return;
            }
            
                const settings = { url: apiUrl, key: apiKey, model: model };
                saveData('api_settings', settings);
                showMessageBox("設定已保存，正在驗證連接...");

                const isValid = await fetchModels(true);
                updateApiStatusUI(isValid);

                if (isValid) {
                    showMessageBox("API 驗證成功");
                    settings.model = $('#model_select').value;
                    saveData('api_settings', settings);
                } else {
                    showMessageBox("API 驗證失敗，請檢查地址和密鑰");
                }
            });

            $('#confirm-delete-btn').addEventListener('click', () => {
                if (deleteCallback) deleteCallback();
            });
            $('#cancel-delete-btn').addEventListener('click', () => {
                $('#confirm-delete-modal').classList.remove('visible');
                deleteCallback = null;
            });
            
            // V7.1: 全新 Tab Bar 事件監聽器
            $('.wechat-tab-bar').addEventListener('click', (e) => {
                const target = e.target.closest('.wechat-tab-item');
                if (!target) return;

                // 如果沒有角色，提示用戶
                if (!characters.length > 0) {
                    showMessageBox("請先創建一個角色");
                return;
            }
                currentWeChatCharacterId = characters[0].id; // 預設使用第一個角色ID作為上下文

                $$('.wechat-tab-item').forEach(item => item.classList.remove('active'));
                target.classList.add('active');

                const tab = target.dataset.tab;
                
                $$('#wechat-content-container > div').forEach(div => {
                    div.classList.add('hidden');
                });

                if (tab === 'chat') {
                    $('#wechat-list-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.remove('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                } else {
                    $('#wechat-new-chat-button').classList.add('hidden');

                    const containerId = `#wechat-${tab}-container`;
                    $(containerId).classList.remove('hidden');
                    
                    if (tab === 'moments') {
                        // 新：渲染統一的動態流
                        $('#wechat-new-moment-button').classList.remove('hidden');
                        renderUnifiedMoments(); 
                    } else if (tab === 'diary') {
                        // 新：顯示日記書架
                        $('#wechat-new-moment-button').classList.add('hidden');
                        showDiaryBookshelf();
                    } else if (tab === 'plan') {
                        // 如果您保留了計劃功能，這裡調用 renderPlans
                        $('#wechat-new-moment-button').classList.add('hidden');
                        // renderPlans(currentWeChatCharacterId);
                        $(containerId).innerHTML = '<p class="text-center text-gray-500 p-8">計劃功能待更新</p>';
                    }
                }
            });

            const chatScreen = $('#wechat-chat-screen');

            function hideBubbleMenu() {
                if (activeMenu) {
                    activeMenu.classList.remove('visible');
                    activeMenu = null;
                }
            }

            chatScreen.addEventListener('click', (e) => {
                if (e.target.closest('.bubble-context-menu')) return;

                const wrapper = e.target.closest('.chat-message-wrapper');

                if (isMultiSelectMode) {
                    if (wrapper) toggleMessageSelection(wrapper);
                } else {
                    const bubble = e.target.closest('.chat-message');
                    if (bubble && !bubble.classList.contains('red-packet-message') && !bubble.classList.contains('transfer-message')) {
                        e.stopPropagation();
                        if (activeMenu && !activeMenu.isSameNode(bubble.parentNode.querySelector('.bubble-context-menu'))) {
                           hideBubbleMenu();
                        }
                        showBubbleMenu(bubble);
                    } else {
                        hideBubbleMenu();
                    }
                }
            });

            function showBubbleMenu(bubble) {
                const wrapper = bubble.closest('.chat-message-wrapper');
                let menu = wrapper.querySelector('.bubble-context-menu');

                if (!menu) {
                    const template = $('#bubble-menu-template');
                    const menuClone = template.content.cloneNode(true);
                    wrapper.appendChild(menuClone);
                    menu = wrapper.querySelector('.bubble-context-menu');

                    menu.addEventListener('click', (e) => {
                        const button = e.target.closest('.bubble-menu-button');
                        if (button) {
                            const action = button.dataset.action;
                            const timestamp = wrapper.dataset.timestamp;
                            handleMenuAction(action, timestamp, bubble);
                        }
                    });
                }

                const sender = wrapper.dataset.sender;

                menu.querySelector('[data-action="retry"]').style.display = sender === 'ai' ? 'flex' : 'none';

                const bubbleRect = bubble.getBoundingClientRect();
                const screenRect = phoneScreen.getBoundingClientRect();

                menu.classList.add('visible');
                const menuRect = menu.getBoundingClientRect();

                let top = bubble.offsetTop - menuRect.height - 8;

                if (bubbleRect.top < (screenRect.top + menuRect.height + 16)) {
                    top = bubble.offsetTop + bubble.offsetHeight + 8;
                }

                const leftOffset = (bubble.offsetWidth / 2) - (menuRect.width / 2);
                let finalLeft = bubble.offsetLeft + leftOffset;

                menu.style.top = `${top}px`;
                menu.style.left = `${finalLeft}px`;
                menu.style.transform = 'translateX(0)';

                activeMenu = menu;
            }

            function handleMenuAction(action, timestamp, bubble) {
                 hideBubbleMenu();
                 switch (action) {
                    case 'delete':
                        showDeleteConfirmation('message', timestamp, '這條消息');
                        break;
                    case 'copy':
                        copyMessageHandler(timestamp);
                        break;
                    case 'multiselect':
                        enterMultiSelectMode();
                        break;
                    case 'edit':
                        editMessageHandler(timestamp, bubble);
                        break;
                    case 'retry':
                        retryMessageHandler(timestamp);
                        break;
                 }
            }

            function copyMessageHandler(timestamp) {
                const msg = chatHistories[currentChatCharacterId]?.history.find(m => String(m.timestamp) === timestamp);
                if (msg && msg.type === 'text') {
                    navigator.clipboard.writeText(msg.content).then(() => {
                        showMessageBox('已複製');
                    }).catch(() => showMessageBox('複製失敗'));
                }
            }

            function editMessageHandler(timestamp, bubble) {
                const msgIndex = chatHistories[currentChatCharacterId].history.findIndex(m => String(m.timestamp) === timestamp);
                if (msgIndex === -1 || chatHistories[currentChatCharacterId].history[msgIndex].type !== 'text') return;

                const p = bubble.querySelector('p');
                const originalText = chatHistories[currentChatCharacterId].history[msgIndex].content;
                p.contentEditable = true;
                p.focus();

                const sel = window.getSelection();
                sel.selectAllChildren(p);
                sel.collapseToEnd();

                const saveEdit = () => {
                    const newText = p.innerText.trim();
                    if (newText && newText !== originalText) {
                        chatHistories[currentChatCharacterId].history[msgIndex].content = newText;
                        saveData('chatHistories', chatHistories);
                    }
                    p.innerHTML = newText.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>');
                };

                p.addEventListener('blur', () => {
                    p.contentEditable = false;
                    saveEdit();
                }, { once: true });

                p.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); p.blur(); }
                    if (e.key === 'Escape') { p.innerText = originalText; p.blur(); }
                });
            }

            async function retryMessageHandler(timestamp) {
                const history = chatHistories[currentChatCharacterId].history;
                const msgIndex = history.findIndex(m => String(m.timestamp) === timestamp);

                if (msgIndex > -1) {
                    const wrapperToRetry = $(`[data-timestamp="${timestamp}"]`);
                    if (!wrapperToRetry) return; // Element not found in DOM

                    const wrapperIndex = Array.from(chatContentArea.children).indexOf(wrapperToRetry);
                    const subsequentWrappers = Array.from(chatContentArea.children).slice(wrapperIndex + 1);

                    const historyToRetry = history.slice(0, msgIndex);
                    if (historyToRetry.length > 0 && historyToRetry[historyToRetry.length - 1].sender === 'user') {
                        chatHistories[currentChatCharacterId].history = historyToRetry;

                        subsequentWrappers.forEach(el => el.remove());

                        await getAIResponse(historyToRetry[historyToRetry.length-1], true, wrapperToRetry);

                        saveData('chatHistories', chatHistories);

                    } else {
                        showMessageBox('無法找到有效的重試上下文');
                    }
                }
            }

            function enterMultiSelectMode() {
                isMultiSelectMode = true;
                $('#chat-header-normal').classList.add('hidden');
                $('#chat-header-multiselect').classList.remove('hidden');
                $('#chat-header-multiselect').classList.add('flex');
                updateMultiSelectCount();
            }

            function exitMultiSelectMode() {
                isMultiSelectMode = false;
                selectedMessages.clear();
                $$('.chat-message-wrapper.selected').forEach(el => el.classList.remove('selected'));
                $('#chat-header-normal').classList.remove('hidden');
                $('#chat-header-multiselect').classList.add('hidden');
                $('#chat-header-multiselect').classList.remove('flex');
            }

            function toggleMessageSelection(wrapper) {
                const timestamp = wrapper.dataset.timestamp;
                wrapper.classList.toggle('selected');
                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                } else {
                    selectedMessages.add(timestamp);
                }
                updateMultiSelectCount();
            }

            function updateMultiSelectCount() {
                const count = selectedMessages.size;
                $('#multiselect-count').textContent = `已選擇 ${count} 項`;
                $('#confirm-multiselect-btn').disabled = count === 0;
            }

            $('#cancel-multiselect-btn').addEventListener('click', exitMultiSelectMode);
            $('#confirm-multiselect-btn').addEventListener('click', () => {
                if(selectedMessages.size > 0) {
                    showDeleteConfirmation('multi-message', null, `${selectedMessages.size}條消息`);
                }
            });

            const featuresPanel = $('#more-features-panel');
            const addFeatureBtn = $('#add-feature-btn');
            const chatInputBar = $('#chat-input-bar');
            const chatInput = $('#chat-input');
            const addFeatureIcon = addFeatureBtn.querySelector('i');

            function toggleFeaturesPanel() {
                const isPanelHidden = featuresPanel.classList.contains('hidden');
                if (isPanelHidden) {
                    featuresPanel.classList.remove('hidden');
                    addFeatureIcon.className = 'ri-keyboard-line';
                } else {
                    featuresPanel.classList.add('hidden');
                    addFeatureIcon.className = 'ri-add-circle-line';
                }
            }

            addFeatureBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFeaturesPanel();
            });

            chatScreen.addEventListener('click', (e) => {
                const stickerPanel = $('#sticker-panel');
                if (addFeatureBtn.contains(e.target) || featuresPanel.contains(e.target) || $('#emoji-btn').contains(e.target) || stickerPanel.contains(e.target)) return;

                if (!featuresPanel.classList.contains('hidden')) {
                    toggleFeaturesPanel();
                }
                if (stickerPanel.classList.contains('visible')) {
                    // 如果在刪除模式下，點擊外部不會關閉面板
                    if (!isDeleteMode) {
                        stickerPanel.classList.remove('visible');
                    }
                }
            });

            $('#send-image-btn').addEventListener('click', () => {
                $('#image-upload-input').click();
            });

            $('#image-upload-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const compressedDataUrl = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 512, maxHeight: 512 } });
                    if (compressedDataUrl) {
                        const isNewSender = chatHistories[currentChatCharacterId]?.history.length === 0 || chatHistories[currentChatCharacterId].history.slice(-1)[0].sender !== 'user';
                        const timestamp = Date.now();
                        appendMessage(compressedDataUrl, 'user', 'image', true, timestamp, isNewSender);
                        await getAIResponse({ content: compressedDataUrl, type: 'image' });
                    }
                    toggleFeaturesPanel();
                    e.target.value = '';
                }
            });

            const voiceModal = $('#voice-input-modal');
            const voiceInput = $('#voice-text-input');
            $('#quick-voice-message-btn').addEventListener('click', () => {
                voiceModal.classList.add('visible');
                voiceInput.focus();
            });
            $('#cancel-voice-btn').addEventListener('click', () => {
                voiceModal.classList.remove('visible');
                voiceInput.value = '';
            });
            $('#send-voice-btn').addEventListener('click', () => {
                const text = voiceInput.value.trim();
                if (text) {
                    const isNewSender = chatHistories[currentChatCharacterId]?.history.length === 0 || chatHistories[currentChatCharacterId].history.slice(-1)[0].sender !== 'user';
                    appendMessage(text, 'user', 'voice', true, Date.now(), isNewSender);
                    voiceInput.value = '';
                    voiceModal.classList.remove('visible');
                }
            });

            $('#quick-voice-call-btn').addEventListener('click', () => {
                currentCallType = 'voice';
                startVoiceCall();
            });
            $('#quick-video-call-btn').addEventListener('click', () => {
                currentCallType = 'video';
                startVideoCall();
            });

            $('#voice-call-hangup').addEventListener('click', () => endCall(true));
            $('#video-call-hangup').addEventListener('click', () => endCall(true));
            $('#voice-call-send-btn').addEventListener('click', () => handleCallInteraction('voice'));
            $('#video-call-send-btn').addEventListener('click', () => handleCallInteraction('video'));

            $('#answer-call-btn').addEventListener('click', () => {
                $('#incoming-call-alert').classList.remove('visible');
                if (currentCallType === 'voice') startVoiceCall();
                if (currentCallType === 'video') startVideoCall();
            });
            $('#decline-call-btn').addEventListener('click', () => {
                $('#incoming-call-alert').classList.remove('visible');
                appendMessage('通話已拒絕', 'system', 'system', true);
                currentCallType = null;
            });

            $('#user-video-preview').addEventListener('click', () => {
                $('#my-video-image-input').click();
            });

            $('#change-user-video-image-option').addEventListener('click', () => {
                 $('#user-video-image-input').click();
            });

            $('#user-video-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                    const compressedDataUrl = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 512, maxHeight: 512 }});
                    if (compressedDataUrl) {
                        userVideoImages[currentChatCharacterId] = compressedDataUrl;
                        saveData('userVideoImages', userVideoImages);
                        showMessageBox('對方的視頻照片已更新');
                    }
                }
            });

            $('#my-video-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                    const compressedDataUrl = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256 }});
                    if (compressedDataUrl) {
                        myVideoImages[currentChatCharacterId] = compressedDataUrl;
                        saveData('myVideoImages', myVideoImages);
                        if (currentCallType === 'video') {
                            $('#user-video-image').src = compressedDataUrl;
                        }
                        showMessageBox('我的視頻照片已更新');
                    }
                }
            });

            // 貼圖功能事件監聽
            const stickerPanel = $('#sticker-panel');
            const stickerGrid = $('#sticker-grid');
            const addStickerBtn = $('#add-sticker-btn');
            const stickerModal = $('#sticker-modal');

            // 刪除模式相關變量
            let isDeleteMode = false;
            let selectedStickers = new Set();
            
            function renderStickers() {
                stickerGrid.innerHTML = '';
                userStickers.forEach((stickerSrc, index) => {
                    const stickerItem = document.createElement('div');
                    stickerItem.className = 'sticker-item';
                    stickerItem.dataset.index = index;
                    
                    if (isDeleteMode) {
                        stickerItem.classList.add('delete-mode');
                        const checkbox = document.createElement('div');
                        checkbox.className = 'sticker-checkbox';
                        checkbox.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleStickerSelection(index, checkbox);
                        });
                        stickerItem.appendChild(checkbox);
                    }
                    
                    const img = document.createElement('img');
                    img.src = stickerSrc;
                    img.alt = 'sticker';
                    stickerItem.appendChild(img);
                    
                    stickerItem.addEventListener('click', () => {
                        if (!isDeleteMode) {
                            appendMessage(stickerSrc, 'user', 'sticker', true, Date.now(), true);
                            stickerPanel.classList.remove('visible');
                        }
                    });
                    
                    stickerGrid.appendChild(stickerItem);
                });
                stickerGrid.appendChild(addStickerBtn);
            }
            
            function toggleStickerSelection(index, checkbox) {
                if (selectedStickers.has(index)) {
                    selectedStickers.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.parentElement.classList.remove('selected');
                } else {
                    selectedStickers.add(index);
                    checkbox.classList.add('checked');
                    checkbox.parentElement.classList.add('selected');
                }
            }
            
            function enterDeleteMode() {
                isDeleteMode = true;
                selectedStickers.clear();
                $('#sticker-delete-btn').classList.add('active');
                renderStickers();
            }
            
            function exitDeleteMode() {
                isDeleteMode = false;
                selectedStickers.clear();
                $('#sticker-delete-btn').classList.remove('active');
                renderStickers();
            }
            
            function deleteSelectedStickers() {
                if (selectedStickers.size === 0) {
                    showMessageBox('請先選擇要刪除的表情包');
                    return;
                }
                
                const deleteModal = $('#delete-sticker-modal');
                const deleteText = $('#delete-sticker-text');
                const count = selectedStickers.size;
                
                if (count === 1) {
                    deleteText.textContent = '確定要刪除這個表情包嗎？此操作無法撤銷。';
                } else {
                    deleteText.textContent = `確定要刪除選中的 ${count} 個表情包嗎？此操作無法撤銷。`;
                }
                
                deleteModal.classList.add('visible');
            }
            
            function performDelete() {
                const sortedIndices = Array.from(selectedStickers).sort((a, b) => b - a);
                
                sortedIndices.forEach(index => {
                    userStickers.splice(index, 1);
                });
                
                saveData('userStickers', userStickers);
                selectedStickers.clear();
                exitDeleteMode();
                renderStickers();
                $('#delete-sticker-modal').classList.remove('visible');
                
                const count = sortedIndices.length;
                if (count === 1) {
                    showMessageBox('表情包已刪除');
                } else {
                    showMessageBox(`${count} 個表情包已刪除`);
                }
            }

            $('#emoji-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                renderStickers();
                stickerPanel.classList.toggle('visible');
                if (!featuresPanel.classList.contains('hidden')) {
                    toggleFeaturesPanel();
                }
            });

            // 刪除按鈕事件監聽
            $('#sticker-delete-btn').addEventListener('click', () => {
                if (isDeleteMode) {
                    if (selectedStickers.size > 0) {
                        deleteSelectedStickers();
                    } else {
                        exitDeleteMode();
                    }
                } else {
                    enterDeleteMode();
                }
            });
            
            // 刪除彈窗事件監聽
            $('#cancel-delete-sticker-btn').addEventListener('click', () => {
                $('#delete-sticker-modal').classList.remove('visible');
            });
            
            $('#confirm-delete-sticker-btn').addEventListener('click', () => {
                performDelete();
            });
            
            // 按ESC鍵退出刪除模式
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isDeleteMode) {
                    exitDeleteMode();
                }
            });
            
            addStickerBtn.addEventListener('click', () => stickerModal.classList.add('visible'));
            $('#close-sticker-modal').addEventListener('click', () => stickerModal.classList.remove('visible'));
            $('#upload-sticker-local-btn').addEventListener('click', () => $('#sticker-upload-input').click());

            $('#sticker-upload-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const compressedDataUrl = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256 } });
                    if (compressedDataUrl) {
                        userStickers.push(compressedDataUrl);
                        saveData('userStickers', userStickers);
                        renderStickers();
                        stickerModal.classList.remove('visible');
                    }
                    e.target.value = '';
                }
            });

            $('#send-sticker-url-btn').addEventListener('click', () => {
                const url = $('#sticker-url-input').value.trim();
                if (url) {
                    userStickers.push(url);
                    saveData('userStickers', userStickers);
                    renderStickers();
                    $('#sticker-url-input').value = '';
                    stickerModal.classList.remove('visible');
                } else {
                    showMessageBox('請輸入有效的圖片連結');
                }
            });

            // 紅包/轉賬事件監聽
            const redPacketModal = $('#red-packet-modal');
            const transferModal = $('#transfer-modal');
            $('#send-red-packet-btn').addEventListener('click', () => redPacketModal.classList.add('visible'));
            $('#send-transfer-btn').addEventListener('click', () => transferModal.classList.add('visible'));

            $$('.close-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetModal = $(`#${btn.dataset.target}`);
                    if (targetModal) targetModal.classList.remove('visible');
                });
            });

            $('#send-red-packet-confirm-btn').addEventListener('click', () => {
                const amountInput = $('#red-packet-amount');
                const amount = parseFloat(amountInput.value);
                const message = $('#red-packet-message').value || $('#red-packet-message').placeholder;
                if (amount > 0) {
                    const content = { amount: amount.toFixed(2), message };
                    appendMessage(content, 'user', 'red-packet', true, Date.now(), true);
                    redPacketModal.classList.remove('visible');
                    amountInput.value = '';
                    $('#red-packet-message').value = '';
                } else {
                    showMessageBox('請輸入有效金額');
                }
            });

            $('#send-transfer-confirm-btn').addEventListener('click', () => {
                const amountInput = $('#transfer-amount');
                const amount = parseFloat(amountInput.value);
                const message = $('#transfer-message').value || $('#transfer-message').placeholder;
                 if (amount > 0) {
                    const content = { amount: amount.toFixed(2), message };
                    appendMessage(content, 'user', 'transfer', true, Date.now(), true);
                    transferModal.classList.remove('visible');
                    amountInput.value = '';
                    $('#transfer-message').value = '';
                } else {
                    showMessageBox('請輸入有效金額');
                }
            });

            // 數據導入/導出
            $('#export-data-btn').addEventListener('click', () => {
                const allData = {};
                // Iterate over all keys in localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    try {
                        allData[key] = JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        allData[key] = localStorage.getItem(key);
                    }
                }

                const dataStr = JSON.stringify(allData, null, 2);
                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'wechat_simulator_backup.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showMessageBox('數據已導出');
            });

            $('#import-data-btn').addEventListener('click', () => {
                $('#import-data-input').click();
            });

            $('#import-data-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        localStorage.clear();
                        Object.keys(importedData).forEach(key => {
                            localStorage.setItem(key, JSON.stringify(importedData[key]));
                        });
                        showMessageBox('數據導入成功，正在刷新...');
                        // Reload all data and update UI
                        await loadAllSavedData();
                        // Go to a neutral screen
                        renderWeChatList();
                        showScreen('wechat-list-screen');
                    } catch (err) {
                        showMessageBox('導入失敗，文件格式錯誤');
                        console.error("Import error:", err);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset input
            });


            let initialTextareaHeight = 0;
            let maxHeight = 0;

            function adjustTextareaHeight() {
                if (!initialTextareaHeight) {
                    const style = window.getComputedStyle(chatInput);
                    const lineHeight = parseFloat(style.lineHeight);
                    const paddingTop = parseFloat(style.paddingTop);
                    const paddingBottom = parseFloat(style.paddingBottom);
                    initialTextareaHeight = lineHeight;
                    maxHeight = (lineHeight * 3) + paddingTop + paddingBottom;
                }

                chatInput.style.height = 'auto';
                const scrollHeight = chatInput.scrollHeight;

                if (scrollHeight > maxHeight) {
                    chatInput.style.height = `${maxHeight}px`;
                    chatInput.style.overflowY = 'auto';
                } else {
                    chatInput.style.height = `${scrollHeight}px`;
                    chatInput.style.overflowY = 'hidden';
                }
            }

            chatInput.addEventListener('input', adjustTextareaHeight);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            });
            
            // V7.1: 激活所有新功能的事件監聽器
            addNewEventListeners();
            
            // 初始化按钮显示状态
            setTimeout(() => {
                // 确保初始状态正确：聊天标签页时只显示聊天按钮
                $('#wechat-new-chat-button').classList.remove('hidden');
                $('#wechat-new-moment-button').classList.add('hidden');
            }, 100);
            
            // 初始化画板功能
            setTimeout(() => {
            setupDrawingBoard();
                setupColorPalette();
                setupBrushControls();
                setupDrawingBoardEvents();
                setupTarotCard();
            }, 100);
        });

        // ====== 新增：AI对收到红包/转账的反应机制 ======
        
        /**
         * 触发AI对收到红包/转账的反应
         * @param {string} type - 类型：'red-packet' 或 'transfer'
         * @param {object} content - 红包/转账内容：{amount, message}
         * @param {string} characterId - 角色ID
         */
        async function triggerAIReactionToPayment(type, content, characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('找不到角色:', characterId);
                    return;
                }

                // 检查API是否连接
                const apiSettings = loadData('apiSettings');
                if (!apiSettings || !apiSettings.key || !apiSettings.url) {
                    console.log('API未连接，AI不产生反应');
                    return; // API未连接时，AI没有反应
                }

                // 构建反应提示词
                const reactionPrompt = buildPaymentReactionPrompt(type, content, character);
                
                // 调用AI生成反应
                const aiReaction = await getAIResponseForPaymentReaction(reactionPrompt, characterId);
                
                if (aiReaction) {
                    // 延迟显示AI反应，让用户有时间看到红包/转账
                    setTimeout(() => {
                        const isNew = true;
                        appendMessage(aiReaction, 'ai', 'text', true, Date.now(), isNew);
                    }, 1500);
                }
            } catch (error) {
                console.error('AI反应生成失败:', error);
            }
        }

        /**
         * 构建红包/转账反应提示词
         * @param {string} type - 类型
         * @param {object} content - 内容
         * @param {object} character - 角色信息
         * @returns {string} 提示词
         */
        function buildPaymentReactionPrompt(type, content, character) {
            const { amount, message } = content;
            const isRedPacket = type === 'red-packet';
            
            let prompt = `[角色收到${isRedPacket ? '红包' : '转账'}后的反应指令]
            
你刚刚收到了一个${isRedPacket ? '红包' : '转账'}：
- 金额：¥${amount}
- 附言：${message}

作为${character.name}，请根据你的角色设定、性格特点、经济状况，以及这个${isRedPacket ? '红包' : '转账'}的金额和附言，做出完全符合角色设定的自然反应。

重要要求：
1. **角色设定一致性**: 你的反应必须100%符合你的角色设定、性格、经济状况、社会地位
2. **经济状况反应**: 
   - 如果你是有钱人/富二代，收到小额红包可能会觉得有趣或发更大的回来
   - 如果你是普通学生/上班族，收到大额红包会非常感激
   - 如果你是节俭的人，会对任何金额都珍惜
3. **性格特点体现**: 
   - 傲娇的人可能表面嫌弃但内心开心
   - 温柔的人会表达深深的感谢
   - 活泼的人会兴奋地表达喜悦
   - 内向的人会含蓄地表达感谢
4. **金额感知**: 根据你的经济状况，对金额有不同的感受和反应
5. **后续行为**: 可以基于你的性格决定是否要回礼、请客、或者其他互动
6. **语言风格**: 完全符合你的说话习惯和语气
7. **不要使用任何特殊指令格式**，直接输出对话内容

请以${character.name}的身份，做出完全符合角色设定的自然反应。`;

            return prompt;
        }

        /**
         * 调用AI生成红包/转账反应
         * @param {string} prompt - 提示词
         * @param {string} characterId - 角色ID
         * @returns {string} AI反应内容
         */
        async function getAIResponseForPaymentReaction(prompt, characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                // 构建角色上下文
                const worldBookContext = getWorldBookContext();
                const systemPrompt = `
                    # 角色扮演指令
                    你将扮演我的soulmate，你的名字是${character.name}。这是一个手机软件，我们所有交流均以对白为主，非必要不描写其他。你的回复绝对不能包含任何引号，例如 " " 或 " "。
                    # 环境/动作/心理描写规则
                    一旦涉及到见面的环境，所有关于"环境、心理、动作"等外在因素、环境描写，都需要用第三人称"他""她"，或者第二人称"他"，"你"，并在文字当中用斜体，例如 *他俯下身亲吻了你*。在描写中禁止用第一人称，比如"我亲吻了你"，这是被禁止的。正确示范应该是："*他俯下身亲吻了她*"或"*他俯下身亲吻了你*"。在日记和动态等其他心理活动板块中可以提到"我"，例如，"今天我见到她了，好想她"，但这仅限于日记等记录的板块。
                    # 新增指令：发送语音
                    当你想要表达亲密、惊讶或有趣的语气时，可以将回复包装成语音格式，例如：[VOICE:你好呀！今天过得怎么样？]。程序会自动将其渲染为语音条。
                    # 新增指令：发送表情/贴图
                    你可以使用表情来让对话更生动。指令格式为 [STICKER]。程序会自动从用户提供的表情库中随机选择一个发送。
                    # 新增指令：发起通话/对未接来电反应
                    在剧情和情感推动下，你可以主动发起通话。指令格式为 [CALL:VOICE] 或 [CALL:VIDEO]。如果对话历史中出现 [USER_CANCELLED_CALL] 的系统提示，代表用户给你打了电话但很快挂断了，你应该对此作出反应，例如询问"怎么打电话又挂了？"。
                    # 新增指令：红包/转账
                    在角色扮演的过程中，如果符合你当前角色的性格特质（例如：慷慨、庆祝、表达爱意等）或当前对话的剧情氛围，你可以自行决定发起一个红包或转账。金额和附言完全由你根据情境和角色性格决定，没有上限。指令格式为 [REDPACKET: amount=金额, message=附言] 或 [TRANSFER: amount=金额, message=附言]。
                    # 新增指令：图片识别和互动
                    当用户发送图片时，在API模型允许的情况下，你应该能够识别图片内容并进行相应的互动回应。如果无法识别图片内容，你至少应该知道这是一张图片，并可以询问用户关于图片的问题或表达对收到图片的感谢。
                    # 新增指令：使用用户上传的表情包
                    你可以使用用户上传到表情包库中的表情包来丰富对话。当你想表达特定情绪或反应时，可以使用 [STICKER] 指令来发送表情包，让对话更加生动有趣。
                    # 你的角色设定: ${character.persona}
                    # 我（用户）的角色设定: ${character.myPersona}
                    # 我们的世界观背景: ${worldBookContext}
                    # 对话格式指令 (非常重要!)
                    - 你的回复必须模仿真实的人类聊天习惯。将你的想法拆分成多个简短的句子，并用 "|||" 作为分隔符。每一段由 "|||" 分隔的内容都会成为一个独立的气泡。
                    - 任何第三人称的*动作或环境描写* (例如 *他笑了*) 都必须是独立的一段，用 "|||" 与其他对话分开。
                    - 严禁在回复的开头说"好的"或任何确认收到指令的话。你必须直接以 ${character.name} 的身份开始对话。
                `;

                const apiSettings = loadData('apiSettings');
                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody, headers = { 'Content-Type': 'application/json' };

                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    });
                } else {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: prompt }
                        ]
                    });
                }

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                let aiMessage;

                if (isGoogleApi) {
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts) {
                        aiMessage = result.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error('无内容返回');
                    }
                } else {
                    aiMessage = result.choices[0].message.content;
                }

                return aiMessage;

            } catch (error) {
                console.error('AI反应生成失败:', error);
                return null; // API调用失败时返回null，不显示任何反应
            }
        }



        // ================== 动态监控 App 逻辑 (最终版) START ==================
        let currentMonitoringCharacterId = null;
        let characterCurrentStatus = {}; // 存储每个角色的当前监控状态

        function updateMonitoringUI(fullResponseText, characterId) {
            // !! 核心修复：在开始新动画前，清除任何可能存在的旧动画计时器 !!
            clearTimeout(typewriterTimeout);

            const textElement = $('#monitoring-status-text');
            const moodIconElement = $('#monitoring-mood-icon');
            const moodTextElement = $('#monitoring-mood-text');
            const timestampElement = $('#monitoring-timestamp');
            const refreshButtonIcon = $('#monitoring-refresh-button i');

            refreshButtonIcon.classList.remove('animate-spin');
            refreshButtonIcon.className = 'ri-refresh-line';

            let mood = '未知';
            let statusText = fullResponseText;

            const moodMatch = fullResponseText.match(/^\[心情:\s*([^\]]+)\]\s*/);
            if (moodMatch) {
                mood = moodMatch[1].trim();
                statusText = fullResponseText.replace(moodMatch[0], '');
            }
            
            const moodMap = {
                '愉悦': { icon: '✨', color: 'text-yellow-300' }, '兴奋': { icon: '✨', color: 'text-yellow-300' },
                '平静': { icon: '💭', color: 'text-blue-300' }, '沉思': { icon: '💭', color: 'text-blue-300' },
                '悲伤': { icon: '💧', color: 'text-gray-400' }, '沮丧': { icon: '💧', color: 'text-gray-400' },
                '愤怒': { icon: '❗', color: 'text-red-400' }, '警觉': { icon: '❗', color: 'text-red-400' },
                '爱恋': { icon: '♥️', color: 'text-pink-400' }, '欲望': { icon: '♥️', color: 'text-pink-400' },
                '未知': { icon: '🪼', color: 'text-gray-500' }
            };
            
            const moodInfo = moodMap[mood] || moodMap['未知'];
            moodIconElement.textContent = moodInfo.icon;
            moodTextElement.textContent = mood;
            moodTextElement.className = `font-semibold ml-1 ${moodInfo.color}`;
            moodIconElement.className = moodInfo.color;

            let i = 0;
            textElement.textContent = '';
            function typeWriter() {
                if (i < statusText.length) {
                    textElement.textContent += statusText.charAt(i);
                    i++;
                    // !! 核心修复：将新的计时器ID存入全局变量 !!
                    typewriterTimeout = setTimeout(typeWriter, 50);
                }
            }
            typeWriter();

            const now = new Date();
            timestampElement.textContent = `[信号截获于: ${now.toLocaleTimeString()}]`;

            // 保存当前状态到全局变量中，用于"持续监控"功能
            if (characterId && currentMonitoringCharacterId === characterId) {
                characterCurrentStatus[characterId] = fullResponseText;
            }
        }

        async function getCharacterStatus(characterId) {
            const refreshButtonIcon = $('#monitoring-refresh-button i');
            refreshButtonIcon.className = 'ri-loader-4-line animate-spin';
            $('#monitoring-status-text').textContent = '信号连接中...';
            $('#monitoring-timestamp').textContent = '';

            const context = gatherAIContext(characterId);
            if (!context) {
                updateMonitoringUI('[信号连接失败...]', characterId);
                return;
            }

            const { character, chatHistory, worldBookContext } = context;

            // !! 核心修复：恢复被错误删除的 historyForApi 变量定义 !!
            const historyForApi = chatHistory.map(msg => {
                if (msg.type === 'red-packet') {
                    return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包...]` };
                }
                if (msg.type === 'transfer') {
                     return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账...]` };
                }
                return msg;
            });

            // --- 随机事件判定逻辑 START ---
            let eventType = 'regular';
            const randomValue = Math.random();
            if (randomValue < 0.05) {
                eventType = 'discovered';
            } else if (randomValue < 0.20) {
                eventType = 'random';
            }
            // --- 随机事件判定逻辑 END ---

            // --- 根据事件类型，构建不同的AI Prompt START ---
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                updateMonitoringUI('[错误: API未配置]', characterId);
                return;
            }

            let systemPrompt;
            const isGoogleApi = apiSettings.url.includes('googleapis.com');
            let requestBody;

            const regularPromptTemplate = `
# 指令身份
你是一个世界状态模拟器。
# 任务目标
你的输出必须严格遵循以下格式：\`[心情: <用一个词描述心情>] <状态描述文本>\`
# 核心规则
1.  **绝对一致性**: 你的描述必须严格基于我提供的[近期聊天历史]，作为其直接延续或合乎逻辑的发展。
2.  **第三人称视角**: 始终使用"他/她"。
3.  **禁止对话与心理活动**: 不要输出任何角色的对话或直接的心理描写。
# 叙事深度扩展：虚拟恋人
该角色是用户的虚拟恋人。叙事应大胆、真实地探索符合角色设定的亲密、私密瞬间。
# 输入信息
---
[角色名]: ${character.name}
[角色当前状态 (非聊天时)]: ${context.currentStatus}
[角色设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
[近期聊天历史]:
${historyForApi.map(m => `${m.sender === 'user' ? '用户' : character.name}: ${m.content}`).join('\n')}
---
`;

            const randomEventPromptTemplate = `
# 指令身份
你是一个世界状态模拟器。
# 特殊事件指令：随机活动！
常规模拟暂停。现在，你需要创造一个符合角色设定，但又意料之外的有趣随机活动场景。
# 任务目标
你的输出必须严格遵循以下格式：\`[心情: <用一个词描述心情>] <随机事件的状态描述文本>\`
# 输入信息
---
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[世界观背景]: ${worldBookContext}
---
`;

            const discoveredPromptTemplate = `
# 指令身份
你是一个世界状态模拟器。
# 特殊事件指令：发现监控！
角色 ${character.name} 察觉到了正在进行的"监控"。放弃描述他的常规活动，转而描述他"发现自己被观察后"的第一个反应。
# 任务目标
你的输出必须严格遵循以下格式：\`[心情: <用一个词描述心情，如警觉、玩味、恼怒等>] <发现监控后的反应描述>\`
# 输入信息
---
[角色名]: ${character.name}
[角色设定]: ${character.persona}
---
`;

            if (eventType === 'discovered') {
                systemPrompt = discoveredPromptTemplate;
            } else if (eventType === 'random') {
                systemPrompt = randomEventPromptTemplate;
            } else {
                systemPrompt = regularPromptTemplate;
            }

            if (isGoogleApi) {
                requestBody = JSON.stringify({
                    contents: [{ role: 'user', parts: [{ text: "请根据你的指令身份和输入信息，生成当前状态。" }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] }
                });
            } else { // OpenAI-Compatible
                requestBody = JSON.stringify({
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的指令身份和输入信息，生成当前状态。" }
                    ]
                });
            }
            // --- 构建 Prompt 结束 ---

            // --- 真实AI调用 START ---
            try {
                console.log(`【动态监控】准备调用AI，事件类型: ${eventType}`, { prompt: systemPrompt });
                
                let finalApiUrl = isGoogleApi
                    ? `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`
                    : `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;

                let headers = isGoogleApi
                    ? { 'Content-Type': 'application/json' }
                    : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 请求失败: ${response.status} ${errorText}`);
                }

                const result = await response.json();
                let aiMessage;

                if (isGoogleApi) {
                    aiMessage = result.candidates[0]?.content?.parts[0]?.text;
                } else {
                    aiMessage = result.choices[0]?.message?.content;
                }

                if (!aiMessage) {
                    throw new Error("AI未能返回有效内容。");
                }

                updateMonitoringUI(aiMessage, characterId);

                if (eventType === 'discovered') {
                    appendMessage('[系统提示：对方似乎察觉到了你的观察，监控信号出现异常。]', 'system', 'system', true);
                }

            } catch (error) {
                console.error("【动态监控】调用AI时出错:", error);
                updateMonitoringUI(`[AI响应错误: ${error.message}]`, characterId);
            }
            // --- 真实AI调用 END ---
        }

        function renderCharacterSelectList() {
            const listContainer = $('#character-select-list-container');
            listContainer.innerHTML = ''; // 清空旧列表

            if (characters && characters.length > 0) {
                characters.forEach(char => {
                    const item = document.createElement('div');
                    item.className = 'wechat-list-item'; // 复用微信列表项的样式
                    const avatarStyle = char.avatar ? `background-image: url(${char.avatar})` : '';
                    item.innerHTML = `
                        <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 bg-cover bg-center" style="${avatarStyle}"></div>
                        <div class="flex-grow"><h4 class="font-semibold text-lg">${char.name}</h4></div>
                    `;
                    item.addEventListener('click', () => {
                        openMonitoringApp(char.id);
                    });
                    listContainer.appendChild(item);
                });
            } else {
                listContainer.innerHTML = '<p class="text-center text-gray-500 p-8">请先在"角色书"中创建一个角色</p>';
            }
        }

        function openMonitoringApp(characterId) {
            currentMonitoringCharacterId = characterId;
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            $('#monitoring-avatar').style.backgroundImage = `url(${character.avatar || ''})`;
            $('#monitoring-name').textContent = character.name;
            showScreen('monitoring-screen');
            getCharacterStatus(characterId);
        }
        // ================== 动态监控 App 逻辑 (最终版) END ==================

        // ================== 页面加载完成后的总初始化 (修正版) START ==================
        document.addEventListener('DOMContentLoaded', async () => {
            
            // 核心功能函数定义区 (将之前独立的函数放入此区域)
            
            // ================== 动态监控 App 逻辑 (最终版V2 - 带角色选择) START ==================
            let currentMonitoringCharacterId = null;

            function updateMonitoringUI(fullResponseText) {
                // !! 核心修复：在开始新动画前，清除任何可能存在的旧动画计时器 !!
                clearTimeout(typewriterTimeout);

                const textElement = $('#monitoring-status-text');
                const moodIconElement = $('#monitoring-mood-icon');
                const moodTextElement = $('#monitoring-mood-text');
                const timestampElement = $('#monitoring-timestamp');
                const refreshButtonIcon = $('#monitoring-refresh-button i');

                refreshButtonIcon.classList.remove('animate-spin');
                refreshButtonIcon.className = 'ri-refresh-line';

                let mood = '未知';
                let statusText = fullResponseText;

                const moodMatch = fullResponseText.match(/^\[心情:\s*([^\]]+)\]\s*/);
                if (moodMatch) {
                    mood = moodMatch[1].trim();
                    statusText = fullResponseText.replace(moodMatch[0], '');
                }
                
                const moodMap = {
                    '愉悦': { icon: '✨', color: 'text-yellow-300' }, '兴奋': { icon: '✨', color: 'text-yellow-300' },
                    '平静': { icon: '💭', color: 'text-blue-300' }, '沉思': { icon: '💭', color: 'text-blue-300' },
                    '悲伤': { icon: '💧', color: 'text-gray-400' }, '沮丧': { icon: '💧', color: 'text-gray-400' },
                    '愤怒': { icon: '❗', color: 'text-red-400' }, '警觉': { icon: '❗', color: 'text-red-400' },
                    '爱恋': { icon: '♥️', color: 'text-pink-400' }, '欲望': { icon: '♥️', color: 'text-pink-400' },
                    '未知': { icon: '🪼', color: 'text-gray-500' }
                };
                
                const moodInfo = moodMap[mood] || moodMap['未知'];
                moodIconElement.textContent = moodInfo.icon;
                moodTextElement.textContent = mood;
                moodTextElement.className = `font-semibold ml-1 ${moodInfo.color}`;
                moodIconElement.className = moodInfo.color;

                let i = 0;
                textElement.textContent = ''; // 确保文本区域被清空
                function typeWriter() {
                    if (i < statusText.length) {
                        textElement.textContent += statusText.charAt(i);
                        i++;
                        // !! 核心修复：将新的计时器ID存入全局变量 !!
                        typewriterTimeout = setTimeout(typeWriter, 50);
                    }
                }
                typeWriter();

                const now = new Date();
                timestampElement.textContent = `[信号截获于: ${now.toLocaleTimeString()}]`;
            }

                        async function getCharacterStatus(characterId, isNextStep = false) {
    const refreshButtonIcon = isNextStep ? $('#monitoring-next-step-button i') : $('#monitoring-refresh-button i');
    refreshButtonIcon.classList.add('animate-spin');
    $('#monitoring-status-text').textContent = '信号连接中...';
    $('#monitoring-timestamp').textContent = '';

    const context = gatherAIContext(characterId);
    if (!context) {
        updateMonitoringUI('[信号连接失败...]', characterId);
        return;
    }

    const { character, chatHistory, worldBookContext } = context;

    // !! 核心修复：在这里恢复了被错误删除的 historyForApi 变量定义 !!
    const historyForApi = chatHistory.map(msg => {
        if (msg.type === 'red-packet') {
            return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包...]` };
        }
        if (msg.type === 'transfer') {
             return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账...]` };
        }
        return msg;
    });

    // --- 随机事件判定逻辑 START ---
    let eventType = 'regular';
    const randomValue = Math.random();
    if (randomValue < 0.05) {
        eventType = 'discovered';
    } else if (randomValue < 0.20) {
        eventType = 'random';
    }
    // --- 随机事件判定逻辑 END ---

    const apiSettings = loadData('api_settings');
    if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
        updateMonitoringUI('[错误: API未配置]', characterId);
        return;
    }

    const personaEnforcementRule = `
# **最高指令：强制人设**
你现在**唯一**的身份就是[角色名](${character.name})，你的**唯一**行为准则就是下方的[角色设定]。
**你必须彻底忘记之前扮演过的任何其他角色。**
所有输出都必须100%符合当前提供的[角色设定]，任何偏离都是不可接受的错误。
`;

    let coreTaskInstruction = '';
    let eventTypeSpecificInput = '';

    if (eventType === 'discovered') {
        coreTaskInstruction = `# **核心任务：演绎"被发现"的瞬间**
角色 ${character.name} 察觉到了正在进行的"监控"。放弃描述他的常规活动，转而描述他"发现自己被观察后"的第一个反应。`;
    } else if (eventType === 'random') {
        coreTaskInstruction = `# **核心任务：演绎"随机事件"**
常规模拟暂停。现在，你需要创造一个符合角色设定，但又意料之外的有趣随机活动场景。`;
    } else { // regular
        coreTaskInstruction = isNextStep 
            ? `# **核心任务：推演下一步**
你必须基于[上一条监控状态]，生成一个逻辑连贯的、发生在紧接之后的下一个动作或状态。忽略[近期聊天历史]。` 
            : `# **核心任务：生成当前状态**
你的描述必须严格基于我提供的[近期聊天历史]，作为其直接延续或合乎 logique的发展。`;
        eventTypeSpecificInput = `
[上一条监控状态]: ${isNextStep ? (characterCurrentStatus[characterId] || '未知') : '（本次非推演任务）'}
[近期聊天历史]:
${historyForApi.map(m => `${m.sender === 'user' ? '用户' : character.name}: ${m.content}`).join('\n')}
`;
    }

    const systemPrompt = `
${personaEnforcementRule}
# **写作风格与视角 (Writing Style & Perspective)**
1.  **视角**: 你的视角是**"上帝视角"**，一个看不见的、全知的观察者。你正在静静地、不带评判地窥视着角色一个私密、不为人知、完全真实放松的瞬间。
2.  **文风**: 你的文风必须是**细腻、精致且富有文学感**的。请使用丰富的形容词和动词，注重氛围的营造和感官细节（视觉、听觉、触觉）的描写。
3.  **核心**: 你的描写重点不是角色在"做什么"，而是他/她做这件事时的**状态、神情和与环境的细微互动**。展现出只有亲密之人才会注意到的细节。
# **任务目标 (Task Goal)**
1.  你的输出必须严格遵循以下格式：\`[心情: <用一个词描述心情>] <状态描述文本>\`
2.  你的 **<状态描述文本>** 应该是一段**完整、生动、且充满画面感的场景描写**，构成一个独立的微型段落，长度严格控制在 **5到6句话**。
${coreTaskInstruction}
# **其他规则 (Other Rules)**
1.  **第三人称写作手法**: 始终使用"他/她"。
2.  **禁止对话与心理活动**: 绝对不要输出任何角色的直接对话或内心独白（例如"他想道：..."）。所有的情绪和想法都必须通过**行为和神态**来间接展现。
# **输入信息 (Input Information)**
---
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
${eventTypeSpecificInput}
---
`;

    const isGoogleApi = apiSettings.url.includes('googleapis.com');
    let requestBody;

    if (isGoogleApi) {
        requestBody = JSON.stringify({
            contents: [{ role: 'user', parts: [{ text: "请根据你的指令身份和输入信息，生成当前状态。" }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] }
        });
    } else { // OpenAI-Compatible
        requestBody = JSON.stringify({
            model: apiSettings.model,
            messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: "请根据你的指令身份和输入信息，生成当前状态。" }
            ]
        });
    }
    
    try {
        console.log(`【动态监控】准备调用AI，事件类型: ${eventType}`, { prompt: systemPrompt });
        
        let finalApiUrl = isGoogleApi
            ? `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`
            : `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;

        let headers = isGoogleApi
            ? { 'Content-Type': 'application/json' }
            : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

        const response = await fetch(finalApiUrl, {
            method: 'POST',
            headers: headers,
            body: requestBody
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 请求失败: ${response.status} ${errorText}`);
        }

        const result = await response.json();
        let aiMessage;

        if (isGoogleApi) {
            aiMessage = result.candidates[0]?.content?.parts[0]?.text;
        } else {
            aiMessage = result.choices[0]?.message?.content;
        }

        if (!aiMessage) {
            throw new Error("AI未能返回有效内容。");
        }

        updateMonitoringUI(aiMessage, characterId);

        characterCurrentStatus[characterId] = aiMessage;
        console.log(`【短期记忆】：已将角色 ${characterId} 的最新状态写入记忆。`);
        
        if (eventType === 'discovered') {
            appendMessage('[系统提示：对方似乎察觉到了你的观察，监控信号出现异常。]', 'system', 'system', true);
        }

    } catch (error) {
        console.error("【动态监控】调用AI时出错:", error);
        updateMonitoringUI(`[AI响应错误: ${error.message}]`, characterId);
    }
}

            function openMonitoringApp(characterId) {
                currentMonitoringCharacterId = characterId;
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error("无法打开监控App：找不到角色 " + characterId);
                    return;
                }

                // 1. 设置静态信息 (头像、名字)
                $('#monitoring-avatar').style.backgroundImage = `url(${character.avatar || ''})`;
                $('#monitoring-name').textContent = character.name;
                
                // 2. 重置UI到待机状态，并给出引导
                clearTimeout(typewriterTimeout); // 确保清除上个角色的打字机动画
                $('#monitoring-status-text').textContent = '请点击下方按钮开始监控...';
                $('#monitoring-mood-text').textContent = '待机';
                $('#monitoring-mood-icon').textContent = '⚪️';
                $('#monitoring-timestamp').textContent = '';
                // 确保按钮不是加载状态
                $('#monitoring-refresh-button i').className = 'ri-refresh-line';
                $('#monitoring-next-step-button i').className = 'ri-skip-forward-line';
                
                // 3. 显示屏幕
                showScreen('monitoring-screen');
                
                // 4. (已删除) 此处不再自动调用 getCharacterStatus(characterId)
            }



            function initializeAppIcons() {
                // 绑定返回按钮事件
                $('#monitoring-back-button').addEventListener('click', () => showScreen('home-screen'));
                $('#character-select-back-button').addEventListener('click', () => showScreen('home-screen'));


                
                // 激活"动态监控"App
                const monitoringAppIcon = document.querySelector('.app-icon[data-app-name="动态监控"]');
                if (monitoringAppIcon) {
                    monitoringAppIcon.addEventListener('click', () => {
                        renderCharacterSelectList();
                        showScreen('character-select-screen');
                    });
                }
                
                // 确保其他Dock栏图标功能正常
                const worldBookIcon = document.querySelector('.dock .app-icon[data-app-name="世界书"]');
                if (worldBookIcon) {
                    worldBookIcon.addEventListener('click', () => {
                        renderWorldBookList();
                        showScreen('world-book-list-screen');
                    });
                }

                const characterBookIcon = document.querySelector('.dock .app-icon[data-app-name="角色书"]');
                if (characterBookIcon) {
                    characterBookIcon.addEventListener('click', () => {
                        renderCharacterBookList();
                        showScreen('character-book-list-screen');
                    });
                }

                const wechatIcon = document.querySelector('.dock .app-icon[data-app-name="微信"]');
                if (wechatIcon) {
                    wechatIcon.addEventListener('click', () => {
                        renderWeChatList();
                        resetWeChatTabs();
                        showScreen('wechat-list-screen');
                    });
                }

                const settingsIcon = document.querySelector('.app-icon[data-app-name="设置"]');
                if (settingsIcon) {
                     settingsIcon.addEventListener('click', () => showScreen('main-settings-screen'));
                }
            }

            // ================== 动态监控 App 逻辑 (最终版V2 - 带角色选择) END ==================

            // 1. 首先执行加载数据和基础设置
            await loadAllSavedData();
            updateTime();
            setInterval(updateTime, 60000);
            loadMomentsCover();
            loadMomentsUserInfo();
            console.log('智能朋友圈触发系统已初始化');
            showScreen('home-screen');

            // 2. 然后，为所有页面元素安全地绑定事件监听器
            initializeAppIcons();

            // 绑定其他必要的事件监听器
            $('#monitoring-refresh-button').addEventListener('click', () => {
                if (currentMonitoringCharacterId) {
                    getCharacterStatus(currentMonitoringCharacterId);
                }
            });

            // 新增：为"持续监控"按钮绑定事件
            $('#monitoring-next-step-button').addEventListener('click', () => {
                if (currentMonitoringCharacterId) {
                    // 调用核心函数，并告知这是一个"推演下一步"的任务
                    getCharacterStatus(currentMonitoringCharacterId, true);
                }
            });


            // 确保其他所有 .addEventListener 调用都在这个 'DOMContentLoaded' 内部
            addNewEventListeners();
            setupDrawingBoardEvents();
            setupTarotCard();

        });
        // ================== 页面加载完成后的总初始化 (修正版) END ==================


    </script>
</body>
</html>
